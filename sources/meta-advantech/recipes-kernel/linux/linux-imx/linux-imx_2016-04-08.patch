Index: kernel/power/process.c
===================================================================
diff --git a/kernel/power/process.c b/kernel/power/process.c
--- a/kernel/power/process.c	(revision 513)
+++ b/kernel/power/process.c	(revision 1734)
@@ -22,7 +22,9 @@
  * Timeout for stopping processes
  */
 unsigned int __read_mostly freeze_timeout_msecs = 20 * MSEC_PER_SEC;
-
+#ifdef CONFIG_ARCH_ADVANTECH
+extern char suspend_key_flag;
+#endif
 static int try_to_freeze_tasks(bool user_only)
 {
 	struct task_struct *g, *p;
@@ -185,6 +187,10 @@
 	usermodehelper_enable();
 
 	schedule();
+#ifdef CONFIG_ARCH_ADVANTECH
+	suspend_key_flag=0;
+	printk( "suspend_key_flag=0.\n");
+#endif
 	printk("done.\n");
 }
 
Index: crypto/testmgr.c
===================================================================
diff --git a/crypto/testmgr.c b/crypto/testmgr.c
--- a/crypto/testmgr.c	(revision 513)
+++ b/crypto/testmgr.c	(revision 1734)
@@ -190,13 +190,20 @@
 	const char *algo = crypto_tfm_alg_driver_name(crypto_ahash_tfm(tfm));
 	unsigned int i, j, k, temp;
 	struct scatterlist sg[8];
-	char result[64];
+	char *result;
+	char *key;
 	struct ahash_request *req;
 	struct tcrypt_result tresult;
 	void *hash_buff;
 	char *xbuf[XBUFSIZE];
 	int ret = -ENOMEM;
 
+	result = kmalloc(MAX_DIGEST_SIZE, GFP_KERNEL);
+	if (!result)
+		return ret;
+	key = kmalloc(MAX_KEYLEN, GFP_KERNEL);
+	if (!key)
+		goto out_nobuf;
 	if (testmgr_alloc_buf(xbuf))
 		goto out_nobuf;
 
@@ -217,7 +224,7 @@
 			continue;
 
 		j++;
-		memset(result, 0, 64);
+		memset(result, 0, MAX_DIGEST_SIZE);
 
 		hash_buff = xbuf[0];
 
@@ -226,8 +233,14 @@
 
 		if (template[i].ksize) {
 			crypto_ahash_clear_flags(tfm, ~0);
-			ret = crypto_ahash_setkey(tfm, template[i].key,
-						  template[i].ksize);
+			if (template[i].ksize > MAX_KEYLEN) {
+				pr_err("alg: hash: setkey failed on test %d for %s: key size %d > %d\n",
+				       j, algo, template[i].ksize, MAX_KEYLEN);
+				ret = -EINVAL;
+				goto out;
+			}
+			memcpy(key, template[i].key, template[i].ksize);
+			ret = crypto_ahash_setkey(tfm, key, template[i].ksize);
 			if (ret) {
 				printk(KERN_ERR "alg: hash: setkey failed on "
 				       "test %d for %s: ret=%d\n", j, algo,
@@ -283,7 +296,7 @@
 	for (i = 0; i < tcount; i++) {
 		if (template[i].np) {
 			j++;
-			memset(result, 0, 64);
+			memset(result, 0, MAX_DIGEST_SIZE);
 
 			temp = 0;
 			sg_init_table(sg, template[i].np);
@@ -302,8 +315,16 @@
 			}
 
 			if (template[i].ksize) {
+				if (template[i].ksize > MAX_KEYLEN) {
+					pr_err("alg: hash: setkey failed on test %d for %s: key size %d > %d\n",
+					       j, algo, template[i].ksize,
+					       MAX_KEYLEN);
+					ret = -EINVAL;
+					goto out;
+				}
 				crypto_ahash_clear_flags(tfm, ~0);
-				ret = crypto_ahash_setkey(tfm, template[i].key,
+				memcpy(key, template[i].key, template[i].ksize);
+				ret = crypto_ahash_setkey(tfm, key,
 							  template[i].ksize);
 
 				if (ret) {
@@ -355,6 +376,8 @@
 out_noreq:
 	testmgr_free_buf(xbuf);
 out_nobuf:
+	kfree(key);
+	kfree(result);
 	return ret;
 }
 
@@ -377,16 +400,21 @@
 	void *input;
 	void *output;
 	void *assoc;
-	char iv[MAX_IVLEN];
+	char *iv;
 	char *xbuf[XBUFSIZE];
 	char *xoutbuf[XBUFSIZE];
 	char *axbuf[XBUFSIZE];
 
+	iv = kzalloc(MAX_IVLEN, GFP_KERNEL);
+	if (!iv)
+		return ret;
+	key = kmalloc(MAX_KEYLEN, GFP_KERNEL);
+	if (!key)
+		goto out_noxbuf;
 	if (testmgr_alloc_buf(xbuf))
 		goto out_noxbuf;
 	if (testmgr_alloc_buf(axbuf))
 		goto out_noaxbuf;
-
 	if (diff_dst && testmgr_alloc_buf(xoutbuf))
 		goto out_nooutbuf;
 
@@ -446,7 +474,14 @@
 				crypto_aead_set_flags(
 					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 
-			key = template[i].key;
+			if (template[i].klen > MAX_KEYLEN) {
+				pr_err("alg: aead%s: setkey failed on test %d for %s: key size %d > %d\n",
+				       d, j, algo, template[i].klen,
+				       MAX_KEYLEN);
+				ret = -EINVAL;
+				goto out;
+			}
+			memcpy(key, template[i].key, template[i].klen);
 
 			ret = crypto_aead_setkey(tfm, key,
 						 template[i].klen);
@@ -542,7 +577,14 @@
 			if (template[i].wk)
 				crypto_aead_set_flags(
 					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
-			key = template[i].key;
+			if (template[i].klen > MAX_KEYLEN) {
+				pr_err("alg: aead%s: setkey failed on test %d for %s: key size %d > %d\n",
+				       d, j, algo, template[i].klen,
+				       MAX_KEYLEN);
+				ret = -EINVAL;
+				goto out;
+			}
+			memcpy(key, template[i].key, template[i].klen);
 
 			ret = crypto_aead_setkey(tfm, key, template[i].klen);
 			if (!ret == template[i].fail) {
@@ -726,6 +768,8 @@
 out_noaxbuf:
 	testmgr_free_buf(xbuf);
 out_noxbuf:
+	kfree(key);
+	kfree(iv);
 	return ret;
 }
 
Index: crypto/testmgr.h
===================================================================
diff --git a/crypto/testmgr.h b/crypto/testmgr.h
--- a/crypto/testmgr.h	(revision 513)
+++ b/crypto/testmgr.h	(revision 1734)
@@ -32,7 +32,7 @@
 #define MAX_DIGEST_SIZE		64
 #define MAX_TAP			8
 
-#define MAX_KEYLEN		56
+#define MAX_KEYLEN		160
 #define MAX_IVLEN		32
 
 struct hash_testvec {
Index: include/linux/regulator/pfuze100.h
===================================================================
diff --git a/include/linux/regulator/pfuze100.h b/include/linux/regulator/pfuze100.h
--- a/include/linux/regulator/pfuze100.h	(revision 513)
+++ b/include/linux/regulator/pfuze100.h	(revision 1734)
@@ -35,6 +35,20 @@
 #define PFUZE100_VGEN6		14
 #define PFUZE100_MAX_REGULATOR	15
 
+#define PFUZE200_SW1AB		0
+#define PFUZE200_SW2		1
+#define PFUZE200_SW3A		2
+#define PFUZE200_SW3B		3
+#define PFUZE200_SWBST		4
+#define PFUZE200_VSNVS		5
+#define PFUZE200_VREFDDR	6
+#define PFUZE200_VGEN1		7
+#define PFUZE200_VGEN2		8
+#define PFUZE200_VGEN3		9
+#define PFUZE200_VGEN4		10
+#define PFUZE200_VGEN5		11
+#define PFUZE200_VGEN6		12
+
 struct regulator_init_data;
 
 struct pfuze_regulator_platform_data {
Index: include/linux/power/ec_battery.h
===================================================================
diff --git a/include/linux/power/ec_battery.h b/include/linux/power/ec_battery.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/linux/power/ec_battery.h	(revision 1734)
@@ -0,0 +1,39 @@
+/*
+ * Gas Gauge driver for TI's BQ20Z75
+ *
+ * Copyright (c) 2010, NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef __LINUX_POWER_BQ20Z75_H_
+#define __LINUX_POWER_BQ20Z75_H_
+
+#include <linux/power_supply.h>
+#include <linux/types.h>
+
+/**
+ * struct bq20z75_platform_data - platform data for bq20z75 devices
+ * @battery_detect:		GPIO which is used to detect battery presence
+ * @battery_detect_present:	gpio state when battery is present (0 / 1)
+ * @i2c_retry_count:		# of times to retry on i2c IO failure
+ */
+struct bq20z75_platform_data {
+	int battery_detect;
+	int battery_detect_present;
+	int i2c_retry_count;
+};
+
+#endif
Index: sound/soc/codecs/sgtl5000.c
===================================================================
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
--- a/sound/soc/codecs/sgtl5000.c	(revision 513)
+++ b/sound/soc/codecs/sgtl5000.c	(revision 1734)
@@ -16,6 +16,7 @@
 #include <linux/pm.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
+#include <linux/regmap.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 #include <linux/regulator/consumer.h>
@@ -34,30 +35,30 @@
 #define SGTL5000_MAX_REG_OFFSET	0x013A
 
 /* default value of sgtl5000 registers */
-static const u16 sgtl5000_regs[SGTL5000_MAX_REG_OFFSET] =  {
-	[SGTL5000_CHIP_CLK_CTRL] = 0x0008,
-	[SGTL5000_CHIP_I2S_CTRL] = 0x0010,
-	[SGTL5000_CHIP_SSS_CTRL] = 0x0010,
-	[SGTL5000_CHIP_DAC_VOL] = 0x3c3c,
-	[SGTL5000_CHIP_PAD_STRENGTH] = 0x015f,
-	[SGTL5000_CHIP_ANA_HP_CTRL] = 0x1818,
-	[SGTL5000_CHIP_ANA_CTRL] = 0x0111,
-	[SGTL5000_CHIP_LINE_OUT_VOL] = 0x0404,
-	[SGTL5000_CHIP_ANA_POWER] = 0x7060,
-	[SGTL5000_CHIP_PLL_CTRL] = 0x5000,
-	[SGTL5000_DAP_BASS_ENHANCE] = 0x0040,
-	[SGTL5000_DAP_BASS_ENHANCE_CTRL] = 0x051f,
-	[SGTL5000_DAP_SURROUND] = 0x0040,
-	[SGTL5000_DAP_EQ_BASS_BAND0] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND1] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND2] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND3] = 0x002f,
-	[SGTL5000_DAP_EQ_BASS_BAND4] = 0x002f,
-	[SGTL5000_DAP_MAIN_CHAN] = 0x8000,
-	[SGTL5000_DAP_AVC_CTRL] = 0x0510,
-	[SGTL5000_DAP_AVC_THRESHOLD] = 0x1473,
-	[SGTL5000_DAP_AVC_ATTACK] = 0x0028,
-	[SGTL5000_DAP_AVC_DECAY] = 0x0050,
+static const struct reg_default sgtl5000_reg_defaults[] = {
+	{ SGTL5000_CHIP_CLK_CTRL,		0x0008 },
+	{ SGTL5000_CHIP_I2S_CTRL,		0x0010 },
+	{ SGTL5000_CHIP_SSS_CTRL,		0x0010 },
+	{ SGTL5000_CHIP_DAC_VOL,		0x3c3c },
+	{ SGTL5000_CHIP_PAD_STRENGTH,		0x015f },
+	{ SGTL5000_CHIP_ANA_HP_CTRL,		0x1818 },
+	{ SGTL5000_CHIP_ANA_CTRL,		0x0111 },
+	{ SGTL5000_CHIP_LINE_OUT_VOL,		0x0404 },
+	{ SGTL5000_CHIP_ANA_POWER,		0x7060 },
+	{ SGTL5000_CHIP_PLL_CTRL,		0x5000 },
+	{ SGTL5000_DAP_BASS_ENHANCE,		0x0040 },
+	{ SGTL5000_DAP_BASS_ENHANCE_CTRL,	0x051f },
+	{ SGTL5000_DAP_SURROUND,		0x0040 },
+	{ SGTL5000_DAP_EQ_BASS_BAND0,		0x002f },
+	{ SGTL5000_DAP_EQ_BASS_BAND1,		0x002f },
+	{ SGTL5000_DAP_EQ_BASS_BAND2,		0x002f },
+	{ SGTL5000_DAP_EQ_BASS_BAND3,		0x002f },
+	{ SGTL5000_DAP_EQ_BASS_BAND4,		0x002f },
+	{ SGTL5000_DAP_MAIN_CHAN,		0x8000 },
+	{ SGTL5000_DAP_AVC_CTRL,		0x0510 },
+	{ SGTL5000_DAP_AVC_THRESHOLD,		0x1473 },
+	{ SGTL5000_DAP_AVC_ATTACK,		0x0028 },
+	{ SGTL5000_DAP_AVC_DECAY,		0x0050 },
 };
 
 /* regulator supplies for sgtl5000, VDDD is an optional external supply */
@@ -112,6 +113,8 @@
 	int fmt;	/* i2s data format */
 	struct regulator_bulk_data supplies[SGTL5000_SUPPLY_NUM];
 	struct ldo_regulator *ldo;
+	struct regmap *regmap;
+	struct clk *mclk;
 };
 
 /*
@@ -128,10 +131,21 @@
 {
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
+#ifdef CONFIG_ARCH_ADVANTECH
+		/* change mic bias resistor to 2Kohm and voltage to 2.00V 
+		    to avoid recording noise */
+		snd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,
+				SGTL5000_BIAS_R_MASK,
+				SGTL5000_BIAS_R_2K << SGTL5000_BIAS_R_SHIFT);
+		snd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,
+				SGTL5000_BIAS_VOLT_MASK,
+				SGTL5000_BIAS_VOLT_2_00V << SGTL5000_BIAS_VOLT_SHIFT);
+#else
 		/* change mic bias resistor to 4Kohm */
 		snd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,
 				SGTL5000_BIAS_R_MASK,
 				SGTL5000_BIAS_R_4k << SGTL5000_BIAS_R_SHIFT);
+#endif
 		break;
 
 	case SND_SOC_DAPM_PRE_PMD:
@@ -151,12 +165,12 @@
 	struct snd_kcontrol *kcontrol, int event)
 {
 	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
+	case SND_SOC_DAPM_POST_PMU:
 		snd_soc_update_bits(w->codec, SGTL5000_CHIP_ANA_POWER,
 			SGTL5000_VAG_POWERUP, SGTL5000_VAG_POWERUP);
 		break;
 
-	case SND_SOC_DAPM_POST_PMD:
+	case SND_SOC_DAPM_PRE_PMD:
 		snd_soc_update_bits(w->codec, SGTL5000_CHIP_ANA_POWER,
 			SGTL5000_VAG_POWERUP, 0);
 		msleep(400);
@@ -217,12 +231,11 @@
 				0, SGTL5000_CHIP_DIG_POWER,
 				1, 0),
 
-	SND_SOC_DAPM_SUPPLY("VAG_POWER", SGTL5000_CHIP_ANA_POWER, 7, 0,
-			    power_vag_event,
-			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
 	SND_SOC_DAPM_ADC("ADC", "Capture", SGTL5000_CHIP_ANA_POWER, 1, 0),
 	SND_SOC_DAPM_DAC("DAC", "Playback", SGTL5000_CHIP_ANA_POWER, 3, 0),
+
+	SND_SOC_DAPM_PRE("VAG_POWER_PRE", power_vag_event),
+	SND_SOC_DAPM_POST("VAG_POWER_POST", power_vag_event),
 };
 
 /* routes for sgtl5000 */
@@ -230,16 +243,13 @@
 	{"Capture Mux", "LINE_IN", "LINE_IN"},	/* line_in --> adc_mux */
 	{"Capture Mux", "MIC_IN", "MIC_IN"},	/* mic_in --> adc_mux */
 
-	{"ADC", NULL, "VAG_POWER"},
 	{"ADC", NULL, "Capture Mux"},		/* adc_mux --> adc */
 	{"AIFOUT", NULL, "ADC"},		/* adc --> i2s_out */
 
-	{"DAC", NULL, "VAG_POWER"},
 	{"DAC", NULL, "AIFIN"},			/* i2s-->dac,skip audio mux */
 	{"Headphone Mux", "DAC", "DAC"},	/* dac --> hp_mux */
 	{"LO", NULL, "DAC"},			/* dac --> line_out */
 
-	{"LINE_IN", NULL, "VAG_POWER"},
 	{"Headphone Mux", "LINE_IN", "LINE_IN"},/* line_in --> hp_mux */
 	{"HP", NULL, "Headphone Mux"},		/* hp_mux --> hp */
 
@@ -897,9 +907,24 @@
 	int ret;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 
+	if (codec->dapm.bias_level == level)
+		return 0;
+
 	switch (level) {
 	case SND_SOC_BIAS_ON:
+
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, SGTL5000_VAG_POWERUP);
+		if (ret)
+			msleep(400);
+		break;
+
 	case SND_SOC_BIAS_PREPARE:
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, 0);
+		if (ret)
+			msleep(600);
+
 		break;
 	case SND_SOC_BIAS_STANDBY:
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
@@ -909,10 +934,33 @@
 			if (ret)
 				return ret;
 			udelay(10);
+
+			regcache_cache_only(sgtl5000->regmap, false);
+
+			ret = regcache_sync(sgtl5000->regmap);
+			if (ret != 0) {
+				dev_err(codec->dev,
+					"Failed to restore cache: %d\n", ret);
+
+				regcache_cache_only(sgtl5000->regmap, true);
+				regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
+						       sgtl5000->supplies);
+
+				return ret;
+			}
 		}
-
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, 0);
+		if (ret)
+			msleep(600);
 		break;
 	case SND_SOC_BIAS_OFF:
+		regcache_cache_only(sgtl5000->regmap, true);
+		ret = snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VAG_POWERUP, 0);
+		if (ret)
+			msleep(600);
+
 		regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
 					sgtl5000->supplies);
 		break;
@@ -958,19 +1006,78 @@
 	.symmetric_rates = 1,
 };
 
-static int sgtl5000_volatile_register(struct snd_soc_codec *codec,
-					unsigned int reg)
+static bool sgtl5000_volatile(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case SGTL5000_CHIP_ID:
 	case SGTL5000_CHIP_ADCDAC_CTRL:
 	case SGTL5000_CHIP_ANA_STATUS:
-		return 1;
+		return true;
 	}
 
-	return 0;
+	return false;
 }
 
+static bool sgtl5000_readable(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SGTL5000_CHIP_ID:
+	case SGTL5000_CHIP_DIG_POWER:
+	case SGTL5000_CHIP_CLK_CTRL:
+	case SGTL5000_CHIP_I2S_CTRL:
+	case SGTL5000_CHIP_SSS_CTRL:
+	case SGTL5000_CHIP_ADCDAC_CTRL:
+	case SGTL5000_CHIP_DAC_VOL:
+	case SGTL5000_CHIP_PAD_STRENGTH:
+	case SGTL5000_CHIP_ANA_ADC_CTRL:
+	case SGTL5000_CHIP_ANA_HP_CTRL:
+	case SGTL5000_CHIP_ANA_CTRL:
+	case SGTL5000_CHIP_LINREG_CTRL:
+	case SGTL5000_CHIP_REF_CTRL:
+	case SGTL5000_CHIP_MIC_CTRL:
+	case SGTL5000_CHIP_LINE_OUT_CTRL:
+	case SGTL5000_CHIP_LINE_OUT_VOL:
+	case SGTL5000_CHIP_ANA_POWER:
+	case SGTL5000_CHIP_PLL_CTRL:
+	case SGTL5000_CHIP_CLK_TOP_CTRL:
+	case SGTL5000_CHIP_ANA_STATUS:
+	case SGTL5000_CHIP_SHORT_CTRL:
+	case SGTL5000_CHIP_ANA_TEST2:
+	case SGTL5000_DAP_CTRL:
+	case SGTL5000_DAP_PEQ:
+	case SGTL5000_DAP_BASS_ENHANCE:
+	case SGTL5000_DAP_BASS_ENHANCE_CTRL:
+	case SGTL5000_DAP_AUDIO_EQ:
+	case SGTL5000_DAP_SURROUND:
+	case SGTL5000_DAP_FLT_COEF_ACCESS:
+	case SGTL5000_DAP_COEF_WR_B0_MSB:
+	case SGTL5000_DAP_COEF_WR_B0_LSB:
+	case SGTL5000_DAP_EQ_BASS_BAND0:
+	case SGTL5000_DAP_EQ_BASS_BAND1:
+	case SGTL5000_DAP_EQ_BASS_BAND2:
+	case SGTL5000_DAP_EQ_BASS_BAND3:
+	case SGTL5000_DAP_EQ_BASS_BAND4:
+	case SGTL5000_DAP_MAIN_CHAN:
+	case SGTL5000_DAP_MIX_CHAN:
+	case SGTL5000_DAP_AVC_CTRL:
+	case SGTL5000_DAP_AVC_THRESHOLD:
+	case SGTL5000_DAP_AVC_ATTACK:
+	case SGTL5000_DAP_AVC_DECAY:
+	case SGTL5000_DAP_COEF_WR_B1_MSB:
+	case SGTL5000_DAP_COEF_WR_B1_LSB:
+	case SGTL5000_DAP_COEF_WR_B2_MSB:
+	case SGTL5000_DAP_COEF_WR_B2_LSB:
+	case SGTL5000_DAP_COEF_WR_A1_MSB:
+	case SGTL5000_DAP_COEF_WR_A1_LSB:
+	case SGTL5000_DAP_COEF_WR_A2_MSB:
+	case SGTL5000_DAP_COEF_WR_A2_LSB:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
 #ifdef CONFIG_SUSPEND
 static int sgtl5000_suspend(struct snd_soc_codec *codec)
 {
@@ -1214,7 +1321,7 @@
 
 static int sgtl5000_enable_regulators(struct snd_soc_codec *codec)
 {
-	u16 reg;
+	int reg;
 	int ret;
 	int rev;
 	int i;
@@ -1242,23 +1349,17 @@
 	/* wait for all power rails bring up */
 	udelay(10);
 
-	/* read chip information */
-	reg = snd_soc_read(codec, SGTL5000_CHIP_ID);
-	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
-	    SGTL5000_PARTID_PART_ID) {
-		dev_err(codec->dev,
-			"Device with ID register %x is not a sgtl5000\n", reg);
-		ret = -ENODEV;
+	/*
+	 * workaround for revision 0x11 and later,
+	 * roll back to use internal LDO
+	 */
+
+	ret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);
+	if (ret)
 		goto err_regulator_disable;
-	}
 
 	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
-	dev_info(codec->dev, "sgtl5000 revision 0x%x\n", rev);
 
-	/*
-	 * workaround for revision 0x11 and later,
-	 * roll back to use internal LDO
-	 */
 	if (external_vddd && rev >= 0x11) {
 		/* disable all regulator first */
 		regulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),
@@ -1300,7 +1401,8 @@
 	struct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);
 
 	/* setup i2c data ops */
-	ret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_I2C);
+	codec->control_data = sgtl5000->regmap;
+	ret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_REGMAP);
 	if (ret < 0) {
 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
 		return ret;
@@ -1343,9 +1445,15 @@
 	snd_soc_write(codec, SGTL5000_CHIP_ANA_CTRL,
 			SGTL5000_HP_ZCD_EN |
 			SGTL5000_ADC_ZCD_EN);
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	snd_soc_write(codec, SGTL5000_CHIP_MIC_CTRL, 0);
+	snd_soc_write(codec, SGTL5000_CHIP_DAC_VOL, 0x6060);
+	snd_soc_write(codec, SGTL5000_CHIP_ANA_ADC_CTRL,
+		(0xf << SGTL5000_ADC_VOL_LEFT_SHIFT) |\
+		(0xf << SGTL5000_ADC_VOL_RIGHT_SHIFT));
+#else
 	snd_soc_write(codec, SGTL5000_CHIP_MIC_CTRL, 2);
-
+#endif
 	/*
 	 * disable DAP
 	 * TODO:
@@ -1391,11 +1499,6 @@
 	.suspend = sgtl5000_suspend,
 	.resume = sgtl5000_resume,
 	.set_bias_level = sgtl5000_set_bias_level,
-	.reg_cache_size = ARRAY_SIZE(sgtl5000_regs),
-	.reg_word_size = sizeof(u16),
-	.reg_cache_step = 2,
-	.reg_cache_default = sgtl5000_regs,
-	.volatile_register = sgtl5000_volatile_register,
 	.controls = sgtl5000_snd_controls,
 	.num_controls = ARRAY_SIZE(sgtl5000_snd_controls),
 	.dapm_widgets = sgtl5000_dapm_widgets,
@@ -1404,28 +1507,118 @@
 	.num_dapm_routes = ARRAY_SIZE(sgtl5000_dapm_routes),
 };
 
+static const struct regmap_config sgtl5000_regmap = {
+	.reg_bits = 16,
+	.val_bits = 16,
+
+	.max_register = SGTL5000_MAX_REG_OFFSET,
+	.volatile_reg = sgtl5000_volatile,
+	.readable_reg = sgtl5000_readable,
+
+	.cache_type = REGCACHE_RBTREE,
+	.reg_defaults = sgtl5000_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(sgtl5000_reg_defaults),
+};
+
+/*
+ * Write all the default values from sgtl5000_reg_defaults[] array into the
+ * sgtl5000 registers, to make sure we always start with the sane registers
+ * values as stated in the datasheet.
+ *
+ * Since sgtl5000 does not have a reset line, nor a reset command in software,
+ * we follow this approach to guarantee we always start from the default values
+ * and avoid problems like, not being able to probe after an audio playback
+ * followed by a system reset or a 'reboot' command in Linux
+ */
+static int sgtl5000_fill_defaults(struct sgtl5000_priv *sgtl5000)
+{
+	int i, ret, val, index;
+
+	for (i = 0; i < ARRAY_SIZE(sgtl5000_reg_defaults); i++) {
+		val = sgtl5000_reg_defaults[i].def;
+		index = sgtl5000_reg_defaults[i].reg;
+		ret = regmap_write(sgtl5000->regmap, index, val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int sgtl5000_i2c_probe(struct i2c_client *client,
 			      const struct i2c_device_id *id)
 {
 	struct sgtl5000_priv *sgtl5000;
-	int ret;
+	int ret, reg, rev;
 
 	sgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),
 								GFP_KERNEL);
 	if (!sgtl5000)
 		return -ENOMEM;
 
+	sgtl5000->regmap = devm_regmap_init_i2c(client, &sgtl5000_regmap);
+	if (IS_ERR(sgtl5000->regmap)) {
+		ret = PTR_ERR(sgtl5000->regmap);
+		dev_err(&client->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	sgtl5000->mclk = devm_clk_get(&client->dev, NULL);
+	if (IS_ERR(sgtl5000->mclk)) {
+		ret = PTR_ERR(sgtl5000->mclk);
+		dev_err(&client->dev, "Failed to get mclock: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sgtl5000->mclk);
+	if (ret)
+		return ret;
+
+	/* read chip information */
+	ret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);
+	if (ret)
+		goto disable_clk;
+
+	if (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
+	    SGTL5000_PARTID_PART_ID) {
+		dev_err(&client->dev,
+			"Device with ID register %x is not a sgtl5000\n", reg);
+		ret = -ENODEV;
+		goto disable_clk;
+	}
+
+	rev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
+	dev_info(&client->dev, "sgtl5000 revision 0x%x\n", rev);
+
 	i2c_set_clientdata(client, sgtl5000);
 
+	/* Ensure sgtl5000 will start with sane register values */
+	ret = sgtl5000_fill_defaults(sgtl5000);
+	if (ret)
+		goto disable_clk;
+
 	ret = snd_soc_register_codec(&client->dev,
 			&sgtl5000_driver, &sgtl5000_dai, 1);
+	if (ret)
+		goto disable_clk;
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(sgtl5000->mclk);
 	return ret;
 }
 
 static int sgtl5000_i2c_remove(struct i2c_client *client)
 {
+	struct sgtl5000_priv *sgtl5000;
+	sgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),
+								GFP_KERNEL);
+	if (!sgtl5000)
+		return -ENOMEM;
+
 	snd_soc_unregister_codec(&client->dev);
-
+	clk_disable_unprepare(sgtl5000->mclk);
 	return 0;
 }
 
Index: sound/soc/codecs/sgtl5000.h
===================================================================
diff --git a/sound/soc/codecs/sgtl5000.h b/sound/soc/codecs/sgtl5000.h
--- a/sound/soc/codecs/sgtl5000.h	(revision 513)
+++ b/sound/soc/codecs/sgtl5000.h	(revision 1734)
@@ -290,6 +290,7 @@
 #define SGTL5000_BIAS_VOLT_MASK			0x0070
 #define SGTL5000_BIAS_VOLT_SHIFT		4
 #define SGTL5000_BIAS_VOLT_WIDTH		3
+#define SGTL5000_BIAS_VOLT_2_00V		0x3
 #define SGTL5000_MIC_GAIN_MASK			0x0003
 #define SGTL5000_MIC_GAIN_SHIFT			0
 #define SGTL5000_MIC_GAIN_WIDTH			2
Index: fs/proc/boardinfo.c
===================================================================
diff --git a/fs/proc/boardinfo.c b/fs/proc/boardinfo.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/fs/proc/boardinfo.c	(revision 1734)
@@ -0,0 +1,30 @@
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+extern char board_type[12];
+
+static int boardinfo_proc_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%s", board_type);
+
+	return 0;
+}
+
+static int boardinfo_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, boardinfo_proc_show, NULL);
+}
+
+static const struct file_operations boardinfo_proc_fops = {
+	.open		= boardinfo_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_boardinfo_init(void)
+{
+	proc_create("board", 0, NULL, &boardinfo_proc_fops);
+	return 0;
+}
+module_init(proc_boardinfo_init);
Index: fs/proc/uboot.c
===================================================================
diff --git a/fs/proc/uboot.c b/fs/proc/uboot.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/fs/proc/uboot.c	(revision 1734)
@@ -0,0 +1,40 @@
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+char board_uboot_version[100];
+
+static int uboot_version_proc_show(struct seq_file *m, void *v)
+{
+	char uboot_temp_str[20] = "uboot_version=";
+	char *uboot_ver;
+	int uboot_len=0;
+
+    uboot_ver = strstr(saved_command_line, uboot_temp_str);
+	uboot_len = strlen(uboot_ver);
+	uboot_ver = uboot_ver + strlen(uboot_temp_str);
+	memset(board_uboot_version, 0x0, sizeof(board_uboot_version));
+	strcpy(board_uboot_version, uboot_ver);
+
+	seq_printf(m, "%s\n", board_uboot_version);
+
+	return 0;
+}
+
+static int uboot_version_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, uboot_version_proc_show, NULL);
+}
+
+static const struct file_operations uboot_version_proc_fops = {
+	.open		= uboot_version_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_uboot_version_init(void)
+{
+	proc_create("uboot_version", 0, NULL, &uboot_version_proc_fops);
+	return 0;
+}
+module_init(proc_uboot_version_init);
Index: fs/proc/Makefile
===================================================================
diff --git a/fs/proc/Makefile b/fs/proc/Makefile
--- a/fs/proc/Makefile	(revision 513)
+++ b/fs/proc/Makefile	(revision 1734)
@@ -23,6 +23,7 @@
 proc-y	+= softirqs.o
 proc-y	+= namespaces.o
 proc-y	+= self.o
+proc-$(CONFIG_ARCH_ADVANTECH)	+= boardinfo.o advboot.o uboot.o
 proc-$(CONFIG_PROC_SYSCTL)	+= proc_sysctl.o
 proc-$(CONFIG_NET)		+= proc_net.o
 proc-$(CONFIG_PROC_KCORE)	+= kcore.o
Index: fs/proc/advboot.c
===================================================================
diff --git a/fs/proc/advboot.c b/fs/proc/advboot.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/fs/proc/advboot.c	(revision 1734)
@@ -0,0 +1,48 @@
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+char board_advboot_version[100];
+
+static int advboot_version_proc_show(struct seq_file *m, void *v)
+{
+	char uboot_temp_str[20] = "uboot_version=";
+	char advboot_temp_str[20] = "advboot_version=";
+	char *uboot_ver, *advboot_ver;
+	int uboot_len=0, total_len=0, advboot_len=0; 
+
+	/* uboot */
+    uboot_ver = strstr(saved_command_line, uboot_temp_str);
+	uboot_len = strlen(uboot_ver);
+	uboot_ver = uboot_ver + strlen(uboot_temp_str);
+
+	/* advboot */
+    advboot_ver = strstr(saved_command_line, advboot_temp_str);
+	advboot_ver = advboot_ver + strlen(advboot_temp_str);
+	total_len = strlen(advboot_ver);
+	memset(board_advboot_version, 0x0, sizeof(board_advboot_version));
+	advboot_len = total_len - uboot_len - 1;
+	strncpy(board_advboot_version, advboot_ver, advboot_len);
+	
+	seq_printf(m, "%s\n", board_advboot_version);
+
+	return 0;
+}
+
+static int advboot_version_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, advboot_version_proc_show, NULL);
+}
+
+static const struct file_operations advboot_version_proc_fops = {
+	.open		= advboot_version_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_advboot_version_init(void)
+{
+	proc_create("advboot_version", 0, NULL, &advboot_version_proc_fops);
+	return 0;
+}
+module_init(proc_advboot_version_init);
Index: Documentation/devicetree/bindings/regulator/pfuze100.txt
===================================================================
diff --git a/Documentation/devicetree/bindings/regulator/pfuze100.txt b/Documentation/devicetree/bindings/regulator/pfuze100.txt
--- a/Documentation/devicetree/bindings/regulator/pfuze100.txt	(revision 513)
+++ b/Documentation/devicetree/bindings/regulator/pfuze100.txt	(revision 1734)
@@ -1,7 +1,7 @@
 PFUZE100 family of regulators
 
 Required properties:
-- compatible: "fsl,pfuze100"
+- compatible: "fsl,pfuze100" or "fsl,pfuze200"
 - reg: I2C slave address
 
 Required child node:
@@ -10,11 +10,14 @@
   Documentation/devicetree/bindings/regulator/regulator.txt.
 
   The valid names for regulators are:
+  --PFUZE100
   sw1ab,sw1c,sw2,sw3a,sw3b,sw4,swbst,vsnvs,vrefddr,vgen1~vgen6
+  --PFUZE200
+  sw1ab,sw2,sw3a,sw3b,swbst,vsnvs,vrefddr,vgen1~vgen6
 
 Each regulator is defined using the standard binding for regulators.
 
-Example:
+Example 1: PFUZE100
 
 	pmic: pfuze100@08 {
 		compatible = "fsl,pfuze100";
@@ -110,6 +113,95 @@
 				regulator-min-microvolt = <1800000>;
 				regulator-max-microvolt = <3300000>;
 				regulator-always-on;
+			};
+		};
+	};
+
+
+Example 2: PFUZE200
+
+	pmic: pfuze200@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
 			};
 		};
 	};
Index: arch/arm/boot/dts/imx6dl-ubc220.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6dl-ubc220.dts b/arch/arm/boot/dts/imx6dl-ubc220.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6dl-ubc220.dts	(revision 1734)
@@ -0,0 +1,314 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-advantech.dtsi"
+
+/ {
+	model = "Freescale i.MX6 DualLite UBC220";
+	compatible = "fsl,imx6dl-sabresd", "fsl,imx6dl";
+
+	board {
+		compatible = "proc-board";
+		board-type = "UBC-220";
+		board-cpu = "DualLiteSolo";
+	};
+
+	regulators {
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 15  GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds_debug_1>;
+		debug-led {
+			label = "Heartbeat";
+			gpios = <&gpio7 12 0>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	gpio_direction {
+		pinctrl-names = "default";
+		compatible = "gpio-set-direction";
+		usb-host-pwr-en = <&gpio1 0 1>;
+		usb-host-oc = <&gpio1 3 0>;
+		wifi-det = <&gpio5 21 0>;
+		det-3g = <&gpio5 22 0>;
+		off-3g = <&gpio5 23 0>;
+		pcie-h-wlan-led = <&gpio6 15 0>;
+		pcie-h-wwan-led = <&gpio6 8 0>;
+		pcie-f-wlan-led = <&gpio2 0 0>;
+		pcie-f-wwan-led = <&gpio2 4 0>;
+	};
+};
+
+&audio_sgtl5000 {
+	status = "disabled";
+};
+
+&audmux {
+	status = "disabled";
+};
+
+&bkl {
+	lvds-bkl-enable = <&gpio4 6 1>;
+	lvds-vcc-enable = <&gpio4 7 1>;
+	pwms = <&pwm4 0 5000000>;
+	status = "okay";
+};
+
+&ecspi1 {
+	m25p80@0 {
+		compatible = "st,m25p32";
+	};
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&i2c1 {
+
+	s35390a@30 {
+		compatible = "fsl,s35390a";
+		reg = <0x30>;
+	};
+
+	wdt@29 {
+		compatible = "fsl,adv-wdt-i2c";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_wdt_en_1 &pinctrl_wdt_ping_1>;
+		status = "okay";
+		wdt-en = <&gpio2 5 0>;
+		wdt-ping = <&gpio1 9 0>;
+		reg = <0x29>;
+	};
+};
+
+&i2c2 {
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1 &pinctrl_hog_2>;
+
+	hog {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02		0x80000000	/* SD card - SD2_WP */
+				MX6QDL_PAD_GPIO_4__GPIO1_IO04		0x80000000	/* SD card - SD2_CD */
+				MX6QDL_PAD_EIM_D30__GPIO3_IO30		0x0001B0B0	/* BORAD_ID0 */
+				MX6QDL_PAD_EIM_D31__GPIO3_IO31		0x000130B0	/* BORAD_ID1 */
+			>;
+		};
+
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_VSYNC__GPIO5_IO21	0x0001B0B0	/* WIFI_DET# */
+				MX6QDL_PAD_CSI0_DAT4__GPIO5_IO22	0x0001B0B0	/* 3G_DET# */
+				MX6QDL_PAD_CSI0_DAT5__GPIO5_IO23	0x0001B0B0	/* 3G_OFF# */
+				MX6QDL_PAD_NANDF_CS2__GPIO6_IO15	0x0001B0B0	/* PCIE_H_WLAN_LED# */
+				MX6QDL_PAD_NANDF_ALE__GPIO6_IO08	0x0001B0B0	/* PCIE_H_WWAN_LED# */
+				MX6QDL_PAD_NANDF_D0__GPIO2_IO00		0x0001B0B0	/* PCIE_F_WLAN_LED# */
+				MX6QDL_PAD_NANDF_D4__GPIO2_IO04		0x00017059	/* PCIE_F_WWAN_LED# */
+			>;
+		};
+	};
+
+	leds {
+		pinctrl_leds_debug_1: leds_debug1grp-1{
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_17__GPIO7_IO12		0x80000000	/* gpio - led */
+			>;
+		};
+	};
+
+	pcie {
+		pinctrl_pcie_1: pcie1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_PIXCLK__GPIO5_IO18	0x80000000	/* PCIE disable pin - WIFI_OFF# */
+			>;
+		};
+	};
+
+	pwm4 {
+		pinctrl_pwm4_1: pwm4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__PWM4_OUT		0x1b0b1
+			>;
+		};
+	};
+
+	spi1 {
+		pinctrl_ecspi1_cs_0: ecspi1_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__GPIO2_IO30		0x80000000	/* ECSPI1_CS0 */
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_3: uart2grp-3 { /* DCE mode */
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA		0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA		0x1b0b1
+				MX6QDL_PAD_EIM_D28__UART2_CTS_B			0x1b0b1
+				MX6QDL_PAD_EIM_D29__UART2_RTS_B			0x1b0b1
+			>;
+		};
+	};
+
+	usbh1 {
+		pinctrl_usbh1_1: usbh1_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00		0x00017099	/* USB_HOST_PWR_EN */
+				MX6QDL_PAD_GPIO_3__GPIO1_IO03		0x0001B8B1	/* USB_HOST_OC# */
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_pwr_1: usbotg_pwr_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW4__GPIO4_IO15		0x80000000	/* USB_OTG_PWR */
+				MX6QDL_PAD_KEY_COL4__GPIO4_IO14		0x0001B0B0	/* USB_OTG_OC */
+			>;
+		};
+	};
+
+	wdt{
+		pinctrl_wdt_en_1: wdt_engrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_D5__GPIO2_IO05		0x80000000
+			>;
+		};
+
+		pinctrl_wdt_ping_1: wdt_pinggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_9__GPIO1_IO09		0x80000000
+			>;
+		};
+	};
+};
+
+&ldb {
+	ipu_id = <0>;
+	disp_id = <0>;
+	ext_ref = <1>;
+	mode = "sin0";
+	sec_ipu_id = <0>;
+	sec_disp_id = <1>;
+	status = "okay";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	disp_dev = "ldb";
+	mode_str ="800x480M@60";
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie_1>;
+	disable-gpio = <&gpio5 18 0>;
+	status = "okay";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm4_1>;
+	status = "okay";
+
+};
+
+&ssi2 {
+	status = "disabled";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_3>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&usbh1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbh1_1>;
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_1 &pinctrl_usbotg_pwr_1>;
+	vbus-supply = <&reg_usb_otg_vbus>;
+	imx6-usb-charger-detection;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_2>;
+	cd-gpios = <&gpio1 4 0>;
+	wp-gpios = <&gpio1 2 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&wdog1 {
+	status = "disabled";
+};
Index: arch/arm/boot/dts/imx6sl-evk.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6sl-evk.dts b/arch/arm/boot/dts/imx6sl-evk.dts
--- a/arch/arm/boot/dts/imx6sl-evk.dts	(revision 513)
+++ b/arch/arm/boot/dts/imx6sl-evk.dts	(revision 1734)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -9,195 +9,14 @@
 /dts-v1/;
 
 #include "imx6sl.dtsi"
+#include "imx6sl-evk-common.dtsi"
 
 / {
-	model = "Freescale i.MX6 SoloLite EVK Board";
+	model = "Freescale i.MX6 SoloLite EVK Board(PFUZE100)";
 	compatible = "fsl,imx6sl-evk", "fsl,imx6sl";
-
-	memory {
-		reg = <0x80000000 0x40000000>;
-	};
-
-	battery: max8903@0 {
-		compatible = "fsl,max8903-charger";
-		pinctrl-names = "default";
-		dok_input = <&gpio4 13 1>;
-		uok_input = <&gpio4 13 1>;
-		chg_input = <&gpio4 15 1>;
-		flt_input = <&gpio4 14 1>;
-		fsl,dcm_always_high;
-		fsl,dc_valid;
-		fsl,adc_disable;
-		status = "okay";
-	};
-	regulators {
-		compatible = "simple-bus";
-
-		reg_lcd_3v3: lcd-3v3 {
-			compatible = "regulator-fixed";
-			regulator-name = "lcd-3v3";
-			gpio = <&gpio4 3 0>;
-			enable-active-high;
-		};
-
-		reg_aud3v: wm8962_supply_3v15 {
-			compatible = "regulator-fixed";
-			regulator-name = "wm8962-supply-3v15";
-			regulator-min-microvolt = <3150000>;
-			regulator-max-microvolt = <3150000>;
-			regulator-boot-on;
-		};
-
-		reg_aud4v: wm8962_supply_4v2 {
-			compatible = "regulator-fixed";
-			regulator-name = "wm8962-supply-4v2";
-			regulator-min-microvolt = <4325000>;
-			regulator-max-microvolt = <4325000>;
-			regulator-boot-on;
-		};
-
-		reg_usb_otg1_vbus: usb_otg1_vbus {
-			compatible = "regulator-fixed";
-			regulator-name = "usb_otg1_vbus";
-			regulator-min-microvolt = <5000000>;
-			regulator-max-microvolt = <5000000>;
-			gpio = <&gpio4 0 0>;
-			enable-active-high;
-		};
-
-		reg_usb_otg2_vbus: usb_otg2_vbus {
-			compatible = "regulator-fixed";
-			regulator-name = "usb_otg2_vbus";
-			regulator-min-microvolt = <5000000>;
-			regulator-max-microvolt = <5000000>;
-			gpio = <&gpio4 2 0>;
-			enable-active-high;
-		};
-	};
-
-	backlight {
-		compatible = "pwm-backlight";
-		pwms = <&pwm1 0 5000000>;
-		brightness-levels = <0 4 8 16 32 64 128 255>;
-		default-brightness-level = <6>;
-	};
-
-	csi_v4l2_cap {
-		compatible = "fsl,imx6sl-csi-v4l2";
-		status = "disabled";
-	};
-
-	pxp_v4l2_out {
-		compatible = "fsl,imx6sl-pxp-v4l2";
-		status = "okay";
-	};
-
-	sound {
-		compatible = "fsl,imx6q-sabresd-wm8962",
-			   "fsl,imx-audio-wm8962";
-		model = "wm8962-audio";
-		ssi-controller = <&ssi2>;
-		audio-codec = <&codec>;
-		audio-routing =
-			"Headphone Jack", "HPOUTL",
-			"Headphone Jack", "HPOUTR",
-			"Ext Spk", "SPKOUTL",
-			"Ext Spk", "SPKOUTR",
-			"AMIC", "MICBIAS",
-			"IN3R", "AMIC";
-		amic-mono;
-		mux-int-port = <2>;
-		mux-ext-port = <3>;
-		hp-det-gpios = <&gpio4 19 1>;
-	};
-
-	sound-spdif {
-		compatible = "fsl,imx-audio-spdif",
-			   "fsl,imx6sl-evk-spdif";
-		model = "imx-spdif";
-		spdif-controller = <&spdif>;
-		spdif-out;
-	};
-
-	sii902x_reset: sii902x-reset {
-		compatible = "gpio-reset";
-		reset-gpios = <&gpio2 19 1>;
-		reset-delay-us = <100000>;
-		#reset-cells = <0>;
-	};
 };
 
-&audmux {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_audmux_1>;
-	status = "okay";
-};
-
-&csi {
-	status = "disabled";
-};
-
-&ecspi1 {
-	fsl,spi-num-chipselects = <1>;
-	cs-gpios = <&gpio4 11 0>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_ecspi1_1>;
-	status = "okay";
-
-	flash: m25p80@0 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "st,m25p32";
-		spi-max-frequency = <20000000>;
-		reg = <0>;
-	};
-};
-
-&epdc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_epdc_0>;
-	V3P3-supply = <&V3P3_reg>;
-	VCOM-supply = <&VCOM_reg>;
-	DISPLAY-supply = <&DISPLAY_reg>;
-	status = "okay";
-};
-
-&cpu0 {
-	arm-supply = <&sw1a_reg>;
-	soc-supply = <&sw1c_reg>;
-	pu-supply = <&pu_dummy>; /* use pu_dummy if VDDSOC share with VDDPU */
-};
-
-&fec {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_fec_1>;
-	pinctrl-1 = <&pinctrl_fec_1_sleep>;
-	phy-mode = "rmii";
-	phy-reset-gpios = <&gpio4 21 0>; /* GPIO4_21 */
-	phy-reset-duration = <1>;
-	status = "okay";
-};
-
-&gpc {
-	fsl,cpu_pupscr_sw2iso = <0xf>;
-	fsl,cpu_pupscr_sw = <0xf>;
-	fsl,cpu_pdnscr_iso2sw = <0x1>;
-	fsl,cpu_pdnscr_iso = <0x1>;
-	fsl,ldo-bypass = <1>; /* use ldo-bypass, u-boot will check it and configure */
-	fsl,wdog-reset = <1>; /* watchdog select of reset source */
-	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
-};
-
-&gpu {
-	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
-};
-
 &i2c1 {
-	clock-frequency = <100000>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c1_1>;
-	status = "okay";
-
 	pmic: pfuze100@08 {
 		compatible = "fsl,pfuze100";
 		reg = <0x08>;
@@ -297,314 +116,4 @@
 			};
 		};
 	};
-
-	elan@10 {
-		compatible = "elan,elan-touch";
-		reg = <0x10>;
-		interrupt-parent = <&gpio2>;
-		interrupts = <10 2>;
-		gpio_elan_cs = <&gpio2 9 0>;
-		gpio_elan_rst = <&gpio4 4 0>;
-		gpio_intr = <&gpio2 10 0>;
-		status = "okay";
-	};
-
-	max17135@48 {
-		compatible = "maxim,max17135";
-		reg = <0x48>;
-		vneg_pwrup = <1>;
-		gvee_pwrup = <2>;
-		vpos_pwrup = <10>;
-		gvdd_pwrup = <12>;
-		gvdd_pwrdn = <1>;
-		vpos_pwrdn = <2>;
-		gvee_pwrdn = <8>;
-		vneg_pwrdn = <10>;
-		gpio_pmic_pwrgood = <&gpio2 13 0>;
-		gpio_pmic_vcom_ctrl = <&gpio2 3 0>;
-		gpio_pmic_wakeup = <&gpio2 14 0>;
-		gpio_pmic_v3p3 = <&gpio2 7 0>;
-		gpio_pmic_intr = <&gpio2 12 0>;
-
-		regulators {
-			DISPLAY_reg: DISPLAY {
-				regulator-name = "DISPLAY";
-			};
-
-			GVDD_reg: GVDD {
-				/* 20v */
-				regulator-name = "GVDD";
-			};
-
-			GVEE_reg: GVEE {
-				/* -22v */
-				regulator-name = "GVEE";
-			};
-
-			HVINN_reg: HVINN {
-				/* -22v */
-				regulator-name = "HVINN";
-			};
-
-			HVINP_reg: HVINP {
-				/* 20v */
-				regulator-name = "HVINP";
-			};
-
-			VCOM_reg: VCOM {
-				regulator-name = "VCOM";
-				/* 2's-compliment, -4325000 */
-				regulator-min-microvolt = <0xffbe0178>;
-				/* 2's-compliment, -500000 */
-				regulator-max-microvolt = <0xfff85ee0>;
-			};
-
-			VNEG_reg: VNEG {
-				/* -15v */
-				regulator-name = "VNEG";
-			};
-
-			VPOS_reg: VPOS {
-				/* 15v */
-				regulator-name = "VPOS";
-			};
-
-			V3P3_reg: V3P3 {
-				regulator-name = "V3P3";
-			};
-		};
-	};
-
-	mma8450@1c {
-		compatible = "fsl,mma8450";
-		reg = <0x1c>;
-	};
 };
-
-&i2c2 {
-	clock-frequency = <100000>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c2_1>;
-	status = "okay";
-
-	codec: wm8962@1a {
-		compatible = "wlf,wm8962";
-		reg = <0x1a>;
-		clocks = <&clks IMX6SL_CLK_EXTERN_AUDIO>;
-		DCVDD-supply = <&vgen3_reg>;
-		DBVDD-supply = <&reg_aud3v>;
-		AVDD-supply = <&vgen3_reg>;
-		CPVDD-supply = <&vgen3_reg>;
-		MICVDD-supply = <&reg_aud3v>;
-		PLLVDD-supply = <&vgen3_reg>;
-		SPKVDD1-supply = <&reg_aud4v>;
-		SPKVDD2-supply = <&reg_aud4v>;
-		amic-mono;
-	};
-
-	sii902x@39 {
-		compatible = "SiI,sii902x";
-		interrupt-parent = <&gpio2>;
-		interrupts = <10 2>;
-		mode_str ="1280x720M@60";
-		bits-per-pixel = <32>;
-		resets = <&sii902x_reset>;
-		reg = <0x39>;
-	};
-};
-
-&i2c3 {
-	clock-frequency = <100000>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c3_1>;
-	status = "disabled";
-
-	ov564x: ov564x@3c {
-		compatible = "ovti,ov564x";
-		reg = <0x3c>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_csi_0>;
-		clocks = <&clks IMX6SL_CLK_CSI>;
-		clock-names = "csi_mclk";
-		AVDD-supply = <&vgen6_reg>;  /* 2.8v */
-		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
-		pwn-gpios = <&gpio1 25 1>;
-		rst-gpios = <&gpio1 26 0>;
-		csi_id = <0>;
-		mclk = <24000000>;
-		mclk_source = <0>;
-	};
-};
-
-&iomuxc {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_hog>;
-	pinctrl-1 = <&pinctrl_hog_sleep>;
-
-	hog {
-		pinctrl_hog: hoggrp {
-			fsl,pins = <
-				MX6SL_PAD_KEY_ROW7__GPIO4_IO07    0x17059
-				MX6SL_PAD_KEY_COL7__GPIO4_IO06    0x17059
-				MX6SL_PAD_SD2_DAT7__GPIO5_IO00    0x17059
-				MX6SL_PAD_SD2_DAT6__GPIO4_IO29    0x17059
-				MX6SL_PAD_REF_CLK_32K__GPIO3_IO22 0x17059
-				MX6SL_PAD_FEC_TX_CLK__GPIO4_IO21  0x80000000
-				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x110b0
-				MX6SL_PAD_EPDC_VCOM0__GPIO2_IO03  0x80000000
-				MX6SL_PAD_EPDC_PWRSTAT__GPIO2_IO13 0x80000000
-				MX6SL_PAD_EPDC_PWRCTRL0__GPIO2_IO07 0x80000000
-				MX6SL_PAD_EPDC_PWRWAKEUP__GPIO2_IO14 0x80000000
-				MX6SL_PAD_EPDC_PWRINT__GPIO2_IO12 0x80000000
-				MX6SL_PAD_EPDC_PWRCTRL3__GPIO2_IO10 0x170b0
-				MX6SL_PAD_EPDC_PWRCTRL2__GPIO2_IO09 0x80000000
-				MX6SL_PAD_KEY_COL6__GPIO4_IO04    0x110b0
-				MX6SL_PAD_ECSPI2_MISO__GPIO4_IO14 0x17000
-				MX6SL_PAD_ECSPI2_MOSI__GPIO4_IO13 0x17000
-				MX6SL_PAD_ECSPI2_SS0__GPIO4_IO15  0x17000
-				MX6SL_PAD_FEC_RX_ER__GPIO4_IO19   0x1b0b0
-				MX6SL_PAD_LCD_RESET__GPIO2_IO19 0x1b0b0
-				MX6SL_PAD_KEY_COL4__GPIO4_IO00	0x80000000
-				MX6SL_PAD_KEY_COL5__GPIO4_IO02	0x80000000
-			>;
-		};
-
-		pinctrl_hog_sleep: hoggrp_sleep {
-			fsl,pins = <
-				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x3080
-				MX6SL_PAD_KEY_COL6__GPIO4_IO04 	  0x3080
-				MX6SL_PAD_LCD_RESET__GPIO2_IO19   0x3080
-			>;
-		};
-	};
-};
-
-&kpp {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_kpp_1>;
-	pinctrl-1 = <&pinctrl_kpp_1_sleep>;
-	linux,keymap = <
-			0x00000067      /* KEY_UP */
-			0x0001006c      /* KEY_DOWN */
-			0x0002001c      /* KEY_ENTER */
-			0x01000066      /* KEY_HOME */
-			0x0101006a      /* KEY_RIGHT */
-			0x01020069      /* KEY_LEFT */
-			0x02000072      /* KEY_VOLUMEDOWN */
-			0x02010073      /* KEY_VOLUMEUP */
-		>;
-        status = "okay";
-};
-
-&lcdif {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_lcdif_dat_0
-		     &pinctrl_lcdif_ctrl_0>;
-	lcd-supply = <&reg_lcd_3v3>;
-	display = <&display>;
-	status = "okay";
-
-	display: display {
-		bits-per-pixel = <16>;
-		bus-width = <24>;
-
-		display-timings {
-			native-mode = <&timing0>;
-			timing0: timing0 {
-				clock-frequency = <33500000>;
-				hactive = <800>;
-				vactive = <480>;
-				hback-porch = <89>;
-				hfront-porch = <164>;
-				vback-porch = <23>;
-				vfront-porch = <10>;
-				hsync-len = <10>;
-				vsync-len = <10>;
-				hsync-active = <0>;
-				vsync-active = <0>;
-				de-active = <1>;
-				pixelclk-active = <0>;
-			};
-		};
-	};
-};
-
-&pwm1 {
-	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&pinctrl_pwm1_0>;
-	pinctrl-1 = <&pinctrl_pwm1_0_sleep>;
-	status = "okay";
-};
-
-&pxp {
-	status = "okay";
-};
-
-&spdif {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_spdif_1>;
-	status = "okay";
-};
-
-&ssi2 {
-	fsl,mode = "i2s-slave";
-	status = "okay";
-};
-
-&uart1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_uart1_1>;
-	status = "okay";
-};
-
-&usbotg1 {
-	vbus-supply = <&reg_usb_otg1_vbus>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usbotg1_1>;
-	disable-over-current;
-	imx6-usb-charger-detection;
-	status = "okay";
-};
-
-&usbotg2 {
-	vbus-supply = <&reg_usb_otg2_vbus>;
-	dr_mode = "host";
-	disable-over-current;
-	status = "okay";
-};
-
-&usdhc1 {
-	pinctrl-names = "default", "state_100mhz", "state_200mhz";
-	pinctrl-0 = <&pinctrl_usdhc1_1>;
-	pinctrl-1 = <&pinctrl_usdhc1_1_100mhz>;
-	pinctrl-2 = <&pinctrl_usdhc1_1_200mhz>;
-	bus-width = <8>;
-	cd-gpios = <&gpio4 7 0>;
-	wp-gpios = <&gpio4 6 0>;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
-};
-
-&usdhc2 {
-	pinctrl-names = "default", "state_100mhz", "state_200mhz";
-	pinctrl-0 = <&pinctrl_usdhc2_1>;
-	pinctrl-1 = <&pinctrl_usdhc2_1_100mhz>;
-	pinctrl-2 = <&pinctrl_usdhc2_1_200mhz>;
-	cd-gpios = <&gpio5 0 0>;
-	wp-gpios = <&gpio4 29 0>;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
-};
-
-&usdhc3 {
-	pinctrl-names = "default", "state_100mhz", "state_200mhz";
-	pinctrl-0 = <&pinctrl_usdhc3_1>;
-	pinctrl-1 = <&pinctrl_usdhc3_1_100mhz>;
-	pinctrl-2 = <&pinctrl_usdhc3_1_200mhz>;
-	cd-gpios = <&gpio3 22 0>;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
-};
Index: arch/arm/boot/dts/Makefile
===================================================================
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
--- a/arch/arm/boot/dts/Makefile	(revision 513)
+++ b/arch/arm/boot/dts/Makefile	(revision 1734)
@@ -120,6 +120,7 @@
 	imx6dl-sabresd.dtb \
 	imx6dl-sabresd-hdcp.dtb \
 	imx6dl-sabresd-ldo.dtb \
+	imx6dl-sabresd-pf200.dtb \
 	imx6dl-wandboard.dtb \
 	imx6q-arm2.dtb \
 	imx6q-sabreauto.dtb \
@@ -134,7 +135,17 @@
 	imx6sl-evk.dtb \
 	imx6sl-evk-csi.dtb \
 	imx6sl-evk-ldo.dtb \
+	imx6sl-evk-pf200.dtb \
 	vf610-twr.dtb
+dtb-$(CONFIG_ARCH_ADVANTECH) += \
+	imx6q-ubcds31.dtb \
+	imx6q-rsb4410.dtb \
+	imx6q-rom7420.dtb \
+	imx6q-rom5420.dtb \
+	imx6q-rom3420.dtb \
+	imx6q-ubc220.dtb \
+	imx6dl-ubc220.dtb \
+	imx6q-wise3310.dtb
 dtb-$(CONFIG_ARCH_MXS) += imx23-evk.dtb \
 	imx23-olinuxino.dtb \
 	imx23-stmp378x_devb.dtb \
Index: arch/arm/boot/dts/imx6q-rom7420.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6q-rom7420.dts b/arch/arm/boot/dts/imx6q-rom7420.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6q-rom7420.dts	(revision 1734)
@@ -0,0 +1,388 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-advantech.dtsi"
+
+/ {
+	model = "Freescale i.MX6 Quad ROM7420";
+	compatible = "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	board {
+		compatible = "proc-board";
+		board-type = "ROM-7420";
+		board-cpu = "DualQuad";
+	};
+
+	regulators {
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 22 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+	};
+
+	gpio-keys {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_sleep_1>;
+		compatible = "gpio-keys";
+		sleep {
+			label = "Sleep Button";
+			gpios = <&gpio4 5 1>;
+			linux,input-type = <22>;
+			linux,code = <205>; /* KEY_SUSPEND */
+			debounce_interval = <1>;
+			gpio-key,wakeup;
+		};
+	};
+};
+
+&audio_sgtl5000 {
+	audio-codec = <&codec>;
+};
+
+&bkl {
+	lvds-bkl-enable = <&gpio6 9 1>;
+	lvds-vcc-enable = <&gpio6 7 1>;
+	pwms = <&pwm1 0 5000000>;
+	status = "okay";
+};
+
+&ecspi1 {
+	cs-gpios = <&gpio3 19 0>;
+};
+
+&ecspi5 {
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio1 17 0>, <&gpio1 19 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi5_1 &pinctrl_ecspi5_cs_0 &pinctrl_ecspi5_cs_1>;
+	status = "okay";
+
+	chip1: m25p80@0 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+	chip2: m25p80@1 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <1>;
+	};
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_1>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_1>;
+	status = "okay";
+};
+
+&i2c1 {
+
+	codec: sgtl5000@0a {
+		compatible = "fsl,sgtl5000";
+		reg = <0x0a>;
+		clocks = <&clks 201>;
+		VDDA-supply = <&reg_2p5v>;
+		VDDIO-supply = <&reg_3p3v>;
+		mclk = <16000000>;
+		mclk_source = <0>;
+	};
+
+	s35390a@30 {
+		compatible = "fsl,s35390a";
+		reg = <0x30>;
+	};
+};
+
+&i2c2 {
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+&i2c3 {
+
+	ch7055@76 {
+		compatible = "fsl,ch7055";
+		reg = <0x76>;
+	};
+
+	mxc_vga_i2c@50 {
+		compatible = "fsl,mxc_vga_i2c";
+		reg = <0x50>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1 &pinctrl_hog_2>;
+
+	flexcan1 {
+		pinctrl_flexcan1_1: flexcan1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__FLEXCAN1_TX		0x80000000
+				MX6QDL_PAD_GPIO_8__FLEXCAN1_RX		0x80000000
+			>;
+		};
+	};
+
+	flexcan2 {
+		pinctrl_flexcan2_1: flexcan2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT0__FLEXCAN2_TX	0x80000000
+				MX6QDL_PAD_SD3_DAT1__FLEXCAN2_RX	0x80000000
+			>;
+		};
+	};
+
+	gpio-keys {
+			pinctrl_gpio_sleep_1: gpio_sleep1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_19__GPIO4_IO05		0x80000000	/* SLEEP Button */
+			>;
+		};
+	};
+
+	hog {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11	0x80000000	/* GPIO1 */
+				MX6QDL_PAD_NANDF_CS1__GPIO6_IO14	0x80000000	/* GPIO2 */
+				MX6QDL_PAD_NANDF_CS2__GPIO6_IO15	0x80000000	/* GPIO3 */
+				MX6QDL_PAD_NANDF_CS3__GPIO6_IO16	0x80000000	/* GPIO4 */
+				MX6QDL_PAD_EIM_CS0__GPIO2_IO23		0x80000000	/* GPIO5 */
+				MX6QDL_PAD_EIM_CS1__GPIO2_IO24		0x80000000	/* GPIO6 */
+				MX6QDL_PAD_EIM_OE__GPIO2_IO25		0x80000000	/* GPIO7 */
+				MX6QDL_PAD_EIM_A25__GPIO5_IO02		0x80000000	/* GPIO8 */
+			>;
+		};
+	};
+
+	lvds {
+		pinctrl_lvds_bkl_1: lvds_bklgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09	0x170b0		/* LCD_BKLT_EN */
+			>;
+		};
+		pinctrl_lvds_vcc_1: lvds_vccgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__GPIO6_IO07	0x170b0		/* LCD_VDD_EN */
+			>;
+		};
+	};
+
+	pcie {
+		pinctrl_pcie_1: pcie1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x80000000	/* PWR_EN */
+				MX6QDL_PAD_KEY_COL4__GPIO4_IO14		0x0001B0B0	/* PCIE_DIS_B */
+				MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20	0x0001B0B0	/* PCIE_WAKE */
+				MX6QDL_PAD_GPIO_17__GPIO7_IO12		0x80000000	/* PCIE_RST */
+			>;
+		};
+	};
+
+	spi1 {
+		pinctrl_ecspi1_cs_0: ecspi1_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19		0x80000000	/* ECSPI1_CS1 */
+			>;
+		};
+	};
+
+	spi5 {
+		pinctrl_ecspi5_cs_0: ecspi5_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT1__GPIO1_IO17		0x80000000
+			>;
+		};
+
+		pinctrl_ecspi5_cs_1: ecspi5_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT2__GPIO1_IO19		0x80000000
+			>;
+		};
+
+		pinctrl_ecspi5_1: ecspi5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT0__ECSPI5_MISO	0x100b1
+				MX6QDL_PAD_SD1_CMD__ECSPI5_MOSI		0x100b1
+				MX6QDL_PAD_SD1_CLK__ECSPI5_SCLK		0x100b1
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_1: uart2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+
+	uart3 {
+		pinctrl_uart3_2: uart3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+
+	uart4 {
+		pinctrl_uart4_1: uart4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+
+	uart5 {
+		pinctrl_uart5_1: uart5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_pwr_1: usbotg_pwr_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__GPIO3_IO22		0x000130B0	/* USB_OTG_PWR*/
+			>;
+		};
+		pinctrl_usbotg_2: usbotggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID	0x0001B0B0
+			>;
+		};
+	};
+};
+
+&ldb {
+	status = "okay";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie_1>;
+	power-on-gpio = <&gpio3 20 0>;
+	disable-gpio = <&gpio4 14 0>;
+	wake-up-gpio = <&gpio5 20 0>;
+	reset-gpio = <&gpio7 12 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1_1>;
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_1>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3_2>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4_1>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5_1>;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_2 &pinctrl_usbotg_pwr_1>;
+	vbus-supply = <&reg_usb_otg_vbus>;
+	imx6-usb-charger-detection;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_1>;
+	bus-width = <8>;
+	cd-gpios = <&gpio2 2 0>;
+	wp-gpios = <&gpio2 3 0>;
+	status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	status = "okay";
+};
+
Index: arch/arm/boot/dts/imx6dl-sabresd.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6dl-sabresd.dts b/arch/arm/boot/dts/imx6dl-sabresd.dts
--- a/arch/arm/boot/dts/imx6dl-sabresd.dts	(revision 513)
+++ b/arch/arm/boot/dts/imx6dl-sabresd.dts	(revision 1734)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -10,131 +10,110 @@
 
 #include "imx6dl.dtsi"
 #include "imx6qdl-sabresd.dtsi"
+#include "imx6dl-sabresd-common.dtsi"
 
 / {
-	model = "Freescale i.MX6 DualLite SABRE Smart Device Board";
+	model = "Freescale i.MX6 DualLite SABRE Smart Device Board(PFUZE100)";
 	compatible = "fsl,imx6dl-sabresd", "fsl,imx6dl";
 };
 
-&battery {
-	offset-charger = <1485>;
-	offset-discharger = <1464>;
-	offset-usb-charger = <1285>;
-};
+&i2c2 {
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
 
-&i2c3 {
-	max17135@48 {
-		compatible = "maxim,max17135";
-		reg = <0x48>;
-		vneg_pwrup = <1>;
-		gvee_pwrup = <1>;
-		vpos_pwrup = <2>;
-		gvdd_pwrup = <1>;
-		gvdd_pwrdn = <1>;
-		vpos_pwrdn = <2>;
-		gvee_pwrdn = <1>;
-		vneg_pwrdn = <1>;
-		SENSOR-supply = <&reg_sensor>;
-		gpio_pmic_pwrgood = <&gpio2 21 0>;
-		gpio_pmic_vcom_ctrl = <&gpio3 17 0>;
-		gpio_pmic_wakeup = <&gpio3 20 0>;
-		gpio_pmic_v3p3 = <&gpio2 20 0>;
-		gpio_pmic_intr = <&gpio2 25 0>;
-
 		regulators {
-			DISPLAY_reg: DISPLAY {
-				regulator-name = "DISPLAY";
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
 			};
 
-			GVDD_reg: GVDD {
-				/* 20v */
-				regulator-name = "GVDD";
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
 			};
 
-			GVEE_reg: GVEE {
-				/* -22v */
-				regulator-name = "GVEE";
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			HVINN_reg: HVINN {
-				/* -22v */
-				regulator-name = "HVINN";
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			HVINP_reg: HVINP {
-				/* 20v */
-				regulator-name = "HVINP";
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			VCOM_reg: VCOM {
-				regulator-name = "VCOM";
-				/* 2's-compliment, -4325000 */
-				regulator-min-microvolt = <0xffbe0178>;
-				/* 2's-compliment, -500000 */
-				regulator-max-microvolt = <0xfff85ee0>;
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
 			};
 
-			VNEG_reg: VNEG {
-				/* -15v */
-				regulator-name = "VNEG";
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
 			};
 
-			VPOS_reg: VPOS {
-				/* 15v */
-				regulator-name = "VPOS";
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
 			};
 
-			V3P3_reg: V3P3 {
-				regulator-name = "V3P3";
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
 			};
-		};
-	};
-};
 
-&iomuxc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_hog_1>, <&pinctrl_hog_2>;
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
 
-	hog {
-		pinctrl_hog_2: hoggrp-2 {
-			fsl,pins = <
-				/* MAX17135 */
-				MX6QDL_PAD_EIM_A17__GPIO2_IO21 0x80000000
-				MX6QDL_PAD_EIM_D17__GPIO3_IO17 0x80000000
-				MX6QDL_PAD_EIM_D20__GPIO3_IO20 0x80000000
-				MX6QDL_PAD_EIM_A18__GPIO2_IO20 0x80000000
-				MX6QDL_PAD_EIM_OE__GPIO2_IO25 0x80000000
-				/* elan touch */
-				MX6QDL_PAD_EIM_A20__GPIO2_IO18 0x80000000
-				MX6QDL_PAD_EIM_DA8__GPIO3_IO08 0x80000000
-				MX6QDL_PAD_EIM_D28__GPIO3_IO28 0x170b0
-			>;
-		};
-	};
-};
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
 
-&epdc {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_epdc_0>;
-	V3P3-supply = <&V3P3_reg>;
-	VCOM-supply = <&VCOM_reg>;
-	DISPLAY-supply = <&DISPLAY_reg>;
-	status = "okay";
-};
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
 
-&ldb {
-	ipu_id = <0>;
-	sec_ipu_id = <0>;
-};
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
 
-&mxcfb1 {
-	status = "okay";
-};
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
 
-&mxcfb2 {
-	status = "okay";
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
 };
-
-&pxp {
-	status = "okay";
-};
Index: arch/arm/boot/dts/imx6qdl-advantech.dtsi
===================================================================
diff --git a/arch/arm/boot/dts/imx6qdl-advantech.dtsi b/arch/arm/boot/dts/imx6qdl-advantech.dtsi
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6qdl-advantech.dtsi	(revision 1734)
@@ -0,0 +1,311 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_2p5v: 2p5v {
+			compatible = "regulator-fixed";
+			regulator-name = "2P5V";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+	};
+
+	audio_sgtl5000: sound {
+		compatible = "fsl,imx-audio-sgtl5000";
+		model = "imx-audio-sgtl5000";
+		ssi-controller = <&ssi2>;
+		audio-routing =
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT";
+		mux-int-port = <2>;
+		mux-ext-port = <3>;
+	};
+
+	audio_hdmi: sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="800x480M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="800x480M@60";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	lcd: lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB565";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_1>;
+		status = "okay";
+	};
+
+	bkl: backlight {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lvds_bkl_1 &pinctrl_lvds_vcc_1>;
+		compatible = "pwm-backlight";
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		status = "disabled";
+	};
+
+	v4l2_capture_0: v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "disabled";
+	};
+
+	v4l2_capture_1: v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "disabled";
+	};
+
+	v4l2_output: v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_2>;
+	status = "okay";
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio2 30 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_cs_0 &pinctrl_ecspi1_1>;
+	status = "okay";
+
+	m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1_1>;
+	phy-mode = "rgmii";
+	status = "okay";
+};
+
+&gpc {
+	fsl,ldo-bypass = <0>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <1>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_2>;
+	status = "okay";
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_2>;
+	status = "okay";
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_2>;
+	status = "okay";
+};
+
+&iomuxc {
+
+	enet1 {
+		pinctrl_enet1_1: enet1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b030
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b030
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b030
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b030
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b030
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b030
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x0A0B1
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b030
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b030
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b030
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b030
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b030
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b030
+			>;
+		};
+	};
+
+	hog {
+		/* Common GPIO */
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02 	0x80000000	/* SD2_CD */
+				MX6QDL_PAD_NANDF_D3__GPIO2_IO03 	0x80000000	/* SD2_WP */
+				MX6QDL_PAD_EIM_D30__GPIO3_IO30 		0x80000000	/* BORAD_ID0 */
+				MX6QDL_PAD_EIM_D31__GPIO3_IO31 		0x80000000	/* BORAD_ID1 */
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1   		0x130b0     /* AUDIO CLK */
+			>;
+		};
+	};
+
+	lvds {
+		pinctrl_lvds_bkl_1: lvds_bklgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL0__GPIO4_IO06		0x170b0		/* LCD_BKLT_EN */
+			>;
+		};
+		pinctrl_lvds_vcc_1: lvds_vccgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07		0x170b0		/* LCD_VDD_EN */
+			>;
+		};
+	};
+};
+
+&ldb {
+	ipu_id = <1>;
+	disp_id = <0>;
+	ext_ref = <1>;
+	mode = "sep0";
+	sec_ipu_id = <0>;
+	sec_disp_id = <1>;
+	status = "disabled";
+};
+
+&mipi_csi {
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+	status = "disabled";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&vpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
Index: arch/arm/boot/dts/imx6q-rsb4410.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6q-rsb4410.dts b/arch/arm/boot/dts/imx6q-rsb4410.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6q-rsb4410.dts	(revision 1734)
@@ -0,0 +1,281 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-advantech.dtsi"
+
+/ {
+	model = "Freescale i.MX6 Quad RSB4410";
+	compatible = "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	board {
+		compatible = "proc-board";
+		board-type = "RSB-4410";
+		board-cpu = "DualQuad";
+	};
+
+	ir {
+		//compatible = "fsl,lirc_rpi";
+		compatible = "gpio-ir-receiver";
+		pinctrl-0 = <&pinctrl_ir_1>;
+		gpios=<&gpio1 2 1>;
+		linux,rc-map-name = "rc-rc6-mce";
+	};
+};
+
+&audio_sgtl5000 {
+	audio-codec = <&codec>;
+};
+
+&bkl {
+	lvds-bkl-enable = <&gpio4 6 1>;
+	lvds-vcc-enable = <&gpio4 7 1>;
+	pwms = <&pwm2 0 5000000>;
+	status = "okay";
+};
+
+&i2c1 {
+
+	codec: sgtl5000@0a {
+		compatible = "fsl,sgtl5000";
+		reg = <0x0a>;
+		clocks = <&clks 201>;
+		VDDA-supply = <&reg_2p5v>;
+		VDDIO-supply = <&reg_3p3v>;
+		mclk = <16000000>;
+		mclk_source = <0>;
+	};
+
+	s35390a@30 {
+		compatible = "fsl,s35390a";
+		reg = <0x30>;
+	};
+
+	wdt@29 {
+		compatible = "fsl,adv-wdt-i2c";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_wdt_en_1 &pinctrl_wdt_ping_1>;
+		status = "okay";
+		wdt-en = <&gpio2 5 0>;
+		wdt-ping = <&gpio1 9 0>;
+		reg = <0x29>;
+	};
+};
+
+&i2c2 {
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+&i2c3 {
+
+	ch7055@76 {
+		compatible = "fsl,ch7055";
+		reg = <0x76>;
+	};
+
+	mxc_vga_i2c@50 {
+		compatible = "fsl,mxc_vga_i2c";
+		reg = <0x50>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1 &pinctrl_hog_2>;
+
+	hog {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20 		0x80000000	/* 3G_DET# */
+				MX6QDL_PAD_EIM_D24__GPIO3_IO24 		0x80000000	/* ALL_SYS_PG */
+				MX6QDL_PAD_EIM_D25__GPIO3_IO25 		0x80000000	/* PLTRST# */
+				MX6QDL_PAD_SD1_CMD__GPIO1_IO18		0x80000000	/* GPIO1 */
+				MX6QDL_PAD_SD1_CLK__GPIO1_IO20		0x80000000	/* GPIO2 */
+				MX6QDL_PAD_SD1_DAT0__GPIO1_IO16		0x80000000	/* GPIO3 */
+				MX6QDL_PAD_SD1_DAT1__GPIO1_IO17		0x80000000	/* GPIO4 */
+				MX6QDL_PAD_SD3_CMD__GPIO7_IO02		0x80000000	/* GPIO5 */
+				MX6QDL_PAD_SD3_CLK__GPIO7_IO03		0x80000000	/* GPIO6 */
+				MX6QDL_PAD_SD3_DAT0__GPIO7_IO04		0x80000000	/* GPIO7 */
+				MX6QDL_PAD_SD3_DAT1__GPIO7_IO05		0x80000000	/* GPIO8 */
+			>;
+		};
+	};
+
+	ir {
+		pinctrl_ir_1: irgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02		0x80000000	/* GPIO IR-IN */
+			>;
+		};
+	};
+
+	pcie {
+		pinctrl_pcie_1: pciegrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19		0x80000000	/* PCIE_DIS_B */
+			>;
+		};
+	};
+
+	pwm {
+		pinctrl_pwm2_1: pwm2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__PWM2_OUT			0x1b0b1
+			>;
+		};
+	};
+
+	spi1 {
+		pinctrl_ecspi1_cs_0: ecspi1_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__GPIO2_IO30		0x80000000	/* ECSPI1_CS0 */
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_3: uart2grp-3 { /* DCE mode */
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D28__UART2_CTS_B		0x1b0b1
+				MX6QDL_PAD_EIM_D29__UART2_RTS_B		0x1b0b1
+			>;
+		};
+	};
+
+	uart4 {
+		pinctrl_uart4_1: uart4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+
+	uart5 {
+		pinctrl_uart5_1: uart5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+
+	wdt{
+		pinctrl_wdt_en_1: wdt_engrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_D5__GPIO2_IO05		0x80000000
+			>;
+		};
+		pinctrl_wdt_ping_1: wdt_pinggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_9__GPIO1_IO09		0x80000000
+			>;
+		};
+	};
+};
+
+&ldb {
+	status = "okay";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie_1>;
+	disable-gpio = <&gpio3 19 0>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2_1>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_3>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4_1>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5_1>;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_2>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_2>;
+	cd-gpios = <&gpio2 2 0>;
+	wp-gpios = <&gpio2 3 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&wdog1 {
+	status = "disabled";
+};
Index: arch/arm/boot/dts/imx6q-rom5420.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6q-rom5420.dts b/arch/arm/boot/dts/imx6q-rom5420.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6q-rom5420.dts	(revision 1734)
@@ -0,0 +1,581 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-advantech.dtsi"
+
+/ {
+	model = "Freescale i.MX6 Quad ROM5420";
+	compatible = "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	board {
+		compatible = "proc-board";
+		board-type = "ROM-5420";
+		board-cpu = "DualQuad";
+	};
+
+	regulators {
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 28  GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+	};
+
+	gpio-keys {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_sleep_1>;
+		compatible = "gpio-keys";
+		sleep {
+			label = "Sleep Button";
+			gpios = <&gpio1 25 1>; /* active low */
+			linux,input-type = <1>;
+			linux,code = <205>; /* KEY_SUSPEND */
+			debounce_interval = <1>;
+			gpio-key,wakeup;
+		};
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+			   "fsl,imx6q-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+		spdif-in;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds_suspend_1>;
+		suspend-led {	/* STBY_LED */
+			label = "suspend_led";
+			gpios = <&gpio4 15 0>;
+			linux,default-trigger = "default-on";
+			default-state = "on";
+		};
+	};
+};
+
+&audio_sgtl5000 {
+	audio-codec = <&codec>;
+};
+
+&bkl {
+	lvds-bkl-enable = <&gpio4 6 1>;
+	lvds-vcc-enable = <&gpio4 7 1>;
+	pwms = <&pwm1 0 5000000>;
+	status = "okay";
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio3 20 0>, <&gpio5 2 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_1 &pinctrl_ecspi4_cs_0 &pinctrl_ecspi4_cs_1>;
+	status = "okay";
+
+	chip1: m25p80@0 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+	chip2: m25p80@1 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <1>;
+	};
+};
+
+&ecspi5 {
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio1 17 0>, <&gpio1 19 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi5_1 &pinctrl_ecspi5_cs_0 &pinctrl_ecspi5_cs_1>;
+	status = "okay";
+
+	chip3: m25p80@0 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+	chip4: m25p80@1 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <1>;
+	};
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_1>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_1>;
+	status = "okay";
+};
+
+&i2c1 {
+
+	ch7055@76 {
+		compatible = "fsl,ch7055";
+		reg = <0x76>;
+	};
+
+	mxc_vga_i2c@50 {
+		compatible = "fsl,mxc_vga_i2c";
+		reg = <0x50>;
+	};
+};
+
+&i2c2 {
+
+	i2cmux@70 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "nxp,pca9545";
+		reg = <0x70>;
+
+		i2c2@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			ov5640_mipi: ov5640_mipi@3c {
+				compatible = "ovti,ov5640_mipi";
+				reg = <0x3c>;
+				clocks = <&clks 201>;
+				clock-names = "csi_mclk";
+				DOVDD-supply = <&reg_3p3v>; /* 3.3v, enabled via 2.8 VGEN6 */
+				AVDD-supply = <&reg_3p3v>;  /* 1.8v */
+				DVDD-supply = <&reg_3p3v>;  /* 1.8v */
+				PVDD-supply = <&reg_3p3v>;  /* 1.8v */
+				pwn-gpios = <&gpio1 2 1>;   /* active low: SD1_CLK */
+				rst-gpios = <&gpio1 5 0>;   /* active high: SD1_DAT2 */
+				csi_id = <1>;
+				mclk = <24000000>;
+				mclk_source = <0>;
+			};
+		};
+
+		i2c2@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			codec: sgtl5000@0a {
+				compatible = "fsl,sgtl5000";
+				reg = <0x0a>;
+				clocks = <&clks 201>;
+				VDDA-supply = <&reg_2p5v>;
+				VDDIO-supply = <&reg_3p3v>;
+				mclk = <16000000>;
+				mclk_source = <0>;
+			};
+
+			ec@30 {
+				compatible = "fsl,ec";
+				reg = <0x30>;
+			};
+
+			24c32@57 {
+				compatible = "fsl,24c32";
+				reg = <0x57>;
+			};
+		};
+
+		i2c2@2 {
+			reg = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			hdmi: edid@50 {
+				compatible = "fsl,imx6-hdmi-i2c";
+				reg = <0x50>;
+			};
+		};
+
+		i2c2@3 {
+			reg = <3>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			s35390a@30 {
+				compatible = "fsl,s35390a";
+				reg = <0x30>;
+			};
+		};
+	};
+};
+
+&i2c3 {
+
+	24c32@50 {
+		compatible = "fsl,24c32";
+		reg = <0x50>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1 &pinctrl_hog_2>;
+
+	flexcan1 {
+		pinctrl_flexcan1_1: flexcan1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__FLEXCAN1_TX		0x80000000
+				MX6QDL_PAD_SD3_CLK__FLEXCAN1_RX		0x80000000
+			>;
+		};
+	};
+
+	flexcan2 {
+		pinctrl_flexcan2_1: flexcan2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT0__FLEXCAN2_TX	0x80000000
+				MX6QDL_PAD_SD3_DAT1__FLEXCAN2_RX	0x80000000
+			>;
+		};
+	};
+
+	gpio-keys {
+			pinctrl_gpio_sleep_1: gpio_sleep1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25	0x80000000	/* SLEEP Button */
+			>;
+		};
+	};
+
+	hog {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__GPIO1_IO01		0x80000000	/* GPIO0 */
+				MX6QDL_PAD_GPIO_4__GPIO1_IO04		0x80000000	/* GPIO2 */
+				MX6QDL_PAD_GPIO_18__GPIO7_IO13		0x80000000	/* GPIO4 */
+				MX6QDL_PAD_SD1_DAT3__GPIO1_IO21		0x80000000	/* GPIO5 */
+				MX6QDL_PAD_SD3_DAT2__GPIO7_IO06		0x80000000	/* GPIO6 */
+				MX6QDL_PAD_SD3_DAT3__GPIO7_IO07		0x80000000	/* GPIO7 */
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x80000000	/* GPIO8 */
+				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x80000000	/* GPIO9 */
+				MX6QDL_PAD_SD3_DAT6__GPIO6_IO18		0x80000000	/* GPIO10 */
+				MX6QDL_PAD_SD3_DAT7__GPIO6_IO17		0x80000000	/* GPIO11 */
+				MX6QDL_PAD_NANDF_D0__GPIO2_IO00		0x80000000	/* Battery CHARGER_PRSN */
+				MX6QDL_PAD_NANDF_CLE__GPIO6_IO07	0x80000000	/* Battery BATLOW */
+				MX6QDL_PAD_NANDF_RB0__GPIO6_IO10	0x80000000	/* Battery CHARGING */
+			>;
+		};
+	};
+
+        ipu1 {
+                pinctrl_ipu1_4: ipu1grp-4 {
+                        fsl,pins = <
+                                MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0xE9
+                                MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0xE9
+                                MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0xE9
+                                MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0xE9
+                                MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000
+                                MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0xE9
+                                MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0xE9
+                                MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0xE9
+                                MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0xE9
+                                MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0xE9
+                                MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0xE9
+                                MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0xE9
+                                MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0xE9
+                                MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0xE9
+                                MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0xE9
+                                MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0xE9
+                                MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0xE9
+                                MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0xE9
+                                MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0xE9
+                                MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0xE9
+                                MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0xE9
+                                MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0xE9
+                                MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0xE9
+                                MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0xE9
+                                MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0xE9
+                                MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0xE9
+                                MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0xE9
+                                MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0xE9
+                                MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0xE9
+                        >;
+                };
+	};
+
+	leds {
+		pinctrl_leds_suspend_1: leds_suspend1grp-1{
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW4__GPIO4_IO15		0x80000000	/* Suspend LED */
+			>;
+		};
+	};
+
+	mipi-csi {
+		pinctrl_mipi_csi_1: mipi_csi1grp-1{
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02		0x80000000	/* GPIO1=MIPICSI_PWN */
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05		0x80000000	/* GPIO3=MIPICSI_RST */
+				MX6QDL_PAD_CSI0_MCLK__CCM_CLKO1		0x80000000	/* CSI0_MCLK */
+			>;
+		};
+	};
+
+	pcie {
+		pinctrl_pcie_1: pcie1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30	0x80000000	/* PCIE_WAKE */
+				MX6QDL_PAD_KEY_ROW1__GPIO4_IO09		0x80000000	/* PCIE_RST */
+			>;
+		};
+	};
+
+	pwm1 {
+		pinctrl_pwm1_1: pwm1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_9__PWM1_OUT			0x1b0b1
+			>;
+		};
+	};
+
+	spi1 {
+		pinctrl_ecspi1_cs_0: ecspi1_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__GPIO2_IO30		0x80000000	/* ECSPI1_CS0 */
+			>;
+		};
+	};
+
+	spi4 {
+		pinctrl_ecspi4_cs_0: ecspi4_cs_grp-0 {
+			fsl,pins = <
+				 MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x80000000	/* ECSPI4_CS0 */
+			>;
+		};
+
+		pinctrl_ecspi4_cs_1: ecspi4_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A25__GPIO5_IO02		0x80000000	/* ECSPI4_CS1 */
+			>;
+		};
+
+		pinctrl_ecspi4_1: ecspi4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO		0x170f1
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI		0x1B008
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK		0x170f1
+			>;
+		};
+	};
+
+	spi5 {
+		pinctrl_ecspi5_cs_0: ecspi5_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT1__GPIO1_IO17		0x80000000	/* ECSPI5_CS0 */
+			>;
+		};
+
+		pinctrl_ecspi5_cs_1: ecspi5_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT2__GPIO1_IO19		0x80000000	/* ECSPI5_CS1 */
+			>;
+		};
+
+		pinctrl_ecspi5_1: ecspi5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT0__ECSPI5_MISO	0x170f1
+				MX6QDL_PAD_SD1_CMD__ECSPI5_MOSI		0x1B008
+				MX6QDL_PAD_SD1_CLK__ECSPI5_SCLK		0x170f1
+			>;
+		};
+	};
+
+	uart3 {
+		pinctrl_uart3_1: uart3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D24__UART3_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D25__UART3_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+
+	uart4 {
+		pinctrl_uart4_1: uart4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT16__UART4_RTS_B		0x1b0b1
+				MX6QDL_PAD_CSI0_DAT17__UART4_CTS_B		0x1b0b1
+			>;
+		};
+	};
+
+	uart5 {
+		pinctrl_uart5_1: uart5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT18__UART5_RTS_B		0x1b0b1
+				MX6QDL_PAD_CSI0_DAT19__UART5_RTS_B		0x1b0b1
+			>;
+		};
+	};
+
+	usbh1 {
+		pinctrl_usbh1_1: usbh1_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_TX_EN__GPIO1_IO28	0x80000000	/* USB0_EN_OC */
+			>;
+		};
+	};
+
+	usbh2 {
+		pinctrl_usbh2_3: usbh2_grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RXD0__GPIO1_IO27	0x80000000	/* USB1_EN_OC */
+			>;
+		};
+	};
+};
+
+&lcd {
+	pinctrl-0 = <&pinctrl_ipu1_4>;
+	status = "okay";
+};
+
+
+&ldb {
+	status = "okay";
+};
+
+&mipi_csi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mipi_csi_1>;
+	status = "okay";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie_1>;
+	power-on-gpio = <&gpio1 30 0>;
+	reset-gpio = <&gpio4 9 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1_1>;
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_2>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_1>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3_1>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4_1>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5_1>;
+	status = "okay";
+};
+
+&usbh1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbh1_1>;
+	status = "okay";
+};
+
+&usbh2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbh2_3>;
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_2>;
+	vbus-supply = <&reg_usb_otg_vbus>;
+	imx6-usb-charger-detection;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_1>;
+	bus-width = <8>;
+	cd-gpios = <&gpio2 2 0>;
+	wp-gpios = <&gpio2 3 0>;
+	status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	status = "okay";
+};
+
+&v4l2_capture_1 {
+	status = "okay";
+};
Index: arch/arm/boot/dts/imx6dl-sabresd-common.dtsi
===================================================================
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-common.dtsi b/arch/arm/boot/dts/imx6dl-sabresd-common.dtsi
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6dl-sabresd-common.dtsi	(revision 1734)
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&battery {
+	offset-charger = <1485>;
+	offset-discharger = <1464>;
+	offset-usb-charger = <1285>;
+};
+
+&i2c3 {
+	max17135@48 {
+		compatible = "maxim,max17135";
+		reg = <0x48>;
+		vneg_pwrup = <1>;
+		gvee_pwrup = <1>;
+		vpos_pwrup = <2>;
+		gvdd_pwrup = <1>;
+		gvdd_pwrdn = <1>;
+		vpos_pwrdn = <2>;
+		gvee_pwrdn = <1>;
+		vneg_pwrdn = <1>;
+		SENSOR-supply = <&reg_sensor>;
+		gpio_pmic_pwrgood = <&gpio2 21 0>;
+		gpio_pmic_vcom_ctrl = <&gpio3 17 0>;
+		gpio_pmic_wakeup = <&gpio3 20 0>;
+		gpio_pmic_v3p3 = <&gpio2 20 0>;
+		gpio_pmic_intr = <&gpio2 25 0>;
+
+		regulators {
+			DISPLAY_reg: DISPLAY {
+				regulator-name = "DISPLAY";
+			};
+
+			GVDD_reg: GVDD {
+				/* 20v */
+				regulator-name = "GVDD";
+			};
+
+			GVEE_reg: GVEE {
+				/* -22v */
+				regulator-name = "GVEE";
+			};
+
+			HVINN_reg: HVINN {
+				/* -22v */
+				regulator-name = "HVINN";
+			};
+
+			HVINP_reg: HVINP {
+				/* 20v */
+				regulator-name = "HVINP";
+			};
+
+			VCOM_reg: VCOM {
+				regulator-name = "VCOM";
+				/* 2's-compliment, -4325000 */
+				regulator-min-microvolt = <0xffbe0178>;
+				/* 2's-compliment, -500000 */
+				regulator-max-microvolt = <0xfff85ee0>;
+			};
+
+			VNEG_reg: VNEG {
+				/* -15v */
+				regulator-name = "VNEG";
+			};
+
+			VPOS_reg: VPOS {
+				/* 15v */
+				regulator-name = "VPOS";
+			};
+
+			V3P3_reg: V3P3 {
+				regulator-name = "V3P3";
+			};
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>, <&pinctrl_hog_2>;
+
+	hog {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				/* MAX17135 */
+				MX6QDL_PAD_EIM_A17__GPIO2_IO21 0x80000000
+				MX6QDL_PAD_EIM_D17__GPIO3_IO17 0x80000000
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20 0x80000000
+				MX6QDL_PAD_EIM_A18__GPIO2_IO20 0x80000000
+				MX6QDL_PAD_EIM_OE__GPIO2_IO25 0x80000000
+				/* elan touch */
+				MX6QDL_PAD_EIM_A20__GPIO2_IO18 0x80000000
+				MX6QDL_PAD_EIM_DA8__GPIO3_IO08 0x80000000
+				MX6QDL_PAD_EIM_D28__GPIO3_IO28 0x170b0
+			>;
+		};
+	};
+};
+
+&epdc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_epdc_0>;
+	V3P3-supply = <&V3P3_reg>;
+	VCOM-supply = <&VCOM_reg>;
+	DISPLAY-supply = <&DISPLAY_reg>;
+	status = "okay";
+};
+
+&ldb {
+	ipu_id = <0>;
+	sec_ipu_id = <0>;
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
Index: arch/arm/boot/dts/imx6q-sabresd.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6q-sabresd.dts b/arch/arm/boot/dts/imx6q-sabresd.dts
--- a/arch/arm/boot/dts/imx6q-sabresd.dts	(revision 513)
+++ b/arch/arm/boot/dts/imx6q-sabresd.dts	(revision 1734)
@@ -26,6 +26,107 @@
 	offset-usb-charger = <1685>;
 };
 
+&i2c2 {
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
 &mxcfb1 {
 	status = "okay";
 };
Index: arch/arm/boot/dts/imx6q-rom3420.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6q-rom3420.dts b/arch/arm/boot/dts/imx6q-rom3420.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6q-rom3420.dts	(revision 1734)
@@ -0,0 +1,658 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-advantech.dtsi"
+
+/ {
+	model = "Freescale i.MX6 Quad ROM3420";
+	compatible = "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	board {
+		compatible = "proc-board";
+		board-type = "ROM-3420";
+		board-cpu = "DualQuad";
+	};
+
+	regulators {
+
+		reg_0v: 0v {
+			compatible = "regulator-fixed";
+			regulator-name = "0V";
+			regulator-min-microvolt = <0>;
+			regulator-max-microvolt = <0>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 15  GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+	};
+
+	gpio-keys {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_sleep_1>;
+		compatible = "gpio-keys";
+		sleep {
+			label = "Sleep Button";
+			gpios = <&gpio1 25 1>; /* active low */
+			linux,input-type = <1>;
+			linux,code = <205>; /* KEY_SUSPEND */
+			debounce_interval = <1>;
+			gpio-key,wakeup;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds_suspend_1>;
+		suspend-led {	/* STBY_LED */
+			label = "suspend_led";
+			gpios = <&gpio6 10 0>;
+			linux,default-trigger = "default-on";
+			default-state = "on";
+		};
+	};
+
+	matrix_keypad: matrix_keypad@0 {
+		compatible = "gpio-matrix-keypad";
+		debounce-delay-ms = <5>;
+		col-scan-delay-us = <2>;
+
+		row-gpios = <&gpio7 12 0	/* Bank7, pin12 */
+					 &gpio7 13 0	/* Bank7, pin13 */
+					 &gpio7  6 0	/* Bank7, pin6 */
+					 &gpio7  7 0>;	/* Bank7, pin7 */
+
+		col-gpios = <&gpio1 5 0		/* Bank1, pin5 */
+					 &gpio2 3 0		/* Bank2, pin3 */
+					 &gpio2 2 0		/* Bank2, pin2 */
+					 &gpio1 1 0>;	/* Bank1, pin1 */
+
+		linux,keymap = <0x00000001		/* KEY_ESC */
+						0x00010002		/* KEY_1 */
+						0x00020003		/* KEY_2 */
+						0x00030004		/* KEY_3 */
+						0x01000005		/* KEY_4 */
+						0x01010006		/* KEY_5 */
+						0x01020007		/* KEY_6 */
+						0x01030008		/* KEY_7 */
+						0x02000009		/* KEY_8 */
+						0x0201000A		/* KEY_9 */
+						0x0202000B		/* KEY_0 */
+						0x0203000C		/* KEY_MINUS */
+						0x0300000D		/* KEY_EQUAL */
+						0x0301000E		/* KEY_BACKSPACE */
+						0x0302000F		/* KEY_TAB */
+						0x03030010>;	/* KEY_Q */
+	};
+
+	sysbus_uart {
+		compatible = "adv-sysbus-uart";
+		sysbus-int1 = <&gpio4 11 0>;
+		sysbus-int2 = <&gpio7 11 0>;
+	};
+};
+
+&audio_sgtl5000 {
+	audio-codec = <&codec>;
+};
+
+&bkl {
+	lvds-bkl-enable = <&gpio5 20 1>;
+	lvds-vcc-enable = <&gpio5 21 1>;
+	pwms = <&pwm1 0 5000000>;
+	status = "okay";
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio4 9 0>, <&gpio4 10 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_3 &pinctrl_ecspi1_cs_0 &pinctrl_ecspi1_cs_2>;
+	status = "okay";
+
+	chip4: m25p80@0 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+	chip5: m25p80@1 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <1>;
+	};
+};
+
+&ecspi5 {
+	fsl,spi-num-chipselects = <3>;
+	cs-gpios = <&gpio1 17 0>, <&gpio1 19 0>, <&gpio1 21 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi5_1 &pinctrl_ecspi5_cs_0 &pinctrl_ecspi5_cs_1 &pinctrl_ecspi5_cs_2>;
+	status = "okay";
+
+	chip1: m25p80@0 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+	chip2: m25p80@1 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <1>;
+	};
+	chip3: m25p80@2 {
+		compatible = "micron,n25q";
+		spi-max-frequency = <20000000>;
+		reg = <2>;
+	};
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_1>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_1>;
+	status = "okay";
+};
+
+&i2c1 {
+
+	ch7055@76 {
+		compatible = "fsl,ch7055";
+		reg = <0x76>;
+	};
+
+	mxc_vga_i2c@50 {
+		compatible = "fsl,mxc_vga_i2c";
+		reg = <0x50>;
+	};
+};
+
+&i2c2 {
+
+	i2cmux@70 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "nxp,pca9545";
+		reg = <0x70>;
+
+		i2c2@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			ov5640_mipi: ov5640_mipi@3c {
+				compatible = "ovti,ov5640_mipi";
+				reg = <0x3c>;
+				clocks = <&clks 201>;
+				clock-names = "csi_mclk";
+				DOVDD-supply = <&reg_3p3v>; /* 3.3v, enabled via 2.8 VGEN6 */
+				AVDD-supply = <&reg_3p3v>;  /* 1.8v */
+				DVDD-supply = <&reg_3p3v>;  /* 1.8v */
+				PVDD-supply = <&reg_3p3v>;  /* 1.8v */
+				pwn-gpios = <&gpio7 8 1>;
+				rst-gpios = <&gpio6 17 0>;
+				csi_id = <1>;
+				mclk = <24000000>;
+				mclk_source = <0>;
+			};
+		};
+
+		i2c2@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			24c32@50 {
+				compatible = "fsl,24c32";
+				reg = <0x50>;
+			};
+
+			24c32@57 {
+				compatible = "fsl,24c32";
+				reg = <0x57>;
+			};
+		};
+
+		i2c2@2 {
+			reg = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			hdmi: edid@50 {
+				compatible = "fsl,imx6-hdmi-i2c";
+				reg = <0x50>;
+			};
+		};
+
+		i2c2@3 {
+			reg = <3>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			s35390a@30 {
+				compatible = "fsl,s35390a";
+				reg = <0x30>;
+			};
+		};
+	};
+};
+
+&i2c3 {
+
+	codec: sgtl5000@0a {
+		compatible = "fsl,sgtl5000";
+		reg = <0x0a>;
+		clocks = <&clks 201>;
+		VDDA-supply = <&reg_2p5v>;
+		VDDIO-supply = <&reg_3p3v>;
+		mclk = <16000000>;
+		mclk_source = <0>;
+	};
+
+	24c32@50 {
+		compatible = "fsl,24c32";
+		reg = <0x50>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1 &pinctrl_hog_2 &pinctrl_hog_3>;
+
+	flexcan1 {
+		pinctrl_flexcan1_1: flexcan1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__FLEXCAN1_TX		0x80000000
+				MX6QDL_PAD_GPIO_8__FLEXCAN1_RX		0x80000000
+			>;
+		};
+	};
+
+	flexcan2 {
+		pinctrl_flexcan2_1: flexcan2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT0__FLEXCAN2_TX	0x80000000
+				MX6QDL_PAD_SD3_DAT1__FLEXCAN2_RX	0x80000000
+			>;
+		};
+	};
+
+	gpio-keys {
+			pinctrl_gpio_sleep_1: gpio_sleep1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25	0x80000000	/* SLEEP Button */
+			>;
+		};
+	};
+
+	hog {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__GPIO1_IO01		0x80000000	/* GPIO0 */
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02		0x80000000	/* GPIO1 */
+				MX6QDL_PAD_NANDF_D3__GPIO2_IO03		0x80000000	/* GPIO2 */
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05		0x80000000	/* GPIO3 */
+				MX6QDL_PAD_GPIO_17__GPIO7_IO12		0x80000000	/* GPIO4 */
+				MX6QDL_PAD_GPIO_18__GPIO7_IO13		0x80000000	/* GPIO5 */
+				MX6QDL_PAD_SD3_DAT2__GPIO7_IO06		0x80000000	/* GPIO6 */
+				MX6QDL_PAD_SD3_DAT3__GPIO7_IO07		0x80000000	/* GPIO7 */
+				MX6QDL_PAD_NANDF_ALE__GPIO6_IO08	0x80000000	/* GPIO8 */
+				MX6QDL_PAD_NANDF_D6__GPIO2_IO06		0x80000000	/* GPIO9 */
+			>;
+		};
+
+		pinctrl_hog_3: hoggrp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_CS0__EIM_CS0_B		0xb0b1		/* CS0 */
+				MX6QDL_PAD_EIM_CS1__EIM_CS1_B		0xb0b1		/* CS1 */
+				MX6QDL_PAD_KEY_ROW2__GPIO4_IO11		0x1b0b0		/* ADV_EXT_UART0_INT: CS0 - INT Pin - irq */
+				MX6QDL_PAD_GPIO_16__GPIO7_IO11		0x1b0b0		/* ADV_EXT_UART1_INT: CS1 - INT Pin - irq */
+				MX6QDL_PAD_EIM_OE__EIM_OE_B     	0xb0b1
+				MX6QDL_PAD_EIM_RW__EIM_RW       	0xb0b1
+				MX6QDL_PAD_EIM_WAIT__EIM_WAIT_B 	0xb060
+				MX6QDL_PAD_EIM_A25__EIM_ADDR25		0xb0b1
+				MX6QDL_PAD_EIM_EB2__EIM_EB2_B		0x1b0b0
+				MX6QDL_PAD_EIM_D16__EIM_DATA16		0xb0b1
+				MX6QDL_PAD_EIM_D17__EIM_DATA17		0xb0b1
+				MX6QDL_PAD_EIM_D18__EIM_DATA18		0xb0b1
+				MX6QDL_PAD_EIM_D19__EIM_DATA19		0xb0b1
+				MX6QDL_PAD_EIM_D20__EIM_DATA20		0xb0b1
+				MX6QDL_PAD_EIM_D21__EIM_DATA21		0xb0b1
+				MX6QDL_PAD_EIM_D22__EIM_DATA22		0xb0b1
+				MX6QDL_PAD_EIM_D23__EIM_DATA23		0xb0b1
+				MX6QDL_PAD_EIM_EB3__EIM_EB3_B		0x1b0b0
+				MX6QDL_PAD_EIM_D24__EIM_DATA24		0xb0b1
+				MX6QDL_PAD_EIM_D25__EIM_DATA25		0xb0b1
+				MX6QDL_PAD_EIM_D26__EIM_DATA26		0xb0b1
+				MX6QDL_PAD_EIM_D27__EIM_DATA27		0xb0b1
+				MX6QDL_PAD_EIM_D28__EIM_DATA28		0xb0b1
+				MX6QDL_PAD_EIM_D29__EIM_DATA29		0xb0b1
+				MX6QDL_PAD_EIM_D30__EIM_DATA30		0xb0b1
+				MX6QDL_PAD_EIM_D31__EIM_DATA31		0xb0b1
+				MX6QDL_PAD_EIM_A24__EIM_ADDR24		0xb0b1
+				MX6QDL_PAD_EIM_A23__EIM_ADDR23		0xb0b1
+				MX6QDL_PAD_EIM_A22__EIM_ADDR22		0xb0b1
+				MX6QDL_PAD_EIM_A21__EIM_ADDR21		0xb0b1
+				MX6QDL_PAD_EIM_A20__EIM_ADDR20		0xb0b1
+				MX6QDL_PAD_EIM_A19__EIM_ADDR19		0xb0b1
+				MX6QDL_PAD_EIM_A18__EIM_ADDR18		0xb0b1
+				MX6QDL_PAD_EIM_A17__EIM_ADDR17		0xb0b1
+				MX6QDL_PAD_EIM_A16__EIM_ADDR16		0xb0b1
+				MX6QDL_PAD_EIM_LBA__EIM_LBA_B		0xb0b1
+				MX6QDL_PAD_EIM_EB0__EIM_EB0_B		0xb0b1
+				MX6QDL_PAD_EIM_EB1__EIM_EB1_B		0xb0b1
+				MX6QDL_PAD_EIM_DA0__EIM_AD00		0xb0b1
+				MX6QDL_PAD_EIM_DA1__EIM_AD01		0xb0b1
+				MX6QDL_PAD_EIM_DA2__EIM_AD02		0xb0b1
+				MX6QDL_PAD_EIM_DA3__EIM_AD03		0xb0b1
+				MX6QDL_PAD_EIM_DA4__EIM_AD04		0xb0b1
+				MX6QDL_PAD_EIM_DA5__EIM_AD05		0xb0b1
+				MX6QDL_PAD_EIM_DA6__EIM_AD06		0xb0b1
+				MX6QDL_PAD_EIM_DA7__EIM_AD07		0xb0b1
+				MX6QDL_PAD_EIM_DA8__EIM_AD08		0xb0b1
+				MX6QDL_PAD_EIM_DA9__EIM_AD09		0xb0b1
+				MX6QDL_PAD_EIM_DA10__EIM_AD10		0xb0b1
+				MX6QDL_PAD_EIM_DA11__EIM_AD11		0xb0b1
+				MX6QDL_PAD_EIM_DA12__EIM_AD12		0xb0b1
+				MX6QDL_PAD_EIM_DA13__EIM_AD13		0xb0b1
+				MX6QDL_PAD_EIM_DA14__EIM_AD14		0xb0b1
+				MX6QDL_PAD_EIM_DA15__EIM_AD15		0xb0b1
+				MX6QDL_PAD_EIM_BCLK__EIM_BCLK		0xb0b1
+			>;
+		};
+	};
+
+	keypad {
+		pinctrl_keypad_1: keypad_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__GPIO1_IO01		0x80000000	/* col 3: GPIO0 */
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02		0x80000000	/* col 2: GPIO1 */
+				MX6QDL_PAD_NANDF_D3__GPIO2_IO03		0x80000000	/* col 1: GPIO2 */
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05		0x80000000	/* col 0: GPIO3 */
+				MX6QDL_PAD_GPIO_17__GPIO7_IO12		0x80000000	/* row 0: GPIO4 */
+				MX6QDL_PAD_GPIO_18__GPIO7_IO13		0x80000000	/* row 1: GPIO5 */
+				MX6QDL_PAD_SD3_DAT2__GPIO7_IO06		0x80000000	/* row 2: GPIO6 */
+				MX6QDL_PAD_SD3_DAT3__GPIO7_IO07		0x80000000	/* row 3: GPIO7 */
+			>;
+		};
+	};
+
+	leds {
+		pinctrl_leds_suspend_1: leds_suspend1grp-1{
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_RB0__GPIO6_IO10	0x80000000	/* Suspend LED */
+			>;
+		};
+	};
+
+	lvds {
+		pinctrl_lvds_bkl_1: lvds_bklgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20	0x170b0		/* LCD_BKLT_EN */
+			>;
+		};
+		pinctrl_lvds_vcc_1: lvds_vccgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_VSYNC__GPIO5_IO21	0x170b0		/* LCD_VDD_EN */
+			>;
+		};
+	};
+
+	mipi-csi {
+		pinctrl_mipi_csi_1: mipi_csi1grp-1{
+			fsl,pins = <
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08		0x80000000	/* MIPICSI_PWN */
+				MX6QDL_PAD_SD3_DAT7__GPIO6_IO17		0x80000000	/* MIPICSI_RST */
+				MX6QDL_PAD_CSI0_MCLK__CCM_CLKO1		0x80000000	/* CSI0_MCLK */
+			>;
+		};
+	};
+
+	pcie {
+		pinctrl_pcie_1: pcie1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_D0__GPIO2_IO00 	0x80000000	/* PCIE_WAKE_B */
+				MX6QDL_PAD_CSI0_PIXCLK__GPIO5_IO18	0x80000000	/* PCIE_RST_B_REVB */
+			>;
+		};
+	};
+
+	pwm1 {
+		pinctrl_pwm1_1: pwm1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_9__PWM1_OUT			0x1b0b1
+			>;
+		};
+	};
+
+	spi1 {
+		pinctrl_ecspi1_cs_0: ecspi1_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW1__GPIO4_IO09		0x0001B0B0	/* ECSPI1_CS0 */
+			>;
+		};
+
+		pinctrl_ecspi1_cs_2: ecspi1_cs_grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL2__GPIO4_IO10		0x0001B0B0	/* ECSPI1_CS1 */
+			>;
+		};
+
+		pinctrl_ecspi1_3: ecspi1grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL1__ECSPI1_MISO	0x0001B0B0
+				MX6QDL_PAD_KEY_ROW0__ECSPI1_MOSI	0x0001B0B0
+				MX6QDL_PAD_KEY_COL0__ECSPI1_SCLK	0x0001B0B0
+			>;
+		};
+	};
+
+	spi5 {
+		pinctrl_ecspi5_cs_0: ecspi5_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT1__GPIO1_IO17		0x0001B0B0	/* ECSPI5_CS0 */
+			>;
+		};
+
+		pinctrl_ecspi5_cs_1: ecspi5_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT2__GPIO1_IO19		0x0001B0B0	/* ECSPI5_CS1 */
+			>;
+		};
+
+		pinctrl_ecspi5_cs_2: ecspi5_cs_grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT3__GPIO1_IO21		0x0001B0B0	/* ECSPI5_CS2 */
+			>;
+		};
+
+		pinctrl_ecspi5_1: ecspi5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT0__ECSPI5_MISO	0x0001B0B0
+				MX6QDL_PAD_SD1_CMD__ECSPI5_MOSI		0x0001B0B0
+				MX6QDL_PAD_SD1_CLK__ECSPI5_SCLK		0x0001B0B0
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_4: uart2grp-4 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT5__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_SD3_DAT4__UART2_RX_DATA	0x1b0b1
+				MX6QDL_PAD_SD3_CMD__UART2_CTS_B		0x1b0b1
+				MX6QDL_PAD_SD3_CLK__UART2_RTS_B		0x1b0b1
+			>;
+		};
+	};
+
+	uart4 {
+		pinctrl_uart4_2: uart4grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT16__UART4_RTS_B		0x1b0b1
+				MX6QDL_PAD_CSI0_DAT17__UART4_CTS_B		0x1b0b1
+			>;
+		};
+	};
+
+	uart5 {
+		pinctrl_uart5_1: uart5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT18__UART5_RTS_B		0x1b0b1
+				MX6QDL_PAD_CSI0_DAT19__UART5_CTS_B		0x1b0b1
+			>;
+		};
+	};
+
+	usbh1 {
+		pinctrl_usbh1_1: usbh1_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RXD0__GPIO1_IO27	0x80000000	/* USB_HOST_OC */
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_pwr_1: usbotg_pwr_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW4__GPIO4_IO15		0x80000000	/* USB_OTG_PWR */
+				MX6QDL_PAD_KEY_COL4__GPIO4_IO14		0x80000000	/* USB_OTG_OC */
+			>;
+		};
+	};
+};
+
+&ldb {
+	status = "okay";
+};
+
+&mipi_csi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_mipi_csi_1>;
+	status = "okay";
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie_1>;
+	power-on-gpio = <&gpio2 0 0>;
+	reset-gpio = <&gpio5 18 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1_1>;
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_4>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4_2>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5_1>;
+	status = "okay";
+};
+
+&usbh1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbh1_1>;
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_2 &pinctrl_usbotg_pwr_1>;
+	vbus-supply = <&reg_usb_otg_vbus>;
+	imx6-usb-charger-detection;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_2>;
+	bus-width = <8>;
+	cd-gpios = <&gpio1 4 0>;
+	wp-gpios = <&gpio1 2 0>;
+	//vmmc-supply = <&reg_3p3v>;
+	//vqmmc-supply = <&reg_3p3v>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	bus-width = <8>;
+	//vmmc-supply = <&reg_3p3v>;
+	//vqmmc-supply = <&reg_3p3v>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&v4l2_capture_1 {
+	status = "okay";
+};
Index: arch/arm/boot/dts/imx6q-wise3310.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6q-wise3310.dts b/arch/arm/boot/dts/imx6q-wise3310.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6q-wise3310.dts	(revision 1734)
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-advantech.dtsi"
+
+/ {
+	model = "Freescale i.MX6 Quad WISE3310";
+	compatible = "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	board {
+		compatible = "proc-board";
+		board-type = "WISE-3310";
+		board-cpu = "DualQuad";
+	};
+
+	wsn {
+		compatible = "adv,dustwsn";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_dustwsn_0>;
+		status = "okay";
+	};
+};
+
+&audio_sgtl5000 {
+	status = "disabled";
+};
+
+&audio_hdmi {
+	status = "disabled";
+};
+
+&audmux {
+	status = "disabled";
+};
+
+&hdmi_audio {
+	status = "disabled";
+};
+
+&hdmi_cec {
+	status = "disabled";
+};
+
+&hdmi_core {
+	status = "disabled";
+};
+
+&hdmi_video {
+	status = "disabled";
+};
+
+&i2c1 {
+
+	s35390a@30 {
+		compatible = "fsl,s35390a";
+		reg = <0x30>;
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1 &pinctrl_hog_2>;
+
+	dustwsn {
+		pinctrl_dustwsn_0: dustwsn_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00       0x80000000
+				MX6QDL_PAD_GPIO_1__GPIO1_IO01       0x80000000
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02       0x80000000
+				MX6QDL_PAD_GPIO_3__GPIO1_IO03       0x80000000
+				MX6QDL_PAD_GPIO_4__GPIO1_IO04       0x80000000
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05       0x80000000
+				MX6QDL_PAD_GPIO_6__GPIO1_IO06       0x80000000
+				MX6QDL_PAD_GPIO_7__GPIO1_IO07       0x80000000
+			>;
+		};
+	};
+
+	hog {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02		0x80000000	/* SD2_CD */
+				MX6QDL_PAD_NANDF_D3__GPIO2_IO03		0x80000000	/* SD2_WP */
+				MX6QDL_PAD_EIM_D30__GPIO3_IO30		0x80000000	/* BORAD_ID0 */
+				MX6QDL_PAD_EIM_D31__GPIO3_IO31		0x80000000	/* BORAD_ID1 */
+			>;
+		};
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB3__GPIO2_IO31		0x80000000
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x80000000
+				MX6QDL_PAD_EIM_D24__GPIO3_IO24		0x80000000
+				MX6QDL_PAD_EIM_D25__GPIO3_IO25		0x80000000
+				MX6QDL_PAD_EIM_A24__GPIO5_IO04		0x80000000
+				MX6QDL_PAD_EIM_A23__GPIO6_IO06		0x80000000
+				MX6QDL_PAD_EIM_A22__GPIO2_IO16		0x80000000
+				MX6QDL_PAD_EIM_A21__GPIO2_IO17		0x80000000
+				MX6QDL_PAD_EIM_A20__GPIO2_IO18		0x80000000
+				MX6QDL_PAD_EIM_A19__GPIO2_IO19		0x80000000
+				MX6QDL_PAD_EIM_A18__GPIO2_IO20		0x80000000
+				MX6QDL_PAD_EIM_A17__GPIO2_IO21		0x80000000
+				MX6QDL_PAD_EIM_A16__GPIO2_IO22		0x80000000
+				MX6QDL_PAD_EIM_RW__GPIO2_IO26		0x80000000
+				MX6QDL_PAD_EIM_LBA__GPIO2_IO27		0x80000000
+				MX6QDL_PAD_EIM_EB0__GPIO2_IO28		0x80000000
+				MX6QDL_PAD_EIM_EB1__GPIO2_IO29		0x80000000
+				MX6QDL_PAD_EIM_DA0__GPIO3_IO00		0x80000000
+				MX6QDL_PAD_EIM_DA1__GPIO3_IO01		0x80000000
+				MX6QDL_PAD_EIM_DA2__GPIO3_IO02		0x80000000
+				MX6QDL_PAD_EIM_DA3__GPIO3_IO03		0x80000000
+				MX6QDL_PAD_EIM_DA4__GPIO3_IO04		0x80000000
+				MX6QDL_PAD_EIM_DA5__GPIO3_IO05		0x80000000
+				MX6QDL_PAD_EIM_DA6__GPIO3_IO06		0x80000000
+				MX6QDL_PAD_EIM_DA7__GPIO3_IO07		0x80000000
+				MX6QDL_PAD_EIM_DA8__GPIO3_IO08		0x80000000
+				MX6QDL_PAD_EIM_DA9__GPIO3_IO09		0x80000000
+				MX6QDL_PAD_EIM_DA10__GPIO3_IO10		0x80000000
+				MX6QDL_PAD_EIM_DA11__GPIO3_IO11		0x80000000
+				MX6QDL_PAD_EIM_DA12__GPIO3_IO12		0x80000000
+				MX6QDL_PAD_EIM_DA13__GPIO3_IO13		0x80000000
+				MX6QDL_PAD_EIM_DA14__GPIO3_IO14		0x80000000
+				MX6QDL_PAD_EIM_DA15__GPIO3_IO15		0x80000000
+				MX6QDL_PAD_EIM_WAIT__GPIO5_IO00		0x80000000
+				MX6QDL_PAD_ENET_RXD1__GPIO1_IO26	0x80000000
+			>;
+		};
+	};
+
+	pcie {
+		pinctrl_pcie_1: pciegrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19		0x80000000	/* PCIE_DIS_B */
+			>;
+		};
+	};
+
+	spi1 {
+		pinctrl_ecspi1_cs_0: ecspi1_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__GPIO2_IO30		0x80000000	/* ECSPI1_CS0 */
+			>;
+		};
+	};
+
+	uart5 {
+		pinctrl_uart5_1: uart5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+			>;
+		};
+	};
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie_1>;
+	disable-gpio = <&gpio3 19 0>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5_1>;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_2>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_2>;
+	cd-gpios = <&gpio2 2 0>;
+	wp-gpios = <&gpio2 3 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&v4l2_output {
+	status = "disabled";
+};
Index: arch/arm/boot/dts/imx6qdl.dtsi
===================================================================
diff --git a/arch/arm/boot/dts/imx6qdl.dtsi b/arch/arm/boot/dts/imx6qdl.dtsi
--- a/arch/arm/boot/dts/imx6qdl.dtsi	(revision 513)
+++ b/arch/arm/boot/dts/imx6qdl.dtsi	(revision 1734)
@@ -846,6 +846,16 @@
 				status = "disabled";
 			};
 
+			usdhc4: usdhc@0219c000 {
+				compatible = "fsl,imx6q-usdhc";
+				reg = <0x0219c000 0x4000>;
+				interrupts = <0 25 0x04>;
+				clocks = <&clks 166>, <&clks 166>, <&clks 166>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <4>;
+				status = "disabled";
+			};
+
 			usdhc2: usdhc@02194000 {
 				compatible = "fsl,imx6q-usdhc";
 				reg = <0x02194000 0x4000>;
@@ -866,15 +876,6 @@
 				status = "disabled";
 			};
 
-			usdhc4: usdhc@0219c000 {
-				compatible = "fsl,imx6q-usdhc";
-				reg = <0x0219c000 0x4000>;
-				interrupts = <0 25 0x04>;
-				clocks = <&clks 166>, <&clks 166>, <&clks 166>;
-				clock-names = "ipg", "ahb", "per";
-				bus-width = <4>;
-				status = "disabled";
-			};
 
 			i2c1: i2c@021a0000 {
 				#address-cells = <1>;
Index: arch/arm/boot/dts/imx6sl-evk-common.dtsi
===================================================================
diff --git a/arch/arm/boot/dts/imx6sl-evk-common.dtsi b/arch/arm/boot/dts/imx6sl-evk-common.dtsi
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6sl-evk-common.dtsi	(revision 1734)
@@ -0,0 +1,504 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	memory {
+		reg = <0x80000000 0x40000000>;
+	};
+
+	battery: max8903@0 {
+		compatible = "fsl,max8903-charger";
+		pinctrl-names = "default";
+		dok_input = <&gpio4 13 1>;
+		uok_input = <&gpio4 13 1>;
+		chg_input = <&gpio4 15 1>;
+		flt_input = <&gpio4 14 1>;
+		fsl,dcm_always_high;
+		fsl,dc_valid;
+		fsl,adc_disable;
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		reg_lcd_3v3: lcd-3v3 {
+			compatible = "regulator-fixed";
+			regulator-name = "lcd-3v3";
+			gpio = <&gpio4 3 0>;
+			enable-active-high;
+		};
+
+		reg_aud3v: wm8962_supply_3v15 {
+			compatible = "regulator-fixed";
+			regulator-name = "wm8962-supply-3v15";
+			regulator-min-microvolt = <3150000>;
+			regulator-max-microvolt = <3150000>;
+			regulator-boot-on;
+		};
+
+		reg_aud4v: wm8962_supply_4v2 {
+			compatible = "regulator-fixed";
+			regulator-name = "wm8962-supply-4v2";
+			regulator-min-microvolt = <4325000>;
+			regulator-max-microvolt = <4325000>;
+			regulator-boot-on;
+		};
+
+		reg_usb_otg1_vbus: usb_otg1_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 0 0>;
+			enable-active-high;
+		};
+
+		reg_usb_otg2_vbus: usb_otg2_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg2_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 2 0>;
+			enable-active-high;
+		};
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+	};
+
+	csi_v4l2_cap {
+		compatible = "fsl,imx6sl-csi-v4l2";
+		status = "disabled";
+	};
+
+	pxp_v4l2_out {
+		compatible = "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	sound {
+		compatible = "fsl,imx6q-sabresd-wm8962",
+			   "fsl,imx-audio-wm8962";
+		model = "wm8962-audio";
+		ssi-controller = <&ssi2>;
+		audio-codec = <&codec>;
+		audio-routing =
+			"Headphone Jack", "HPOUTL",
+			"Headphone Jack", "HPOUTR",
+			"Ext Spk", "SPKOUTL",
+			"Ext Spk", "SPKOUTR",
+			"AMIC", "MICBIAS",
+			"IN3R", "AMIC";
+		amic-mono;
+		mux-int-port = <2>;
+		mux-ext-port = <3>;
+		hp-det-gpios = <&gpio4 19 1>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+			   "fsl,imx6sl-evk-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-out;
+	};
+
+	sii902x_reset: sii902x-reset {
+		compatible = "gpio-reset";
+		reset-gpios = <&gpio2 19 1>;
+		reset-delay-us = <100000>;
+		#reset-cells = <0>;
+	};
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_1>;
+	status = "okay";
+};
+
+&csi {
+	status = "disabled";
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio4 11 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_1>;
+	status = "okay";
+
+	flash: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,m25p32";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+};
+
+&epdc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_epdc_0>;
+	V3P3-supply = <&V3P3_reg>;
+	VCOM-supply = <&VCOM_reg>;
+	DISPLAY-supply = <&DISPLAY_reg>;
+	status = "okay";
+};
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+	pu-supply = <&pu_dummy>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&fec {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_fec_1>;
+	pinctrl-1 = <&pinctrl_fec_1_sleep>;
+	phy-mode = "rmii";
+	phy-reset-gpios = <&gpio4 21 0>; /* GPIO4_21 */
+	phy-reset-duration = <1>;
+	status = "okay";
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,ldo-bypass = <1>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpu {
+	pu-supply = <&pu_dummy>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_1>;
+	status = "okay";
+
+	elan@10 {
+		compatible = "elan,elan-touch";
+		reg = <0x10>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <10 2>;
+		gpio_elan_cs = <&gpio2 9 0>;
+		gpio_elan_rst = <&gpio4 4 0>;
+		gpio_intr = <&gpio2 10 0>;
+		status = "okay";
+	};
+
+	max17135@48 {
+		compatible = "maxim,max17135";
+		reg = <0x48>;
+		vneg_pwrup = <1>;
+		gvee_pwrup = <2>;
+		vpos_pwrup = <10>;
+		gvdd_pwrup = <12>;
+		gvdd_pwrdn = <1>;
+		vpos_pwrdn = <2>;
+		gvee_pwrdn = <8>;
+		vneg_pwrdn = <10>;
+		gpio_pmic_pwrgood = <&gpio2 13 0>;
+		gpio_pmic_vcom_ctrl = <&gpio2 3 0>;
+		gpio_pmic_wakeup = <&gpio2 14 0>;
+		gpio_pmic_v3p3 = <&gpio2 7 0>;
+		gpio_pmic_intr = <&gpio2 12 0>;
+
+		regulators {
+			DISPLAY_reg: DISPLAY {
+				regulator-name = "DISPLAY";
+			};
+
+			GVDD_reg: GVDD {
+				/* 20v */
+				regulator-name = "GVDD";
+			};
+
+			GVEE_reg: GVEE {
+				/* -22v */
+				regulator-name = "GVEE";
+			};
+
+			HVINN_reg: HVINN {
+				/* -22v */
+				regulator-name = "HVINN";
+			};
+
+			HVINP_reg: HVINP {
+				/* 20v */
+				regulator-name = "HVINP";
+			};
+
+			VCOM_reg: VCOM {
+				regulator-name = "VCOM";
+				/* 2's-compliment, -4325000 */
+				regulator-min-microvolt = <0xffbe0178>;
+				/* 2's-compliment, -500000 */
+				regulator-max-microvolt = <0xfff85ee0>;
+			};
+
+			VNEG_reg: VNEG {
+				/* -15v */
+				regulator-name = "VNEG";
+			};
+
+			VPOS_reg: VPOS {
+				/* 15v */
+				regulator-name = "VPOS";
+			};
+
+			V3P3_reg: V3P3 {
+				regulator-name = "V3P3";
+			};
+		};
+	};
+
+	mma8450@1c {
+		compatible = "fsl,mma8450";
+		reg = <0x1c>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_1>;
+	status = "okay";
+
+	codec: wm8962@1a {
+		compatible = "wlf,wm8962";
+		reg = <0x1a>;
+		clocks = <&clks IMX6SL_CLK_EXTERN_AUDIO>;
+		DCVDD-supply = <&vgen3_reg>;
+		DBVDD-supply = <&reg_aud3v>;
+		AVDD-supply = <&vgen3_reg>;
+		CPVDD-supply = <&vgen3_reg>;
+		MICVDD-supply = <&reg_aud3v>;
+		PLLVDD-supply = <&vgen3_reg>;
+		SPKVDD1-supply = <&reg_aud4v>;
+		SPKVDD2-supply = <&reg_aud4v>;
+		amic-mono;
+	};
+
+	sii902x@39 {
+		compatible = "SiI,sii902x";
+		interrupt-parent = <&gpio2>;
+		interrupts = <10 2>;
+		mode_str ="1280x720M@60";
+		bits-per-pixel = <32>;
+		resets = <&sii902x_reset>;
+		reg = <0x39>;
+	};
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_1>;
+	status = "disabled";
+
+	ov564x: ov564x@3c {
+		compatible = "ovti,ov564x";
+		reg = <0x3c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_0>;
+		clocks = <&clks IMX6SL_CLK_CSI>;
+		clock-names = "csi_mclk";
+		AVDD-supply = <&vgen6_reg>;  /* 2.8v */
+		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
+		pwn-gpios = <&gpio1 25 1>;
+		rst-gpios = <&gpio1 26 0>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_hog>;
+	pinctrl-1 = <&pinctrl_hog_sleep>;
+
+	hog {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX6SL_PAD_KEY_ROW7__GPIO4_IO07    0x17059
+				MX6SL_PAD_KEY_COL7__GPIO4_IO06    0x17059
+				MX6SL_PAD_SD2_DAT7__GPIO5_IO00    0x17059
+				MX6SL_PAD_SD2_DAT6__GPIO4_IO29    0x17059
+				MX6SL_PAD_REF_CLK_32K__GPIO3_IO22 0x17059
+				MX6SL_PAD_FEC_TX_CLK__GPIO4_IO21  0x80000000
+				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x110b0
+				MX6SL_PAD_EPDC_VCOM0__GPIO2_IO03  0x80000000
+				MX6SL_PAD_EPDC_PWRSTAT__GPIO2_IO13 0x80000000
+				MX6SL_PAD_EPDC_PWRCTRL0__GPIO2_IO07 0x80000000
+				MX6SL_PAD_EPDC_PWRWAKEUP__GPIO2_IO14 0x80000000
+				MX6SL_PAD_EPDC_PWRINT__GPIO2_IO12 0x80000000
+				MX6SL_PAD_EPDC_PWRCTRL3__GPIO2_IO10 0x170b0
+				MX6SL_PAD_EPDC_PWRCTRL2__GPIO2_IO09 0x80000000
+				MX6SL_PAD_KEY_COL6__GPIO4_IO04    0x110b0
+				MX6SL_PAD_ECSPI2_MISO__GPIO4_IO14 0x17000
+				MX6SL_PAD_ECSPI2_MOSI__GPIO4_IO13 0x17000
+				MX6SL_PAD_ECSPI2_SS0__GPIO4_IO15  0x17000
+				MX6SL_PAD_FEC_RX_ER__GPIO4_IO19   0x1b0b0
+				MX6SL_PAD_LCD_RESET__GPIO2_IO19 0x1b0b0
+				MX6SL_PAD_KEY_COL4__GPIO4_IO00	0x80000000
+				MX6SL_PAD_KEY_COL5__GPIO4_IO02	0x80000000
+			>;
+		};
+
+		pinctrl_hog_sleep: hoggrp_sleep {
+			fsl,pins = <
+				MX6SL_PAD_KEY_ROW5__GPIO4_IO03	  0x3080
+				MX6SL_PAD_KEY_COL6__GPIO4_IO04 	  0x3080
+				MX6SL_PAD_LCD_RESET__GPIO2_IO19   0x3080
+			>;
+		};
+	};
+};
+
+&kpp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_kpp_1>;
+	pinctrl-1 = <&pinctrl_kpp_1_sleep>;
+	linux,keymap = <
+			0x00000067      /* KEY_UP */
+			0x0001006c      /* KEY_DOWN */
+			0x0002001c      /* KEY_ENTER */
+			0x01000066      /* KEY_HOME */
+			0x0101006a      /* KEY_RIGHT */
+			0x01020069      /* KEY_LEFT */
+			0x02000072      /* KEY_VOLUMEDOWN */
+			0x02010073      /* KEY_VOLUMEUP */
+		>;
+        status = "okay";
+};
+
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat_0
+		     &pinctrl_lcdif_ctrl_0>;
+	lcd-supply = <&reg_lcd_3v3>;
+	display = <&display>;
+	status = "okay";
+
+	display: display {
+		bits-per-pixel = <16>;
+		bus-width = <24>;
+
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: timing0 {
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <23>;
+				vfront-porch = <10>;
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <0>;
+			};
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_pwm1_0>;
+	pinctrl-1 = <&pinctrl_pwm1_0_sleep>;
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_1>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg1_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg1_1>;
+	disable-over-current;
+	imx6-usb-charger-detection;
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usb_otg2_vbus>;
+	dr_mode = "host";
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1_1>;
+	pinctrl-1 = <&pinctrl_usdhc1_1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_1_200mhz>;
+	bus-width = <8>;
+	cd-gpios = <&gpio4 7 0>;
+	wp-gpios = <&gpio4 6 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2_1>;
+	pinctrl-1 = <&pinctrl_usdhc2_1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc2_1_200mhz>;
+	cd-gpios = <&gpio5 0 0>;
+	wp-gpios = <&gpio4 29 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3_1>;
+	pinctrl-1 = <&pinctrl_usdhc3_1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_1_200mhz>;
+	cd-gpios = <&gpio3 22 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
Index: arch/arm/boot/dts/imx6dl-sabresd-pf200.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-pf200.dts b/arch/arm/boot/dts/imx6dl-sabresd-pf200.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6dl-sabresd-pf200.dts	(revision 1734)
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-sabresd.dtsi"
+#include "imx6dl-sabresd-common.dtsi"
+
+/ {
+	model = "Freescale i.MX6 DualLite SABRE Smart Device Board(PFUZE200)";
+	compatible = "fsl,imx6dl-sabresd", "fsl,imx6dl";
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpc {
+	fsl,ldo-bypass = <0>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&vpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&i2c2 {
+	pmic: pfuze200@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
Index: arch/arm/boot/dts/imx6qdl-sabresd.dtsi
===================================================================
diff --git a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
--- a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi	(revision 513)
+++ b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi	(revision 1734)
@@ -405,105 +405,6 @@
 		mclk_source = <0>;
 	};
 
-	pmic: pfuze100@08 {
-		compatible = "fsl,pfuze100";
-		reg = <0x08>;
-
-		regulators {
-			sw1a_reg: sw1ab {
-				regulator-min-microvolt = <300000>;
-				regulator-max-microvolt = <1875000>;
-				regulator-boot-on;
-				regulator-always-on;
-				regulator-ramp-delay = <6250>;
-			};
-
-			sw1c_reg: sw1c {
-				regulator-min-microvolt = <300000>;
-				regulator-max-microvolt = <1875000>;
-				regulator-boot-on;
-				regulator-always-on;
-				regulator-ramp-delay = <6250>;
-			};
-
-			sw2_reg: sw2 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			sw3a_reg: sw3a {
-				regulator-min-microvolt = <400000>;
-				regulator-max-microvolt = <1975000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			sw3b_reg: sw3b {
-				regulator-min-microvolt = <400000>;
-				regulator-max-microvolt = <1975000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			sw4_reg: sw4 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <3300000>;
-			};
-
-			swbst_reg: swbst {
-				regulator-min-microvolt = <5000000>;
-				regulator-max-microvolt = <5150000>;
-			};
-
-			snvs_reg: vsnvs {
-				regulator-min-microvolt = <1000000>;
-				regulator-max-microvolt = <3000000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vref_reg: vrefddr {
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vgen1_reg: vgen1 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <1550000>;
-			};
-
-			vgen2_reg: vgen2 {
-				regulator-min-microvolt = <800000>;
-				regulator-max-microvolt = <1550000>;
-			};
-
-			vgen3_reg: vgen3 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-			};
-
-			vgen4_reg: vgen4 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-			};
-
-			vgen5_reg: vgen5 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-			};
-
-			vgen6_reg: vgen6 {
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-			};
-		};
-	};
-
         egalax_ts@04 {
                 compatible = "eeti,egalax_ts";
                 reg = <0x04>;
Index: arch/arm/boot/dts/imx6sl-evk-pf200.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6sl-evk-pf200.dts b/arch/arm/boot/dts/imx6sl-evk-pf200.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6sl-evk-pf200.dts	(revision 1734)
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6sl.dtsi"
+#include "imx6sl-evk-common.dtsi"
+
+/ {
+	model = "Freescale i.MX6 SoloLite EVK Board(PFUZE200)";
+	compatible = "fsl,imx6sl-evk", "fsl,imx6sl";
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+	pu-supply = <&reg_pu>; /* use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpc {
+	fsl,ldo-bypass = <0>; /* use ldo-bypass, u-boot will check it and configure */
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&gpu {
+	pu-supply = <&reg_pu>; /* ldo-bypass:use pu_dummy if VDDSOC share with VDDPU */
+};
+
+&i2c1 {
+	pmic: pfuze200@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
Index: arch/arm/boot/dts/imx6q-ubcds31.dts
===================================================================
diff --git a/arch/arm/boot/dts/imx6q-ubcds31.dts b/arch/arm/boot/dts/imx6q-ubcds31.dts
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/boot/dts/imx6q-ubcds31.dts	(revision 1734)
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6q.dtsi"
+#include "imx6qdl-advantech.dtsi"
+
+/ {
+	model = "Freescale i.MX6 Quad UBCDS31";
+	compatible = "fsl,imx6q-sabresd", "fsl,imx6q";
+
+	board {
+		compatible = "proc-board";
+		board-type = "UBC-DS31";
+		board-cpu = "DualQuad";
+	};
+};
+
+&audio_sgtl5000 {
+	audio-codec = <&codec>;
+};
+
+&i2c1 {
+
+	codec: sgtl5000@0a {
+		compatible = "fsl,sgtl5000";
+		reg = <0x0a>;
+		clocks = <&clks 201>;
+		VDDA-supply = <&reg_2p5v>;
+		VDDIO-supply = <&reg_3p3v>;
+		mclk = <16000000>;
+		mclk_source = <0>;
+	};
+
+	s35390a@30 {
+		compatible = "fsl,s35390a";
+		reg = <0x30>;
+	};
+
+};
+
+&i2c2 {
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+&i2c3 {
+
+	ch7055@76 {
+		compatible = "fsl,ch7055";
+		reg = <0x76>;
+	};
+
+	mxc_vga_i2c@50 {
+		compatible = "fsl,mxc_vga_i2c";
+		reg = <0x50>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1 &pinctrl_hog_2>;
+
+	hog {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20 		0x80000000	/* 3G_DET# */
+				MX6QDL_PAD_EIM_D24__GPIO3_IO24 		0x80000000	/* ALL_SYS_PG */
+				MX6QDL_PAD_EIM_D25__GPIO3_IO25 		0x80000000	/* PLTRST# */
+			>;
+		};
+	};
+
+	pcie {
+		pinctrl_pcie_1: pciegrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19		0x80000000	/* PCIE_DIS_B */
+			>;
+		};
+	};
+
+	spi1 {
+		pinctrl_ecspi1_cs_0: ecspi1_cs_grp-0 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__GPIO2_IO30		0x80000000	/* ECSPI1_CS0 */
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_3: uart2grp-3 { /* DCE mode */
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D28__UART2_CTS_B		0x1b0b1
+				MX6QDL_PAD_EIM_D29__UART2_RTS_B		0x1b0b1
+			>;
+		};
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie_1>;
+	disable-gpio = <&gpio3 19 0>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_3>;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_2>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2_2>;
+	cd-gpios = <&gpio2 2 0>;
+	wp-gpios = <&gpio2 3 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4_1>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
Index: arch/arm/mach-imx/proc-board.c
===================================================================
diff --git a/arch/arm/mach-imx/proc-board.c b/arch/arm/mach-imx/proc-board.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/mach-imx/proc-board.c	(revision 1734)
@@ -0,0 +1,85 @@
+#ifdef CONFIG_ARCH_ADVANTECH
+
+#include <linux/of_platform.h>
+#include <linux/module.h>
+
+char board_type[12];
+char board_cpu[20];
+
+struct proc_board_data {
+	const char *board_type;
+	const char *advboot_version;
+	const char *uboot_version;
+	const char *board_cpu;
+};
+
+/* Code to create from OpenFirmware platform devices */
+static int proc_board_probe_dt(struct proc_board_data *board , struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct proc_board_data board_info={};
+
+	/* no device tree device */
+	if (!np)
+	{
+		printk("\n [proc_board_probe_dt] no device tree device... \n");
+		return -1;
+	}
+
+	board_info.board_type = of_get_property(np, "board-type", NULL);
+	board_info.board_cpu = of_get_property(np, "board-cpu", NULL);
+	board_info.advboot_version = of_get_property(np, "advboot_version", NULL);
+	board_info.uboot_version = of_get_property(np, "uboot_version", NULL);
+	board = &board_info;
+	strcpy(board_type, board_info.board_type);
+	strcpy(board_cpu, board_info.board_cpu);
+
+	return 0;
+}
+
+static const struct of_device_id of_proc_board_match[] = {
+	{ .compatible = "proc-board", },
+	{},
+};
+
+static int proc_board_probe(struct platform_device *pdev)
+{
+	struct proc_board_data *board;
+	int ret = 0;
+
+	board = devm_kzalloc(&pdev->dev, sizeof(struct proc_board_data), GFP_KERNEL);
+	
+	if (!board) {
+		printk("\n [proc_board_probe] Allocate board error... \n");
+		return -ENOMEM;
+	}
+
+	ret = proc_board_probe_dt(board, pdev);
+	
+	if (ret < 0) { 
+		printk("\n [proc_board_probe] proc_board_probe_dt() Fail.\n");
+		return ret;
+	}	
+
+	platform_set_drvdata(pdev, board);
+	
+	return 0;
+}
+
+static struct platform_driver proc_board_driver = {
+	.probe		= proc_board_probe,
+	.driver		= {
+		.name	= "proc-board",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(of_proc_board_match),
+	},
+};
+
+module_platform_driver(proc_board_driver);
+
+MODULE_AUTHOR("Advantech");
+MODULE_DESCRIPTION("PROC BOARD driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:proc-board");
+
+#endif
Index: arch/arm/mach-imx/Kconfig
===================================================================
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
--- a/arch/arm/mach-imx/Kconfig	(revision 513)
+++ b/arch/arm/mach-imx/Kconfig	(revision 1734)
@@ -18,6 +18,9 @@
 	help
 	  Support for Freescale MXC/iMX-based family of processors
 
+config ARCH_ADVANTECH
+	bool "Support Advantech board"
+
 menu "Freescale i.MX support"
 	depends on ARCH_MXC
 
@@ -819,8 +822,6 @@
 	select ARCH_SUPPORTS_MSI
 	select PINCTRL
 	select PINCTRL_IMX6Q
-	select PL310_ERRATA_588369 if CACHE_PL310
-	select PL310_ERRATA_727915 if CACHE_PL310
 	select PL310_ERRATA_769419 if CACHE_PL310
 	select PM_OPP if PM
 	select ZONE_DMA
@@ -841,8 +842,6 @@
 	select HAVE_IMX_RNG
 	select PINCTRL
 	select PINCTRL_IMX6SL
-	select PL310_ERRATA_588369 if CACHE_PL310
-	select PL310_ERRATA_727915 if CACHE_PL310
 	select PL310_ERRATA_769419 if CACHE_PL310
 
 	help
@@ -856,8 +855,6 @@
 	select PINCTRL
 	select PINCTRL_VF610
 	select VF_PIT_TIMER
-	select PL310_ERRATA_588369 if CACHE_PL310
-	select PL310_ERRATA_727915 if CACHE_PL310
 	select PL310_ERRATA_769419 if CACHE_PL310
 
 	help
Index: arch/arm/mach-imx/mach-imx6q.c
===================================================================
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
--- a/arch/arm/mach-imx/mach-imx6q.c	(revision 513)
+++ b/arch/arm/mach-imx/mach-imx6q.c	(revision 1734)
@@ -176,6 +176,29 @@
 
 #define PHY_ID_AR8031	0x004dd074
 
+#ifdef CONFIG_ARCH_ADVANTECH
+extern char board_type[12];
+
+static int rtl8211e_phy_fixup(struct phy_device *dev)
+{
+	/*PHY LED OK*/
+	phy_write(dev, 0x1f, 0x0007);
+	phy_write(dev, 0x1e, 0x002c);
+	phy_write(dev, 0x1c, 0x0742);
+	phy_write(dev, 0x1a, 0x0040);
+	phy_write(dev, 0x1f, 0x0000);
+
+	phy_write(dev, 0x1f, 0x0005);
+	phy_write(dev, 0x05, 0x8b82);
+	phy_write(dev, 0x06, 0x052b);
+	phy_write(dev, 0x1f, 0x0000);
+	return 0;
+}
+
+#define PHY_ID_REALTEK	0x001cc915
+#define REALTEK_PHY_ID_MASK 0x001fffff
+#endif
+
 static void __init imx6q_enet_phy_init(void)
 {
 	if (IS_BUILTIN(CONFIG_PHYLIB)) {
@@ -183,8 +206,11 @@
 				ksz9021rn_phy_fixup);
 		phy_register_fixup_for_uid(PHY_ID_KSZ9031, MICREL_PHY_ID_MASK,
 				ksz9031rn_phy_fixup);
-		phy_register_fixup_for_uid(PHY_ID_AR8031, 0xffffffff,
-				ar8031_phy_fixup);
+
+		if(!strcmp(board_type, "UBC-220"))
+			phy_register_fixup_for_uid(PHY_ID_REALTEK, 0xffffffff, rtl8211e_phy_fixup);
+		else
+			phy_register_fixup_for_uid(PHY_ID_AR8031, 0xffffffff, ar8031_phy_fixup);
 	}
 }
 
Index: arch/arm/mach-imx/platsmp.c
===================================================================
diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
--- a/arch/arm/mach-imx/platsmp.c	(revision 513)
+++ b/arch/arm/mach-imx/platsmp.c	(revision 1734)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011-2014 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -77,6 +77,8 @@
 void imx_smp_prepare(void)
 {
 	scu_enable(scu_base);
+	/* Need to enable SCU standby for entering WAIT mode */
+	imx_scu_standby_enable();
 }
 
 static void __init imx_smp_prepare_cpus(unsigned int max_cpus)
Index: arch/arm/mach-imx/Makefile
===================================================================
diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
--- a/arch/arm/mach-imx/Makefile	(revision 513)
+++ b/arch/arm/mach-imx/Makefile	(revision 1734)
@@ -106,7 +106,7 @@
 obj-$(CONFIG_PM) += pm-imx6.o headsmp.o suspend-imx6.o
 
 ifeq ($(CONFIG_ARM_IMX6_CPUFREQ),y)
-obj-y += busfreq-imx6.o
+obj-y += busfreq-imx6.o proc-board.o
 obj-$(CONFIG_SOC_IMX6Q) += ddr3_freq_imx6.o busfreq_ddr3.o
 obj-$(CONFIG_SOC_IMX6SL) += lpddr2_freq_imx6.o busfreq_lpddr2.o imx6sl_wfi.o
 endif
Index: arch/arm/mach-imx/pm-imx6.c
===================================================================
diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
--- a/arch/arm/mach-imx/pm-imx6.c	(revision 513)
+++ b/arch/arm/mach-imx/pm-imx6.c	(revision 1734)
@@ -73,6 +73,8 @@
 	unsigned long iram_pbase, unsigned int cpu_type);
 static unsigned int cpu_type;
 static void __iomem *ccm_base;
+static unsigned long dcr;
+static unsigned long pcr;
 
 unsigned long save_ttbr1(void)
 {
@@ -111,6 +113,34 @@
 	}
 }
 
+static void imx6_save_cpu_arch_regs(void)
+{
+	/* Save the Diagnostic Control Register. */
+	asm volatile(
+		"mrc p15, 0, %0, c15, c0, 1\n"
+	: "=r" (dcr)
+	);
+	/* Save the Power Control Register. */
+	asm volatile(
+		"mrc p15, 0, %0, c15, c0, 0\n"
+	: "=r" (pcr)
+	);
+}
+
+static void imx6_restore_cpu_arch_regs(void)
+{
+	/* Restore the diagnostic Control Register. */
+	asm volatile(
+		"mcr p15, 0, %0, c15, c0, 1\n"
+	: : "r" (dcr)
+	);
+	/* Restore the Power Control Register. */
+	asm volatile(
+		"mcr p15, 0, %0, c15, c0, 0\n"
+	: : "r" (pcr)
+	);
+}
+
 static void imx6_enable_rbc(bool enable)
 {
 	u32 val;
@@ -290,8 +320,14 @@
 		imx_gpc_pre_suspend(true);
 		imx_anatop_pre_suspend();
 		imx_set_cpu_jump(0, v7_cpu_resume);
+
+		imx6_save_cpu_arch_regs();
+
 		/* Zzz ... */
 		cpu_suspend(0, imx6_suspend_finish);
+
+		imx6_restore_cpu_arch_regs();
+
 		if (!cpu_is_imx6sl())
 			imx_smp_prepare();
 		imx_anatop_post_resume();
Index: arch/arm/mach-imx/cpuidle-imx6q.c
===================================================================
diff --git a/arch/arm/mach-imx/cpuidle-imx6q.c b/arch/arm/mach-imx/cpuidle-imx6q.c
--- a/arch/arm/mach-imx/cpuidle-imx6q.c	(revision 513)
+++ b/arch/arm/mach-imx/cpuidle-imx6q.c	(revision 1734)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -65,9 +65,6 @@
 
 int __init imx6q_cpuidle_init(void)
 {
-	/* Need to enable SCU standby for entering WAIT modes */
-	imx_scu_standby_enable();
-
 	/* Set cache lpm bit for reliable WAIT mode support */
 	imx6_set_cache_lpm_in_wait(true);
 
Index: arch/arm/mach-imx/gpc.c
===================================================================
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
--- a/arch/arm/mach-imx/gpc.c	(revision 513)
+++ b/arch/arm/mach-imx/gpc.c	(revision 1734)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2013 Freescale Semiconductor, Inc.
+ * Copyright 2011-2014 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -90,7 +90,8 @@
 
 static void imx_gpc_dispmix_on(void)
 {
-	if (cpu_is_imx6sl()) {
+	if (cpu_is_imx6sl() &&
+		imx_get_soc_revision() >= IMX_CHIP_REVISION_1_2) {
 		imx_disp_clk(true);
 
 		writel_relaxed(0x0, gpc_base + GPC_PGC_DISP_PGCR_OFFSET);
@@ -105,7 +106,8 @@
 
 static void imx_gpc_dispmix_off(void)
 {
-	if (cpu_is_imx6sl()) {
+	if (cpu_is_imx6sl() &&
+		imx_get_soc_revision() >= IMX_CHIP_REVISION_1_2) {
 		imx_disp_clk(true);
 
 		writel_relaxed(0xFFFFFFFF,
Index: arch/arm/mach-imx/imx6sl_wfi.S
===================================================================
diff --git a/arch/arm/mach-imx/imx6sl_wfi.S b/arch/arm/mach-imx/imx6sl_wfi.S
--- a/arch/arm/mach-imx/imx6sl_wfi.S	(revision 513)
+++ b/arch/arm/mach-imx/imx6sl_wfi.S	(revision 1734)
@@ -425,6 +425,17 @@
 	bic	r6, r6, #0x1
 	str	r6, [r3, #0x130]
 
+	/*
+	 * Cannot disable regular bandgap
+	 * in LDO-enabled mode. The bandgap
+	 * is required for ARM-LDO to regulate
+	 * the voltage.
+	 */
+	ldr	r6, [r3, #0x140]
+	and	r6, r6, #0x1f
+	cmp	r6, #0x1f
+	bne	leave_bandgap_enabled
+
 	/* Enable low power bandgap */
 	ldr	r6, [r3, #0x260]
 	orr	r6, r6, #0x20
@@ -453,6 +464,7 @@
 	orr	r6, r6, #0x1
 	str	r6, [r3, #0x150]
 
+leave_bandgap_enabled:
 leave_2p5_on:
 	b	do_wfi
 
@@ -506,6 +518,16 @@
 	cmp	r12, #1
 	beq	ldo2p5_not_disabled
 
+	/*
+	 * Regular bandgap will not be disabled
+	 * in LDO-enabled mode as it is required
+	 * for ARM-LDO to regulate the voltage.
+	 */
+	ldr	r6, [r3, #0x140]
+	and	r6, r6, #0x1f
+	cmp	r6, #0x1f
+	bne	skip_bandgap_restore
+
 	/* Power up the regular bandgap. */
 	ldr	r6, [r3, #0x150]
 	bic	r6, r6, #0x1
@@ -524,6 +546,7 @@
 	bic	r6, r6, #0x20
 	str	r6, [r3, #0x260]
 
+skip_bandgap_restore:
 	/* Enable main 2p5. */
 	ldr	r6, [r3, #0x130]
 	orr	r6, r6, #0x1
Index: arch/arm/configs/imx_v7_adv_mfg_defconfig
===================================================================
diff --git a/arch/arm/configs/imx_v7_adv_mfg_defconfig b/arch/arm/configs/imx_v7_adv_mfg_defconfig
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/configs/imx_v7_adv_mfg_defconfig	(revision 1734)
@@ -0,0 +1,3262 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.10.17 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_FIQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_SPARSE_IRQ=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_UIDGID_CONVERTED=y
+# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_HOTPLUG=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_MULTI_CPU_AUTO is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_BCM is not set
+CONFIG_GPIO_PCA953X=y
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_ARCH_HIGHBANK is not set
+CONFIG_ARCH_MXC=y
+CONFIG_ARCH_ADVANTECH=y
+
+#
+# Freescale i.MX support
+#
+# CONFIG_MXC_IRQ_PRIOR is not set
+CONFIG_MXC_TZIC=y
+CONFIG_MXC_DEBUG_BOARD=y
+CONFIG_HAVE_IMX_RNG=y
+CONFIG_HAVE_IMX_ANATOP=y
+CONFIG_HAVE_IMX_GPC=y
+CONFIG_HAVE_IMX_MMDC=y
+CONFIG_HAVE_IMX_SRC=y
+CONFIG_ARCH_MXC_IOMUX_V3=y
+CONFIG_SOC_IMX5=y
+CONFIG_SOC_IMX51=y
+
+#
+# i.MX51 machines:
+#
+CONFIG_MACH_IMX51_DT=y
+# CONFIG_MACH_MX51_BABBAGE is not set
+CONFIG_MACH_EUKREA_CPUIMX51SD=y
+CONFIG_MACH_EUKREA_MBIMXSD51_BASEBOARD=y
+
+#
+# Device tree only
+#
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_VF610=y
+CONFIG_IMX_HAVE_PLATFORM_FEC=y
+CONFIG_IMX_HAVE_PLATFORM_FSL_USB2_UDC=y
+CONFIG_IMX_HAVE_PLATFORM_GPIO_KEYS=y
+CONFIG_IMX_HAVE_PLATFORM_IMX2_WDT=y
+CONFIG_IMX_HAVE_PLATFORM_IMX_I2C=y
+CONFIG_IMX_HAVE_PLATFORM_IMX_SSI=y
+CONFIG_IMX_HAVE_PLATFORM_IMX_UART=y
+CONFIG_IMX_HAVE_PLATFORM_MXC_EHCI=y
+CONFIG_IMX_HAVE_PLATFORM_MXC_NAND=y
+CONFIG_IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX=y
+CONFIG_IMX_HAVE_PLATFORM_SPI_IMX=y
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+CONFIG_ARM_ERRATA_794072=y
+CONFIG_ARM_ERRATA_761320=y
+# CONFIG_PL310_ERRATA_753970 is not set
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_PL310_ERRATA_769419=y
+CONFIG_ARM_ERRATA_775420=y
+# CONFIG_ARM_ERRATA_798181 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_SYSCALL is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+CONFIG_HAVE_ARM_TWD=y
+# CONFIG_MCPM is not set
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+# CONFIG_GENERIC_CPUFREQ_CPU0 is not set
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5440_CPUFREQ is not set
+CONFIG_ARM_IMX6_CPUFREQ=y
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_PM_SLEEP_DEBUG=y
+CONFIG_APM_EMULATION=y
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGMAP_IRQ=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+
+#
+# Bus devices
+#
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MTD_SST25L=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NAND=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_MXC=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+# CONFIG_PROC_DEVICETREE is not set
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_I2C=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_SRAM=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_SATA_HIGHBANK is not set
+# CONFIG_SATA_MV is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ARASAN_CF is not set
+CONFIG_PATA_IMX=y
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_PLATFORM is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+CONFIG_NET_CADENCE=y
+# CONFIG_ARM_AT91_ETHER is not set
+# CONFIG_MACB is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_FEC=y
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_SMSC911X_ARCH_HOOKS is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+CONFIG_ATH_CARDS=y
+# CONFIG_ATH_DEBUG is not set
+# CONFIG_ATH9K is not set
+# CONFIG_ATH9K_HTC is not set
+# CONFIG_CARL9170 is not set
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_SDIO=m
+# CONFIG_ATH6KL_USB is not set
+# CONFIG_ATH6KL_DEBUG is not set
+# CONFIG_AR5523 is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+# CONFIG_RT2X00 is not set
+# CONFIG_RTLWIFI is not set
+# CONFIG_WL_TI is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+CONFIG_INPUT_MATRIXKMAP=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_INPUT_APMPOWER=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+CONFIG_KEYBOARD_IMX=y
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DA9052 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+CONFIG_TOUCHSCREEN_EGALAX=y
+# CONFIG_TOUCHSCREEN_EGALAX_SINGLE_TOUCH is not set
+CONFIG_TOUCHSCREEN_ELAN=y
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+CONFIG_TOUCHSCREEN_MAX11801=y
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+CONFIG_TOUCHSCREEN_MC13783=y
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MC13783_PWRBUTTON is not set
+CONFIG_INPUT_MMA8450=y
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_DA9052_ONKEY is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+CONFIG_INPUT_ISL29023=y
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=m
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+# CONFIG_TTY_PRINTK is not set
+CONFIG_FSL_OTP=y
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_IMX_RNG is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_MXS_VIIM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_IMX=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_IMX=y
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+CONFIG_PINCTRL_IMX=y
+CONFIG_PINCTRL_IMX51=y
+CONFIG_PINCTRL_IMX53=y
+CONFIG_PINCTRL_IMX6Q=y
+CONFIG_PINCTRL_IMX6SL=y
+CONFIG_PINCTRL_VF610=y
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+# CONFIG_GPIO_DA9052 is not set
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
+CONFIG_GPIO_MXC=y
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_TS5500 is not set
+# CONFIG_GPIO_GRGPIO is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X_IRQ is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_APM_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_EC is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_DA9052 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+CONFIG_SABRESD_MAX8903=y
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_IMX6_USB_CHARGER is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DA9052_ADC is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+CONFIG_SENSORS_MAX17135=y
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_MC13783_ADC is not set
+CONFIG_SENSORS_MAG3110=y
+CONFIG_MXC_MMA8451=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+CONFIG_CPU_THERMAL=y
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_DA9052_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MPCORE_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_IMX2_WDT=y
+# CONFIG_ADVANTECH_RISC_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+CONFIG_PMIC_DA9052=y
+# CONFIG_MFD_DA9052_SPI is not set
+CONFIG_MFD_DA9052_I2C=y
+# CONFIG_MFD_DA9055 is not set
+CONFIG_MFD_MXC_HDMI=y
+CONFIG_MFD_MC13783=y
+CONFIG_MFD_MC13XXX=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+CONFIG_MFD_MAX17135=y
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+CONFIG_MFD_SI476X_CORE=y
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+CONFIG_REGULATOR_DA9052=y
+# CONFIG_REGULATOR_FAN53555 is not set
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_MC13XXX_CORE=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+CONFIG_REGULATOR_MAX17135=y
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+CONFIG_REGULATOR_PFUZE100=y
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+CONFIG_MEDIA_RADIO_SUPPORT=y
+# CONFIG_MEDIA_RC_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=m
+CONFIG_VIDEO_V4L2_INT_DEVICE=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_USB_SN9C102 is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_TIMBERDALE is not set
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=m
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_IPU_CAMERA=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=m
+CONFIG_MXC_CAMERA_OV5640=m
+CONFIG_MXC_CAMERA_OV5642=m
+CONFIG_MXC_CAMERA_OV5640_MIPI=m
+CONFIG_MXC_TVIN_ADV7180=m
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=m
+CONFIG_MXC_IPU_PRP_ENC=m
+CONFIG_MXC_IPU_CSI_ENC=m
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+CONFIG_SOC_CAMERA=y
+# CONFIG_SOC_CAMERA_PLATFORM is not set
+CONFIG_MX3_VIDEO=y
+CONFIG_VIDEO_MX3=y
+# CONFIG_VIDEO_SH_MOBILE_CSI2 is not set
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_SI470X is not set
+CONFIG_RADIO_SI476X=y
+# CONFIG_USB_MR800 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SHARK is not set
+# CONFIG_RADIO_SHARK2 is not set
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_KEENE is not set
+# CONFIG_USB_MA901 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+CONFIG_MEDIA_ATTACH=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# soc_camera sensor drivers
+#
+# CONFIG_SOC_CAMERA_IMX074 is not set
+# CONFIG_SOC_CAMERA_MT9M001 is not set
+# CONFIG_SOC_CAMERA_MT9M111 is not set
+# CONFIG_SOC_CAMERA_MT9T031 is not set
+# CONFIG_SOC_CAMERA_MT9T112 is not set
+# CONFIG_SOC_CAMERA_MT9V022 is not set
+CONFIG_SOC_CAMERA_OV2640=y
+# CONFIG_SOC_CAMERA_OV5642 is not set
+# CONFIG_SOC_CAMERA_OV6650 is not set
+# CONFIG_SOC_CAMERA_OV772X is not set
+# CONFIG_SOC_CAMERA_OV9640 is not set
+# CONFIG_SOC_CAMERA_OV9740 is not set
+# CONFIG_SOC_CAMERA_RJ54N1 is not set
+# CONFIG_SOC_CAMERA_TW9910 is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+CONFIG_DRM=y
+CONFIG_DRM_VIVANTE=y
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_TEGRA_HOST1X is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+CONFIG_FB_MX3=y
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+CONFIG_FB_MXS=y
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+# CONFIG_BACKLIGHT_DA9052 is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_SYNC_PANEL_EDID=y
+CONFIG_FB_MXC_LDB=y
+CONFIG_FB_MXC_MIPI_DSI=y
+CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXC_EDID=y
+CONFIG_FB_MXC_EINK_PANEL=y
+# CONFIG_FB_MXC_EINK_AUTO_UPDATE_MODE is not set
+CONFIG_FB_MXS_SII902X=y
+# CONFIG_HANNSTAR_CABC is not set
+# CONFIG_FB_MXC_CH7055 is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_FB_SSD1307 is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_DMAENGINE_PCM=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_SOC_FSL_SSI=y
+CONFIG_SND_SOC_FSL_ASRC=y
+CONFIG_SND_SOC_FSL_ESAI=y
+CONFIG_SND_SOC_FSL_SPDIF=y
+CONFIG_SND_SOC_FSL_HDMI=y
+CONFIG_SND_SOC_FSL_UTILS=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_IMX_SSI=y
+CONFIG_SND_SOC_IMX_PCM_FIQ=y
+CONFIG_SND_SOC_IMX_PCM_DMA=y
+CONFIG_SND_SOC_IMX_HDMI_DMA=y
+CONFIG_SND_SOC_IMX_AUDMUX=y
+CONFIG_SND_SOC_EUKREA_TLV320=y
+CONFIG_SND_SOC_IMX_CS42888=y
+CONFIG_SND_SOC_IMX_WM8962=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_MC13783=y
+CONFIG_SND_SOC_IMX_HDMI=y
+CONFIG_SND_SOC_IMX_SI476X=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_CS42888=y
+CONFIG_SND_SOC_OMAP_HDMI_CODEC=y
+CONFIG_SND_SOC_SGTL5000=y
+CONFIG_SND_SOC_SI476X=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SOC_TLV320AIC23=y
+CONFIG_SND_SOC_WM8962=y
+CONFIG_SND_SOC_MC13783=y
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_MXC is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_IMX21_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+# CONFIG_USB_CHIPIDEA_DEBUG is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+CONFIG_USB_PHY=y
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_OMAP_CONTROL_USB is not set
+# CONFIG_OMAP_USB3 is not set
+# CONFIG_SAMSUNG_USBPHY is not set
+# CONFIG_SAMSUNG_USB2PHY is not set
+# CONFIG_SAMSUNG_USB3PHY is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+CONFIG_USB_MXS_PHY=y
+# CONFIG_USB_RCAR_PHY is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FSL_USB2 is not set
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=y
+CONFIG_FSL_UTP=y
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+
+#
+# MXC support drivers
+#
+CONFIG_MXC_IPU=y
+
+#
+# MXC Vivante GPU support
+#
+CONFIG_MXC_GPU_VIV=y
+CONFIG_MXC_IPU_V3=y
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+CONFIG_MXC_ASRC=y
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+CONFIG_MXC_VPU=y
+# CONFIG_MXC_VPU_DEBUG is not set
+# CONFIG_MX6_VPU_352M is not set
+
+#
+# MXC HDMI CEC (Consumer Electronics Control) support
+#
+# CONFIG_MXC_HDMI_CEC is not set
+
+#
+# MXC MIPI Support
+#
+CONFIG_MXC_MIPI_CSI2=y
+
+#
+# MXC Media Local Bus Driver
+#
+# CONFIG_MXC_MLB150 is not set
+CONFIG_LEDS_GPIO_REGISTER=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DA9052 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_MC13783 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DA9052 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_IMXDI is not set
+CONFIG_RTC_DRV_MC13XXX=y
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_SNVS=y
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_DW_DMAC is not set
+CONFIG_MX3_IPU=y
+CONFIG_MX3_IPU_IRQS=4
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_CLIENT_DEVICE=y
+# CONFIG_TIMB_DMA is not set
+CONFIG_IMX_SDMA=y
+# CONFIG_IMX_DMA is not set
+CONFIG_MXS_DMA=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CSR_WIFI is not set
+# CONFIG_CED1401 is not set
+# CONFIG_DRM_IMX is not set
+# CONFIG_DGRP is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_DEBUG=y
+# CONFIG_COMMON_CLK_SI5351 is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_VF_PIT_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+# CONFIG_IPACK_BUS is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_GPIO=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=m
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_IMX_UART_PORT=1
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+CONFIG_SECURITYFS=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE=9
+# CONFIG_CRYPTO_DEV_FSL_CAAM_INTC is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API=y
+# CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE=7
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_STMP_DEVICE=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=y
+# CONFIG_VIRTUALIZATION is not set
Index: arch/arm/configs/imx_v7_adv_defconfig
===================================================================
diff --git a/arch/arm/configs/imx_v7_adv_defconfig b/arch/arm/configs/imx_v7_adv_defconfig
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/configs/imx_v7_adv_defconfig	(revision 1734)
@@ -0,0 +1,3376 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.10.17 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_SPARSE_IRQ=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_UIDGID_CONVERTED=y
+# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_HOTPLUG=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_MULTI_CPU_AUTO is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_ARCH_HIGHBANK is not set
+CONFIG_ARCH_MXC=y
+CONFIG_ARCH_ADVANTECH=y
+
+#
+# Freescale i.MX support
+#
+# CONFIG_MXC_IRQ_PRIOR is not set
+CONFIG_MXC_TZIC=y
+CONFIG_MXC_DEBUG_BOARD=y
+CONFIG_HAVE_IMX_RNG=y
+CONFIG_HAVE_IMX_ANATOP=y
+CONFIG_HAVE_IMX_GPC=y
+CONFIG_HAVE_IMX_MMDC=y
+CONFIG_HAVE_IMX_SRC=y
+CONFIG_ARCH_MXC_IOMUX_V3=y
+CONFIG_SOC_IMX5=y
+CONFIG_SOC_IMX51=y
+
+#
+# i.MX51 machines:
+#
+CONFIG_MACH_IMX51_DT=y
+# CONFIG_MACH_MX51_BABBAGE is not set
+CONFIG_MACH_EUKREA_CPUIMX51SD=y
+CONFIG_MACH_EUKREA_MBIMXSD51_BASEBOARD=y
+
+#
+# Device tree only
+#
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_VF610=y
+CONFIG_IMX_HAVE_PLATFORM_FEC=y
+CONFIG_IMX_HAVE_PLATFORM_FSL_USB2_UDC=y
+CONFIG_IMX_HAVE_PLATFORM_GPIO_KEYS=y
+CONFIG_IMX_HAVE_PLATFORM_IMX2_WDT=y
+CONFIG_IMX_HAVE_PLATFORM_IMX_I2C=y
+CONFIG_IMX_HAVE_PLATFORM_IMX_SSI=y
+CONFIG_IMX_HAVE_PLATFORM_IMX_UART=y
+CONFIG_IMX_HAVE_PLATFORM_MXC_EHCI=y
+CONFIG_IMX_HAVE_PLATFORM_MXC_NAND=y
+CONFIG_IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX=y
+CONFIG_IMX_HAVE_PLATFORM_SPI_IMX=y
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+CONFIG_PL310_ERRATA_588369=y
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_ARM_ERRATA_794072=y
+CONFIG_ARM_ERRATA_761320=y
+# CONFIG_PL310_ERRATA_753970 is not set
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_PL310_ERRATA_769419=y
+CONFIG_ARM_ERRATA_775420=y
+# CONFIG_ARM_ERRATA_798181 is not set
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+
+#
+# PCI host controller drivers
+#
+CONFIG_PCIE_DW=y
+CONFIG_PCI_IMX6=y
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+CONFIG_HAVE_ARM_TWD=y
+# CONFIG_MCPM is not set
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+# CONFIG_GENERIC_CPUFREQ_CPU0 is not set
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5440_CPUFREQ is not set
+CONFIG_ARM_IMX6_CPUFREQ=y
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_PM_SLEEP_DEBUG=y
+CONFIG_APM_EMULATION=y
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+# CONFIG_CAN_LEDS is not set
+# CONFIG_CAN_AT91 is not set
+# CONFIG_CAN_MCP251X is not set
+CONFIG_HAVE_CAN_FLEXCAN=y
+CONFIG_CAN_FLEXCAN=y
+# CONFIG_CAN_GRCAN is not set
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_SOFTING is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=y
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+CONFIG_BT_HCIVHCI=y
+# CONFIG_BT_MRVL is not set
+CONFIG_BT_ATH3K=m
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+
+#
+# Bus devices
+#
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MTD_SST25L=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NAND=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_MXC=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+# CONFIG_PROC_DEVICETREE is not set
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_I2C=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_OF_MTD=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_SRAM=y
+CONFIG_ADVANTECH_DUSTWSN=m
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_HAVE_IDE=y
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_SATA_HIGHBANK is not set
+# CONFIG_SATA_MV is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ARASAN_CF is not set
+CONFIG_PATA_IMX=y
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_PLATFORM is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_NET_CADENCE=y
+# CONFIG_ARM_AT91_ETHER is not set
+# CONFIG_MACB is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_NET_VENDOR_DLINK=y
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_NET_VENDOR_EXAR=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_FEC=y
+CONFIG_NET_VENDOR_HP=y
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_NET_VENDOR_NATSEMI is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_ETHOC is not set
+CONFIG_NET_PACKET_ENGINE=y
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_SMSC911X_ARCH_HOOKS is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_NET_VENDOR_TI=y
+CONFIG_NET_VENDOR_VIA=y
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+CONFIG_REALTEK_PHY=y
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+CONFIG_ATH_COMMON=m
+CONFIG_ATH_CARDS=m
+# CONFIG_ATH_DEBUG is not set
+CONFIG_ATH9K_HW=m
+CONFIG_ATH9K_COMMON=m
+CONFIG_ATH9K=m
+CONFIG_ATH9K_PCI=y
+CONFIG_ATH9K_LEGACY_RATE_CONTROL=y
+# CONFIG_ATH9K_HTC is not set
+# CONFIG_CARL9170 is not set
+# CONFIG_AR5523 is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_RT2X00=m
+# CONFIG_RT2500USB is not set
+# CONFIG_RT73USB is not set
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_RT55XX=y
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RT2800_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+CONFIG_RTLWIFI=m
+CONFIG_RTLWIFI_DEBUG=y
+CONFIG_RTL8188EE=m
+# CONFIG_WL_TI is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+CONFIG_INPUT_MATRIXKMAP=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_INPUT_APMPOWER=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+CONFIG_KEYBOARD_MATRIX=y
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+CONFIG_KEYBOARD_IMX=y
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=m
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+CONFIG_SERIAL_XR275X=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+# CONFIG_TTY_PRINTK is not set
+CONFIG_FSL_OTP=y
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_IMX_RNG is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_MXS_VIIM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+CONFIG_I2C_MUX_PCA954x=y
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_IMX=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_IMX=y
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+CONFIG_PINCTRL_IMX=y
+CONFIG_PINCTRL_IMX51=y
+CONFIG_PINCTRL_IMX53=y
+CONFIG_PINCTRL_IMX6Q=y
+CONFIG_PINCTRL_IMX6SL=y
+CONFIG_PINCTRL_VF610=y
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
+CONFIG_GPIO_MXC=y
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_TS5500 is not set
+# CONFIG_GPIO_GRGPIO is not set
+CONFIG_GPIO_ARCH_ADVANTECH=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+CONFIG_BATTERY_EC=y
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_IMX6_USB_CHARGER is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX17135 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_MC13783_ADC is not set
+# CONFIG_SENSORS_MAG3110 is not set
+# CONFIG_MXC_MMA8451 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+CONFIG_CPU_THERMAL=y
+# CONFIG_THERMAL_EMULATION is not set
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MPCORE_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_IMX2_WDT=y
+CONFIG_ADVANTECH_RISC_WDT=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+CONFIG_MFD_MXC_HDMI=y
+CONFIG_MFD_MC13783=y
+CONFIG_MFD_MC13XXX=y
+CONFIG_MFD_MC13XXX_SPI=y
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX17135 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_MC13XXX_CORE=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+CONFIG_MEDIA_RC_SUPPORT=y
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=m
+CONFIG_VIDEO_V4L2_INT_DEVICE=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_RC_MAP=y
+CONFIG_RC_DECODERS=y
+CONFIG_LIRC=y
+CONFIG_IR_LIRC_CODEC=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_SANYO_DECODER=y
+CONFIG_IR_MCE_KBD_DECODER=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_USB_SN9C102 is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_TIMBERDALE is not set
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=m
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_IPU_CAMERA=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=m
+CONFIG_MXC_CAMERA_OV5640=m
+CONFIG_MXC_CAMERA_OV5642=m
+CONFIG_MXC_CAMERA_OV5640_MIPI=m
+CONFIG_MXC_TVIN_ADV7180=m
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=m
+CONFIG_MXC_IPU_PRP_ENC=m
+CONFIG_MXC_IPU_CSI_ENC=m
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+CONFIG_SOC_CAMERA=y
+# CONFIG_SOC_CAMERA_PLATFORM is not set
+CONFIG_MX3_VIDEO=y
+CONFIG_VIDEO_MX3=y
+# CONFIG_VIDEO_SH_MOBILE_CSI2 is not set
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# soc_camera sensor drivers
+#
+# CONFIG_SOC_CAMERA_IMX074 is not set
+# CONFIG_SOC_CAMERA_MT9M001 is not set
+# CONFIG_SOC_CAMERA_MT9M111 is not set
+# CONFIG_SOC_CAMERA_MT9T031 is not set
+# CONFIG_SOC_CAMERA_MT9T112 is not set
+# CONFIG_SOC_CAMERA_MT9V022 is not set
+# CONFIG_SOC_CAMERA_OV2640 is not set
+CONFIG_SOC_CAMERA_OV5642=m
+# CONFIG_SOC_CAMERA_OV6650 is not set
+# CONFIG_SOC_CAMERA_OV772X is not set
+# CONFIG_SOC_CAMERA_OV9640 is not set
+# CONFIG_SOC_CAMERA_OV9740 is not set
+# CONFIG_SOC_CAMERA_RJ54N1 is not set
+# CONFIG_SOC_CAMERA_TW9910 is not set
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_DRM=y
+CONFIG_DRM_VIVANTE=y
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_TEGRA_HOST1X is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+CONFIG_FB_MX3=y
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+CONFIG_FB_MXS=y
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_LDB=y
+CONFIG_FB_MXC_MIPI_DSI=y
+CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXC_EDID=y
+CONFIG_FB_MXC_EINK_PANEL=y
+CONFIG_FB_MXC_SYNC_PANEL_EDID=y
+# CONFIG_FB_MXC_EINK_AUTO_UPDATE_MODE is not set
+CONFIG_FB_MXS_SII902X=y
+CONFIG_HANNSTAR_CABC=y
+CONFIG_FB_MXC_CH7055=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_FB_SSD1307 is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_PCI=y
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_DMAENGINE_PCM=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_SOC_FSL_SSI=y
+CONFIG_SND_SOC_FSL_ASRC=y
+CONFIG_SND_SOC_FSL_SPDIF=y
+CONFIG_SND_SOC_FSL_HDMI=y
+CONFIG_SND_SOC_FSL_UTILS=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_IMX_PCM_DMA=y
+CONFIG_SND_SOC_IMX_HDMI_DMA=y
+CONFIG_SND_SOC_IMX_AUDMUX=y
+# CONFIG_SND_SOC_EUKREA_TLV320 is not set
+# CONFIG_SND_SOC_IMX_CS42888 is not set
+# CONFIG_SND_SOC_IMX_WM8962 is not set
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+# CONFIG_SND_SOC_IMX_MC13783 is not set
+CONFIG_SND_SOC_IMX_HDMI=y
+# CONFIG_SND_SOC_IMX_SI476X is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_OMAP_HDMI_CODEC=y
+CONFIG_SND_SOC_SGTL5000=y
+CONFIG_SND_SOC_SPDIF=y
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_EHCI_MXC is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_IMX21_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+# CONFIG_USB_CHIPIDEA_DEBUG is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_ZTE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+CONFIG_USB_PHY=y
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_OMAP_CONTROL_USB is not set
+# CONFIG_OMAP_USB3 is not set
+# CONFIG_SAMSUNG_USBPHY is not set
+# CONFIG_SAMSUNG_USB2PHY is not set
+# CONFIG_SAMSUNG_USB3PHY is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+CONFIG_USB_MXS_PHY=y
+# CONFIG_USB_RCAR_PHY is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FSL_USB2 is not set
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=m
+CONFIG_USB_F_ACM=m
+CONFIG_USB_U_SERIAL=m
+CONFIG_USB_F_SERIAL=m
+CONFIG_USB_F_OBEX=m
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_ETH_EEM is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=m
+# CONFIG_FSL_UTP is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+
+#
+# MXC support drivers
+#
+CONFIG_MXC_IPU=y
+
+#
+# MXC Vivante GPU support
+#
+CONFIG_MXC_GPU_VIV=y
+CONFIG_MXC_IPU_V3=y
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+CONFIG_MXC_ASRC=y
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+CONFIG_MXC_VPU=y
+# CONFIG_MXC_VPU_DEBUG is not set
+# CONFIG_MX6_VPU_352M is not set
+
+#
+# MXC HDMI CEC (Consumer Electronics Control) support
+#
+# CONFIG_MXC_HDMI_CEC is not set
+
+#
+# MXC MIPI Support
+#
+CONFIG_MXC_MIPI_CSI2=y
+
+#
+# MXC Media Local Bus Driver
+#
+CONFIG_MXC_MLB=y
+CONFIG_MXC_MLB150=m
+CONFIG_LEDS_GPIO_REGISTER=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_MC13783 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+CONFIG_LEDS_TRIGGER_GPIO=y
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+CONFIG_RTC_DRV_S35390A=y
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_IMXDI is not set
+CONFIG_RTC_DRV_MC13XXX=y
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_SNVS=y
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_DW_DMAC is not set
+CONFIG_MX3_IPU=y
+CONFIG_MX3_IPU_IRQS=4
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_CLIENT_DEVICE=y
+# CONFIG_TIMB_DMA is not set
+CONFIG_IMX_SDMA=y
+# CONFIG_IMX_DMA is not set
+CONFIG_MXS_DMA=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CSR_WIFI is not set
+CONFIG_NET_VENDOR_SILICOM=y
+# CONFIG_CED1401 is not set
+# CONFIG_DRM_IMX is not set
+# CONFIG_DGRP is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_DEBUG=y
+# CONFIG_COMMON_CLK_SI5351 is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_VF_PIT_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+# CONFIG_IPACK_BUS is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_GPIO=y
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=m
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU_DELAY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_IMX_UART_PORT=1
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+CONFIG_SECURITYFS=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=y
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_ARM is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_BLOWFISH_COMMON=y
+CONFIG_CRYPTO_CAMELLIA=y
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE=9
+# CONFIG_CRYPTO_DEV_FSL_CAAM_INTC is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API=y
+# CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE=7
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_STMP_DEVICE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=y
+# CONFIG_VIRTUALIZATION is not set
Index: drivers/media/rc/Makefile
===================================================================
diff --git a/drivers/media/rc/Makefile b/drivers/media/rc/Makefile
--- a/drivers/media/rc/Makefile	(revision 513)
+++ b/drivers/media/rc/Makefile	(revision 1734)
@@ -29,4 +29,4 @@
 obj-$(CONFIG_RC_LOOPBACK) += rc-loopback.o
 obj-$(CONFIG_IR_GPIO_CIR) += gpio-ir-recv.o
 obj-$(CONFIG_IR_IGUANA) += iguanair.o
-obj-$(CONFIG_IR_TTUSBIR) += ttusbir.o
+obj-$(CONFIG_IR_TTUSBIR) += ttusbir.o
\ No newline at end of file
Index: drivers/media/rc/gpio-ir-recv.c
===================================================================
diff --git a/drivers/media/rc/gpio-ir-recv.c b/drivers/media/rc/gpio-ir-recv.c
--- a/drivers/media/rc/gpio-ir-recv.c	(revision 513)
+++ b/drivers/media/rc/gpio-ir-recv.c	(revision 1734)
@@ -42,7 +42,7 @@
 	enum of_gpio_flags flags;
 	int gpio;
 
-	gpio = of_get_gpio_flags(np, 0, &flags);
+	gpio = of_get_gpio_flags(np, 0, &flags);	
 	if (gpio < 0) {
 		if (gpio != -EPROBE_DEFER)
 			dev_err(dev, "Failed to get gpio flags (%d)\n", gpio);
@@ -85,6 +85,10 @@
 	if (gpio_dev->active_low)
 		gval = !gval;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	(gval > 0)? (gval = 1): (gval = 0);
+#endif
+	
 	if (gval == 1)
 		type = IR_PULSE;
 
Index: drivers/mtd/devices/m25p80.c
===================================================================
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
--- a/drivers/mtd/devices/m25p80.c	(revision 513)
+++ b/drivers/mtd/devices/m25p80.c	(revision 1734)
@@ -708,6 +708,11 @@
  * have been converging on command sets which including JEDEC ID.
  */
 static const struct spi_device_id m25p_ids[] = {
+	#ifdef CONFIG_ARCH_ADVANTECH
+	/* Micron N25Q */
+	{ "n25q", INFO(0x20ba16, 0, 64 * 1024,  64, SECT_4K) },
+	{ "n25q", INFO(0x20bb16, 0, 64 * 1024,  64, SECT_4K) },
+	#endif
 	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
 	{ "at25fs010",  INFO(0x1f6601, 0, 32 * 1024,   4, SECT_4K) },
 	{ "at25fs040",  INFO(0x1f6604, 0, 64 * 1024,   8, SECT_4K) },
Index: drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c	(revision 1734)
@@ -1060,6 +1060,7 @@
 
         /* Free the command buffer. */
         gcmkCHECK_STATUS(gckVIDMEM_Free(
+            Command->kernel->kernel,
             node
             ));
     }
@@ -1082,7 +1083,7 @@
         gcmkERR_BREAK(gckVIDMEM_Unlock(Kernel->kernel, Node, gcvSURF_TYPE_UNKNOWN, gcvNULL));
 
         /* Free the linear buffer. */
-        gcmkERR_BREAK(gckVIDMEM_Free(Node));
+        gcmkERR_BREAK(gckVIDMEM_Free(Kernel->kernel, Node));
     }
     while (gcvFALSE);
 
@@ -1676,7 +1677,7 @@
             = (gcsTASK_FREE_VIDEO_MEMORY_PTR) TaskHeader->task;
 
         /* Free video memory. */
-        gcmkERR_BREAK(gckVIDMEM_Free(gcmUINT64_TO_PTR(task->node)));
+        gcmkERR_BREAK(gckVIDMEM_Free(Command->kernel->kernel, gcmUINT64_TO_PTR(task->node)));
 
         /* Update the reference counter. */
         TaskHeader->container->referenceCount -= 1;
Index: drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c	(revision 1734)
@@ -308,7 +308,8 @@
                 if(*Pool == gcvPOOL_SYSTEM)
                     Type |= gcvSURF_VG;
                 /* Allocate memory. */
-                status = gckVIDMEM_AllocateLinear(videoMemory,
+                status = gckVIDMEM_AllocateLinear(Kernel,
+                                                  videoMemory,
                                                   Bytes,
                                                   Alignment,
                                                   Type,
@@ -599,7 +600,7 @@
 #endif /* __QNXNTO__ */
 
         /* Free video memory. */
-        gcmkERR_BREAK(gckVIDMEM_Free(
+        gcmkERR_BREAK(gckVIDMEM_Free(Kernel,
             node
             ));
 
Index: drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c	(revision 1734)
@@ -165,6 +165,8 @@
     kernel->dvfs         = gcvNULL;
 #endif
 
+    kernel->vidmemMutex  = gcvNULL;
+
     /* Initialize the gckKERNEL object. */
     kernel->object.type = gcvOBJ_KERNEL;
     kernel->os          = Os;
@@ -297,6 +299,9 @@
     gcmkONERROR(gckOS_CreateSyncTimeline(Os, &kernel->timeline));
 #endif
 
+    /* Construct a video memory mutex. */
+    gcmkONERROR(gckOS_GetVideoMemoryMutex(Os, &kernel->vidmemMutex));
+
     /* Return pointer to the gckKERNEL object. */
     *Kernel = kernel;
 
@@ -529,7 +534,7 @@
     return gcvSTATUS_OK;
 }
 
-#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+#ifdef CONFIG_GPU_LOW_MEMORY_KILLER
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/oom.h>
@@ -565,30 +570,33 @@
 		struct mm_struct *mm;
 		struct signal_struct *sig;
                 gcuDATABASE_INFO info;
-		int oom_adj;
+		int oom_adj, pid;
 
 		task_lock(p);
 		mm = p->mm;
 		sig = p->signal;
+                pid = p->pid;
 		if (!mm || !sig) {
 			task_unlock(p);
 			continue;
 		}
 		oom_adj = sig->oom_adj;
+		task_unlock(p);
 		if (oom_adj < min_adj) {
-			task_unlock(p);
 			continue;
 		}
 
+                read_unlock(&tasklist_lock);
+
 		tasksize = 0;
-		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_VIDEO_MEMORY, &info) == gcvSTATUS_OK){
+		if (gckKERNEL_QueryProcessDB(Kernel, pid, gcvFALSE, gcvDB_VIDEO_MEMORY, &info) == gcvSTATUS_OK){
 			tasksize += info.counters.bytes / PAGE_SIZE;
 		}
-		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_CONTIGUOUS, &info) == gcvSTATUS_OK){
+		if (gckKERNEL_QueryProcessDB(Kernel, pid, gcvFALSE, gcvDB_CONTIGUOUS, &info) == gcvSTATUS_OK){
 			tasksize += info.counters.bytes / PAGE_SIZE;
 		}
 
-		task_unlock(p);
+                read_lock(&tasklist_lock);
 
 		if (tasksize <= 0)
 			continue;
@@ -667,7 +675,7 @@
     gcmkVERIFY_ARGUMENT(Pool != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes != 0);
 
-#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+#ifdef CONFIG_GPU_LOW_MEMORY_KILLER
 _AllocateMemory_Retry:
 #endif
     /* Get initial pool. */
@@ -767,7 +775,7 @@
                     {
                         gckOS_Print("gpu virtual memory 0x%x cannot be allocated in force contiguous request!\n", physAddr);
 
-                        gcmkONERROR(gckVIDMEM_Free(node));
+                        gcmkONERROR(gckVIDMEM_Free(Kernel, node));
 
                         node = gcvNULL;
                     }
@@ -797,7 +805,8 @@
             if (gcmIS_SUCCESS(status))
             {
                 /* Allocate memory. */
-                status = gckVIDMEM_AllocateLinear(videoMemory,
+                status = gckVIDMEM_AllocateLinear(Kernel,
+                                                  videoMemory,
                                                   Bytes,
                                                   Alignment,
                                                   Type,
@@ -858,10 +867,18 @@
     if (node == gcvNULL)
     {
 
-#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+#ifdef CONFIG_GPU_LOW_MEMORY_KILLER
         if(forceContiguous == gcvTRUE)
         {
-            if(force_contiguous_lowmem_shrink(Kernel) == 0)
+            int ret;
+             /* Acquire the mutex. */
+            gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, Kernel->vidmemMutex, gcvINFINITE));
+
+            ret = force_contiguous_lowmem_shrink(Kernel);
+
+            gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
+
+            if(ret == 0)
             {
                  /* Sleep 1 millisecond. */
                  gckOS_Delay(gcvNULL, 1);
@@ -1249,15 +1266,7 @@
             node->VidMem.logical = gcvNULL;
         }
 #endif
-        /* Free video memory. */
-        gcmkONERROR(
-            gckVIDMEM_Free(node));
 
-        gcmkONERROR(
-            gckKERNEL_RemoveProcessDB(Kernel,
-                                      processID, gcvDB_VIDEO_MEMORY,
-                                      node));
-
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
            gcmkONERROR(
@@ -1280,6 +1289,15 @@
                                       node));
         }
 
+        /* Free video memory. */
+        gcmkONERROR(
+            gckVIDMEM_Free(Kernel, node));
+
+        gcmkONERROR(
+            gckKERNEL_RemoveProcessDB(Kernel,
+                                      processID, gcvDB_VIDEO_MEMORY,
+                                      node));
+
         break;
 
     case gcvHAL_LOCK_VIDEO_MEMORY:
Index: drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c	(revision 1734)
@@ -2280,7 +2280,7 @@
 
                 /* Free video memory. */
                 status =
-                    gckVIDMEM_Free(node);
+                    gckVIDMEM_Free(Event->kernel, node);
 
                 break;
 
Index: drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h	(revision 1734)
@@ -453,6 +453,8 @@
 #if gcdANDROID_NATIVE_FENCE_SYNC
     gctHANDLE                   timeline;
 #endif
+
+    gctPOINTER                  vidmemMutex;
 };
 
 struct _FrequencyHistory
@@ -766,9 +768,6 @@
         /* Actual physical address */
         gctUINT32               addresses[gcdMAX_GPU_COUNT];
 
-        /* Mutex. */
-        gctPOINTER              mutex;
-
         /* Locked counter. */
         gctINT32                lockeds[gcdMAX_GPU_COUNT];
 
@@ -824,9 +823,6 @@
     /* Allocation threshold. */
     gctSIZE_T                   threshold;
 
-    /* The heap mutex. */
-    gctPOINTER                  mutex;
-
 #if gcdUSE_VIDMEM_PER_PID
     /* The Pid this VidMem belongs to. */
     gctUINT32                   pid;
Index: drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c	(revision 1734)
@@ -165,7 +165,6 @@
     gceSTATUS status;
     gcsDATABASE_PTR database, previous;
     gctSIZE_T slot;
-    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d LastProcessID=%d",
                    Kernel, ProcessID, LastProcessID);
@@ -173,11 +172,6 @@
     /* Compute the hash for the database. */
     slot = ProcessID % gcmCOUNTOF(Kernel->db->db);
 
-    /* Acquire the database mutex. */
-    gcmkONERROR(
-        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
-    acquired = gcvTRUE;
-
     /* Check whether we are getting the last known database. */
     if (LastProcessID)
     {
@@ -221,9 +215,6 @@
         }
     }
 
-    /* Release the database mutex. */
-    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-
     /* Return the database. */
     *Database = database;
 
@@ -232,11 +223,6 @@
     return gcvSTATUS_OK;
 
 OnError:
-    if (acquired)
-    {
-        /* Release the database mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-    }
 
     /* Return the status. */
     gcmkFOOTER();
@@ -267,16 +253,10 @@
     )
 {
     gceSTATUS status;
-    gctBOOL acquired = gcvFALSE;
     gcsDATABASE_PTR database;
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x", Kernel, Database);
 
-    /* Acquire the database mutex. */
-    gcmkONERROR(
-        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
-    acquired = gcvTRUE;
-
     /* Check slot value. */
     gcmkVERIFY_ARGUMENT(Database->slot < gcmCOUNTOF(Kernel->db->db));
 
@@ -323,19 +303,11 @@
     /* Keep database as the last database. */
     Kernel->db->lastDatabase = Database;
 
-    /* Release the database mutex. */
-    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
-    if (acquired)
-    {
-        /* Release the database mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-    }
 
     /* Return the status. */
     gcmkFOOTER();
@@ -371,16 +343,10 @@
     )
 {
     gceSTATUS status;
-    gctBOOL acquired = gcvFALSE;
     gcsDATABASE_RECORD_PTR record = gcvNULL;
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x", Kernel, Database);
 
-    /* Acquire the database mutex. */
-    gcmkONERROR(
-        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
-    acquired = gcvTRUE;
-
     if (Kernel->db->freeRecord != gcvNULL)
     {
         /* Allocate the record from the free list. */
@@ -403,9 +369,6 @@
     record->next         = Database->list[Slot];
     Database->list[Slot] = record;
 
-    /* Release the database mutex. */
-    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-
     /* Return the record. */
     *Record = record;
 
@@ -414,11 +377,6 @@
     return gcvSTATUS_OK;
 
 OnError:
-    if (acquired)
-    {
-        /* Release the database mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-    }
     if (record != gcvNULL)
     {
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Kernel->os, record));
@@ -464,19 +422,12 @@
     )
 {
     gceSTATUS status;
-    gctBOOL acquired = gcvFALSE;
     gcsDATABASE_RECORD_PTR record, previous;
     gctUINT32 slot = _GetSlot(Database, Data);
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x Type=%d Data=0x%x",
                    Kernel, Database, Type, Data);
 
-    /* Acquire the database mutex. */
-    gcmkONERROR(
-        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
-    acquired = gcvTRUE;
-
-
     /* Scan the database for this record. */
     for (record = Database->list[slot], previous = gcvNULL;
          record != gcvNULL;
@@ -520,19 +471,11 @@
     record->next       = Kernel->db->freeRecord;
     Kernel->db->freeRecord = record;
 
-    /* Release the database mutex. */
-    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-
     /* Success. */
     gcmkFOOTER_ARG("*Bytes=%lu", gcmOPT_VALUE(Bytes));
     return gcvSTATUS_OK;
 
 OnError:
-    if (acquired)
-    {
-        /* Release the database mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-    }
 
     /* Return the status. */
     gcmkFOOTER();
@@ -574,18 +517,12 @@
     )
 {
     gceSTATUS status;
-    gctBOOL acquired = gcvFALSE;
     gcsDATABASE_RECORD_PTR record;
     gctUINT32 slot = _GetSlot(Database, Data);
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x Type=%d Data=0x%x",
                    Kernel, Database, Type, Data);
 
-    /* Acquire the database mutex. */
-    gcmkONERROR(
-        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
-    acquired = gcvTRUE;
-
     /* Scan the database for this record. */
     for (record = Database->list[slot];
          record != gcvNULL;
@@ -614,19 +551,11 @@
             gckOS_MemCopy(Record, record, sizeof(gcsDATABASE_RECORD)));
     }
 
-    /* Release the database mutex. */
-    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-
     /* Success. */
     gcmkFOOTER_ARG("Record=0x%x", Record);
     return gcvSTATUS_OK;
 
 OnError:
-    if (acquired)
-    {
-        /* Release the database mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
-    }
 
     /* Return the status. */
     gcmkFOOTER();
@@ -807,6 +736,7 @@
     gcsDATABASE_PTR database;
     gcsDATABASE_RECORD_PTR record = gcvNULL;
     gcsDATABASE_COUNTERS * count;
+    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d Type=%d Pointer=0x%x "
                    "Physical=0x%x Size=%lu",
@@ -815,6 +745,11 @@
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
 
+    /* Acquire the database mutex. */
+    gcmkONERROR(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
     /* Special case the idle record. */
     if (Type == gcvDB_IDLE)
     {
@@ -869,6 +804,8 @@
             }
         }
 #endif
+        /* Release the database mutex. */
+        gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
 
         /* Success. */
         gcmkFOOTER_NO();
@@ -878,6 +815,7 @@
     /* Verify the arguments. */
     gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
 
+
     /* Find the database. */
     gcmkONERROR(gckKERNEL_FindDatabase(Kernel, ProcessID, gcvFALSE, &database));
 
@@ -943,11 +881,20 @@
         }
     }
 
+    /* Release the database mutex. */
+    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
+    if (acquired)
+    {
+        /* Release the database mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+    }
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -987,6 +934,7 @@
     gceSTATUS status;
     gcsDATABASE_PTR database;
     gctSIZE_T bytes = 0;
+    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d Type=%d Pointer=0x%x",
                    Kernel, ProcessID, Type, Pointer);
@@ -995,6 +943,11 @@
     gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
     gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
 
+    /* Acquire the database mutex. */
+    gcmkONERROR(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
     /* Find the database. */
     gcmkONERROR(gckKERNEL_FindDatabase(Kernel, ProcessID, gcvFALSE, &database));
 
@@ -1041,11 +994,20 @@
         break;
     }
 
+    /* Release the database mutex. */
+    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
+    if (acquired)
+    {
+        /* Release the database mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+    }
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -1087,6 +1049,7 @@
 {
     gceSTATUS status;
     gcsDATABASE_PTR database;
+    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d Type=%d Pointer=0x%x",
                    Kernel, ProcessID, ThreadID, Type, Pointer);
@@ -1095,6 +1058,11 @@
     gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
     gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
 
+    /* Acquire the database mutex. */
+    gcmkONERROR(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
     /* Find the database. */
     gcmkONERROR(gckKERNEL_FindDatabase(Kernel, ProcessID, gcvFALSE, &database));
 
@@ -1102,11 +1070,20 @@
     gcmkONERROR(
         gckKERNEL_FindRecord(Kernel, database, Type, Pointer, Record));
 
+    /* Release the database mutex. */
+    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
+    if (acquired)
+    {
+        /* Release the database mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+    }
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -1145,12 +1122,18 @@
     gcuVIDMEM_NODE_PTR node;
     gckKERNEL kernel = Kernel;
     gctUINT32 i;
+    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
 
+    /* Acquire the database mutex. */
+    gcmkONERROR(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
     /* Find the database. */
     gcmkONERROR(gckKERNEL_FindDatabase(Kernel, ProcessID, gcvFALSE, &database));
 
@@ -1194,12 +1177,15 @@
         /* Next next record. */
         next = record->next;
 
+        gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+        acquired = gcvFALSE;
+
         /* Dispatch on record type. */
         switch (record->type)
         {
         case gcvDB_VIDEO_MEMORY:
             /* Free the video memory. */
-            status = gckVIDMEM_Free(gcmUINT64_TO_PTR(record->data));
+            status = gckVIDMEM_Free(Kernel, gcmUINT64_TO_PTR(record->data));
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: VIDEO_MEMORY 0x%x (status=%d)",
@@ -1364,6 +1350,10 @@
             break;
         }
 
+        gcmkONERROR(
+            gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+        acquired = gcvTRUE;
+
         /* Delete the record. */
         gcmkONERROR(gckKERNEL_DeleteRecord(Kernel,
                                            database,
@@ -1377,11 +1367,20 @@
     /* Delete the database. */
     gcmkONERROR(gckKERNEL_DeleteDatabase(Kernel, database));
 
+    /* Release the database mutex. */
+    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
+    if (acquired)
+    {
+        /* Release the database mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+    }
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -1424,6 +1423,7 @@
 {
     gceSTATUS status;
     gcsDATABASE_PTR database;
+    gctBOOL acquired = gcvFALSE;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d Type=%d Info=0x%x",
                    Kernel, ProcessID, Type, Info);
@@ -1432,6 +1432,11 @@
     gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
     gcmkVERIFY_ARGUMENT(Info != gcvNULL);
 
+    /* Acquire the database mutex. */
+    gcmkONERROR(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
     /* Find the database. */
     gcmkONERROR(
         gckKERNEL_FindDatabase(Kernel, ProcessID, LastProcessID, &database));
@@ -1496,11 +1501,20 @@
         break;
     }
 
+    /* Release the database mutex. */
+    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
+    if (acquired)
+    {
+        /* Release the database mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+    }
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
Index: drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h	(revision 1734)
@@ -18,7 +18,6 @@
 *
 *****************************************************************************/
 
-
 #ifndef __gc_hal_types_h_
 #define __gc_hal_types_h_
 
@@ -1015,6 +1014,7 @@
     gcePATCH_RTESTVA,
     gcePATCH_BMX,
     gcePATCH_BMGUI,
+    gcePATCH_ANDROID_CTS_MEDIA_PRESENTATIONTIME,
 
     /* Game list */
     gcePATCH_NBA2013,
@@ -1048,7 +1048,16 @@
     gcePATCH_DUOKANTV,
     gcePATCH_TESTAPP,
     gcePATCH_GOOGLEEARTH,
-
+    gcePATCH_SF4,
+    gcePATCH_SPEEDRACE,
+    gcePATCH_AIRNAVY,
+    gcePATCH_F18NEW,
+    gcePATCH_F18,
+    gcePATCH_WISTONESG,
+    gcvPATCH_VECUNIT_RED,
+    gcvPATCH_NAMESGAS,
+    gcvPATCH_AFTERBURNER,
+    gcvPATCH_UIMARK,
     /* Count enum*/
     gcePATCH_COUNT,
 }
Index: drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h	(revision 1734)
@@ -704,6 +704,7 @@
     gcv2D_STATE_EN_GAMMA,
     gcv2D_STATE_DE_GAMMA,
     gcv2D_STATE_MULTI_SRC_BLIT_UNIFIED_DST_RECT,
+    gcv2D_STATE_XRGB_ENABLE,
 
     gcv2D_STATE_ARRAY_EN_GAMMA                   = 0x10001,
     gcv2D_STATE_ARRAY_DE_GAMMA,
Index: drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h	(revision 1734)
@@ -455,6 +455,7 @@
 typedef struct _gcsHINT *               gcsHINT_PTR;
 typedef struct _gcSHADER_PROFILER *     gcSHADER_PROFILER;
 typedef struct _gcVARIABLE *			gcVARIABLE;
+typedef struct _gcSHADER_LIST *         gcSHADER_LIST;
 
 struct _gcsHINT
 {
@@ -523,6 +524,11 @@
 #if TEMP_SHADER_PATCH
 	gctUINT32	pachedShaderIdentifier;
 #endif
+
+#if gcdUSE_WCLIP_PATCH
+    /* Strict WClip match. */
+    gctBOOL     strictWClipMatch;
+#endif
 };
 
 #if TEMP_SHADER_PATCH
@@ -3230,6 +3236,12 @@
 	OUT gctBOOL * Enabled
 	);
 
+gceSTATUS
+gcATTRIBUTE_GetIndex(
+    IN gcATTRIBUTE Attribute,
+    OUT gctUINT16 * Index
+    );
+
 /*******************************************************************************
 **                              gcUNIFORM_GetType
 ********************************************************************************
@@ -3392,6 +3404,12 @@
 	OUT gctUINT32 * Sampler
 	);
 
+gceSTATUS
+gcUNIFORM_GetIndex(
+    IN gcUNIFORM Uniform,
+    OUT gctUINT16 * Index
+    );
+
 /*******************************************************************************
 **  gcUNIFORM_GetFormat
 **
@@ -4290,6 +4308,46 @@
     IN OUT gcsHINT_PTR             pHints /* User needs copy original hints to this one, then passed this one in */
     );
 
+gceSTATUS
+gcSHADER_InsertList(
+    IN gcSHADER                    Shader,
+    IN gcSHADER_LIST *             Root,
+    IN gctINT                      Index,
+    IN gctINT                      Data0,
+    IN gctINT                      Data1
+    );
+
+gceSTATUS
+gcSHADER_UpdateList(
+    IN gcSHADER                    Shader,
+    IN gcSHADER_LIST               Root,
+    IN gctINT                      Index,
+    IN gctINT                      NewIndex
+    );
+
+gceSTATUS
+gcSHADER_DeleteList(
+    IN gcSHADER                    Shader,
+    IN gcSHADER_LIST *             Root,
+    IN gctINT                      Index
+    );
+
+gceSTATUS
+gcSHADER_FindList(
+    IN gcSHADER                    Shader,
+    IN gcSHADER_LIST               Root,
+    IN gctINT                      Index,
+    IN gcSHADER_LIST *             List
+    );
+
+gceSTATUS
+gcSHADER_InsertWClipList(
+    IN gcSHADER                    Shader,
+    IN gctINT                      Index,
+    IN gctINT                      Data0,
+    IN gctINT                      Data1
+    );
+
 #ifdef __cplusplus
 }
 #endif
Index: drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h	(revision 1734)
@@ -55,18 +55,21 @@
 #include "wayland-server.h"
 #include <wayland-egl.h>
 
-#define WL_EGL_NUM_BACKBUFFERS 2
+#define WL_EGL_NUM_BACKBUFFERS 3
 
 typedef struct _gcsWL_VIV_BUFFER
 {
-   struct wl_buffer wl_buffer;
+   struct wl_resource *wl_buffer;
    gcoSURF surface;
+   gctINT32 width, height;
 } gcsWL_VIV_BUFFER;
 
 typedef struct _gcsWL_EGL_DISPLAY
 {
    struct wl_display* wl_display;
    struct wl_viv* wl_viv;
+   struct wl_registry *registry;
+   struct wl_event_queue    *wl_queue;
 } gcsWL_EGL_DISPLAY;
 
 typedef struct _gcsWL_EGL_BUFFER_INFO
@@ -79,6 +82,9 @@
    gcePOOL pool;
    gctUINT bytes;
    gcoSURF surface;
+   gcoSURF attached_surface;
+   gctINT32 invalidate;
+   gctBOOL locked;
 } gcsWL_EGL_BUFFER_INFO;
 
 typedef struct _gcsWL_EGL_BUFFER
@@ -89,19 +95,24 @@
 
 typedef struct _gcsWL_EGL_WINDOW_INFO
 {
+   gctINT32 dx;
+   gctINT32 dy;
    gctUINT width;
    gctUINT height;
+   gctINT32 attached_width;
+   gctINT32 attached_height;
    gceSURF_FORMAT format;
    gctUINT bpp;
 } gcsWL_EGL_WINDOW_INFO;
 
 struct wl_egl_window
 {
+   gcsWL_EGL_DISPLAY* display;
    gcsWL_EGL_BUFFER backbuffers[WL_EGL_NUM_BACKBUFFERS];
    gcsWL_EGL_WINDOW_INFO info;
    gctUINT current;
    struct wl_surface* surface;
-   struct wl_callback* pending;
+   struct wl_callback* frame_callback;
 };
 
 typedef void*   HALNativeDisplayType;
Index: drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h	(revision 1734)
@@ -1497,6 +1497,13 @@
     IN gctPOINTER Timer
     );
 
+/* Get the global video memory mutex. */
+gceSTATUS
+gckOS_GetVideoMemoryMutex(
+    IN gckOS Os,
+    OUT gctPOINTER *Mutex
+    );
+
 /******************************************************************************\
 ********************************* gckHEAP Object ********************************
 \******************************************************************************/
@@ -1574,6 +1581,7 @@
 /* Allocate rectangular memory. */
 gceSTATUS
 gckVIDMEM_Allocate(
+    IN gckKERNEL Kernel,
     IN gckVIDMEM Memory,
     IN gctUINT Width,
     IN gctUINT Height,
@@ -1587,6 +1595,7 @@
 /* Allocate linear memory. */
 gceSTATUS
 gckVIDMEM_AllocateLinear(
+    IN gckKERNEL Kernel,
     IN gckVIDMEM Memory,
     IN gctSIZE_T Bytes,
     IN gctUINT32 Alignment,
@@ -1597,6 +1606,7 @@
 /* Free memory. */
 gceSTATUS
 gckVIDMEM_Free(
+    IN gckKERNEL Kernel,
     IN gcuVIDMEM_NODE_PTR Node
     );
 
Index: drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h	(revision 1734)
@@ -694,7 +694,7 @@
         This define enables the recovery code.
 */
 #ifndef gcdENABLE_RECOVERY
-#   define gcdENABLE_RECOVERY                   1
+#   define gcdENABLE_RECOVERY                   0
 #endif
 
 /*
Index: drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h	(revision 1734)
@@ -257,6 +257,9 @@
 
     /* Supertile layout style in hardware */
     gctUINT32                   superTileMode;
+
+    /* Special control bits for 2D chip. */
+    gctUINT32                   chip2DControl;
 }
 gcsHAL_QUERY_CHIP_IDENTITY;
 
Index: drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c	(revision 1734)
@@ -250,8 +250,6 @@
         node->Virtual.lockKernels[i]    = gcvNULL;
     }
 
-    node->Virtual.mutex         = gcvNULL;
-
     gcmkONERROR(gckOS_GetProcessID(&node->Virtual.processID));
 
 #ifdef __QNXNTO__
@@ -267,10 +265,6 @@
 
     gcmkONERROR(gckOS_ZeroMemory(&node->Virtual.sharedInfo, gcmSIZEOF(gcsVIDMEM_NODE_SHARED_INFO)));
 
-    /* Create the mutex. */
-    gcmkONERROR(
-        gckOS_CreateMutex(os, &node->Virtual.mutex));
-
     /* Allocate the virtual memory. */
     gcmkONERROR(
         gckOS_AllocatePagedMemoryEx(os,
@@ -303,12 +297,6 @@
     /* Roll back. */
     if (node != gcvNULL)
     {
-        if (node->Virtual.mutex != gcvNULL)
-        {
-            /* Destroy the mutex. */
-            gcmkVERIFY_OK(gckOS_DeleteMutex(os, node->Virtual.mutex));
-        }
-
         /* Free the structure. */
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(os, node));
     }
@@ -361,9 +349,6 @@
     }
 #endif
 
-    /* Delete the mutex. */
-    gcmkVERIFY_OK(gckOS_DeleteMutex(os, Node->Virtual.mutex));
-
     for (i = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         if (Node->Virtual.pageTables[i] != gcvNULL)
@@ -465,7 +450,6 @@
     memory->bytes       = Bytes;
     memory->freeBytes   = Bytes;
     memory->threshold   = Threshold;
-    memory->mutex       = gcvNULL;
 #if gcdUSE_VIDMEM_PER_PID
     gcmkONERROR(gckOS_GetProcessID(&memory->pid));
 #endif
@@ -602,9 +586,6 @@
                   "[GALCORE] TILE_STATUS:   bank %d",
                   memory->mapping[gcvSURF_TILE_STATUS]);
 
-    /* Allocate the mutex. */
-    gcmkONERROR(gckOS_CreateMutex(Os, &memory->mutex));
-
     /* Return pointer to the gckVIDMEM object. */
     *Memory = memory;
 
@@ -616,12 +597,6 @@
     /* Roll back. */
     if (memory != gcvNULL)
     {
-        if (memory->mutex != gcvNULL)
-        {
-            /* Delete the mutex. */
-            gcmkVERIFY_OK(gckOS_DeleteMutex(Os, memory->mutex));
-        }
-
         for (i = 0; i < banks; ++i)
         {
             /* Free the heap. */
@@ -688,9 +663,6 @@
         }
     }
 
-    /* Free the mutex. */
-    gcmkVERIFY_OK(gckOS_DeleteMutex(Memory->os, Memory->mutex));
-
     /* Mark the object as unknown. */
     Memory->object.type = gcvOBJ_UNKNOWN;
 
@@ -742,6 +714,7 @@
 */
 gceSTATUS
 gckVIDMEM_Allocate(
+    IN gckKERNEL Kernel,
     IN gckVIDMEM Memory,
     IN gctUINT Width,
     IN gctUINT Height,
@@ -773,7 +746,7 @@
 
     /* Allocate through linear function. */
     gcmkONERROR(
-        gckVIDMEM_AllocateLinear(Memory, bytes, Alignment, Type, Node));
+        gckVIDMEM_AllocateLinear(Kernel, Memory, bytes, Alignment, Type, Node));
 
     /* Success. */
     gcmkFOOTER_ARG("*Node=0x%x", *Node);
@@ -989,6 +962,7 @@
 */
 gceSTATUS
 gckVIDMEM_AllocateLinear(
+    IN gckKERNEL Kernel,
     IN gckVIDMEM Memory,
     IN gctSIZE_T Bytes,
     IN gctUINT32 Alignment,
@@ -1016,7 +990,7 @@
     gcmkVERIFY_ARGUMENT(Type < gcvSURF_NUM_TYPES);
 
     /* Acquire the mutex. */
-    gcmkONERROR(gckOS_AcquireMutex(Memory->os, Memory->mutex, gcvINFINITE));
+    gcmkONERROR(gckOS_AcquireMutex(Memory->os, Kernel->vidmemMutex, gcvINFINITE));
 
     acquired = gcvTRUE;
 #if !gcdUSE_VIDMEM_PER_PID
@@ -1203,7 +1177,7 @@
 #endif
 
     /* Release the mutex. */
-    gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Kernel->vidmemMutex));
 
     /* Return the pointer to the node. */
     *Node = node;
@@ -1220,7 +1194,7 @@
     if (acquired)
     {
      /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Kernel->vidmemMutex));
     }
 
     /* Return the status. */
@@ -1245,6 +1219,7 @@
 */
 gceSTATUS
 gckVIDMEM_Free(
+    IN gckKERNEL Kernel,
     IN gcuVIDMEM_NODE_PTR Node
     )
 {
@@ -1252,13 +1227,17 @@
     gckKERNEL kernel = gcvNULL;
     gckVIDMEM memory = gcvNULL;
     gcuVIDMEM_NODE_PTR node;
-    gctBOOL mutexAcquired = gcvFALSE;
     gckOS os = gcvNULL;
     gctBOOL acquired = gcvFALSE;
     gctINT32 i, totalLocked;
 
     gcmkHEADER_ARG("Node=0x%x", Node);
 
+    /* Acquire the mutex. */
+    gcmkONERROR(
+        gckOS_AcquireMutex(Kernel->os, Kernel->vidmemMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
     /* Verify the arguments. */
     if ((Node == gcvNULL)
     ||  (Node->VidMem.memory == gcvNULL)
@@ -1277,6 +1256,9 @@
             /* Client still has a lock, defer free op 'till when lock reaches 0. */
             Node->VidMem.freePending = gcvTRUE;
 
+            gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
+            acquired = gcvFALSE;
+
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                            "Node 0x%x is locked (%d)... deferring free.",
                            Node, Node->VidMem.locked);
@@ -1288,12 +1270,6 @@
         /* Extract pointer to gckVIDMEM object owning the node. */
         memory = Node->VidMem.memory;
 
-        /* Acquire the mutex. */
-        gcmkONERROR(
-            gckOS_AcquireMutex(memory->os, memory->mutex, gcvINFINITE));
-
-        mutexAcquired = gcvTRUE;
-
 #ifdef __QNXNTO__
 #if !gcdUSE_VIDMEM_PER_PID
         /* Reset. */
@@ -1370,7 +1346,7 @@
         }
 
         /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(memory->os, memory->mutex));
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
 
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                        "Node 0x%x is freed.",
@@ -1393,12 +1369,6 @@
     os = kernel->os;
     gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
 
-    /* Grab the mutex. */
-    gcmkONERROR(
-        gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
-
-    acquired = gcvTRUE;
-
     for (i = 0, totalLocked = 0; i < gcdMAX_GPU_COUNT; i++)
     {
         totalLocked += Node->Virtual.lockeds[i];
@@ -1412,8 +1382,6 @@
 
         /* Set Flag */
         Node->Virtual.freed = gcvTRUE;
-
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
     }
     else
     {
@@ -1422,28 +1390,20 @@
                                             Node->Virtual.physical,
                                             Node->Virtual.bytes));
 
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
-
         /* Destroy the gcuVIDMEM_NODE union. */
         gcmkVERIFY_OK(gckVIDMEM_DestroyVirtual(Node));
     }
 
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
-    if (mutexAcquired)
-    {
-        /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(
-            memory->os, memory->mutex
-            ));
-    }
-
     if (acquired)
     {
-       gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
     }
 
     /* Return the status. */
@@ -1684,6 +1644,10 @@
     /* Verify the arguments. */
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
+    /* Grab the mutex. */
+    gcmkONERROR(gckOS_AcquireMutex(Kernel->os, Kernel->vidmemMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
     if ((Node == gcvNULL)
     ||  (Node->VidMem.memory == gcvNULL)
     )
@@ -1745,10 +1709,6 @@
         os = Node->Virtual.kernel->os;
         gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
 
-        /* Grab the mutex. */
-        gcmkONERROR(gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
-        acquired = gcvTRUE;
-
 #if gcdPAGED_MEMORY_CACHEABLE
         /* Force video memory cacheable. */
         Cacheable = gcvTRUE;
@@ -1868,11 +1828,11 @@
 
         /* Return hardware address. */
         *Address = Node->Virtual.addresses[Kernel->core];
-
-        /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
     }
 
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
+
     /* Success. */
     gcmkFOOTER_ARG("*Address=%08x", *Address);
     return gcvSTATUS_OK;
@@ -1918,7 +1878,7 @@
     if (acquired)
     {
         /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
     }
 
     /* Return the status. */
@@ -1976,6 +1936,11 @@
     gcmkHEADER_ARG("Node=0x%x Type=%d *Asynchroneous=%d",
                    Node, Type, gcmOPT_VALUE(Asynchroneous));
 
+    /* Grab the mutex. */
+    gcmkONERROR(gckOS_AcquireMutex(Kernel->os, Kernel->vidmemMutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+
     /* Verify the arguments. */
     if ((Node == gcvNULL)
     ||  (Node->VidMem.memory == gcvNULL)
@@ -2032,7 +1997,11 @@
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                            "Deferred-freeing Node 0x%x.",
                            Node);
-            gcmkONERROR(gckVIDMEM_Free(Node));
+
+            gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
+            acquired = gcvFALSE;
+
+            gcmkONERROR(gckVIDMEM_Free(Kernel, Node));
         }
     }
 
@@ -2052,12 +2021,6 @@
         os = Kernel->os;
         gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
 
-        /* Grab the mutex. */
-        gcmkONERROR(
-            gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
-
-        acquired = gcvTRUE;
-
         if (Asynchroneous == gcvNULL)
         {
             if (Node->Virtual.lockeds[Kernel->core] == 0)
@@ -2119,14 +2082,14 @@
                                                         Node->Virtual.physical,
                                                         Node->Virtual.bytes));
 
+                    /* Destroy the gcuVIDMEM_NODE union. */
+                    gcmkVERIFY_OK(gckVIDMEM_DestroyVirtual(Node));
+
                     /* Release mutex before node is destroyed */
-                    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+                    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
 
                     acquired = gcvFALSE;
 
-                    /* Destroy the gcuVIDMEM_NODE union. */
-                    gcmkVERIFY_OK(gckVIDMEM_DestroyVirtual(Node));
-
                     /* Node has been destroyed, so we should not touch it any more */
                     gcmkFOOTER();
                     return gcvSTATUS_OK;
@@ -2234,10 +2197,12 @@
             /* Schedule the surface to be unlocked. */
             *Asynchroneous = gcvTRUE;
         }
+    }
 
+    if (acquired)
+    {
         /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
-
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
         acquired = gcvFALSE;
     }
 
@@ -2255,7 +2220,7 @@
     if (acquired)
     {
         /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
     }
 
     /* Return the status. */
Index: drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c	(revision 1734)
@@ -211,6 +211,11 @@
 
     /* workqueue for os timer. */
     struct workqueue_struct *   workqueue;
+
+    int                         gpu_clk_on[3];
+    struct mutex                gpu_clk_mutex;
+
+    gctPOINTER                  vidmemMutex;
 };
 
 typedef struct _gcsSIGNAL * gcsSIGNAL_PTR;
@@ -1111,6 +1116,10 @@
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
+    mutex_init(&os->gpu_clk_mutex);
+
+    gcmkONERROR(gckOS_CreateMutex(os, &os->vidmemMutex));
+
     /* Return pointer to the gckOS object. */
     *Os = os;
 
@@ -1234,6 +1243,9 @@
     /* Destroy debug lock mutex. */
     gcmkVERIFY_OK(gckOS_DeleteMutex(Os, Os->debugLock));
 
+    /* Destroy video memory mutex. */
+    gcmkVERIFY_OK(gckOS_DeleteMutex(Os, Os->vidmemMutex));
+
     /* Wait for all works done. */
     flush_workqueue(Os->workqueue);
 
@@ -2425,7 +2437,17 @@
     gcmkVERIFY_ARGUMENT(Address < Os->device->requestedRegisterMemSizes[Core]);
     gcmkVERIFY_ARGUMENT(Data != gcvNULL);
 
+    if(Address != 0x10) mutex_lock(&Os->gpu_clk_mutex);
+    BUG_ON(!Os->gpu_clk_on[Core]);
+
+    if(Address)
+    {
+        gctUINT32 AQHiClockControl = readl((gctUINT8 *)Os->device->registerBases[Core]);
+        BUG_ON((AQHiClockControl & 0x3) == 0x3);
+    }
+
     *Data = readl((gctUINT8 *)Os->device->registerBases[Core] + Address);
+    if(Address != 0x10) mutex_unlock(&Os->gpu_clk_mutex);
 
     /* Success. */
     gcmkFOOTER_ARG("*Data=0x%08x", *Data);
@@ -2475,7 +2497,17 @@
 
     gcmkVERIFY_ARGUMENT(Address < Os->device->requestedRegisterMemSizes[Core]);
 
+    mutex_lock(&Os->gpu_clk_mutex);
+    BUG_ON(!Os->gpu_clk_on[Core]);
+
+    if(Address)
+    {
+        gctUINT32 AQHiClockControl = readl((gctUINT8 *)Os->device->registerBases[Core]);
+        BUG_ON((AQHiClockControl & 0x3) == 0x3);
+    }
+
     writel(Data, (gctUINT8 *)Os->device->registerBases[Core] + Address);
+    mutex_unlock(&Os->gpu_clk_mutex);
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -7020,6 +7052,7 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
     if (Clock == gcvTRUE) {
         if (oldClockState == gcvFALSE) {
+            mutex_lock(&Os->gpu_clk_mutex);
             switch (Core) {
             case gcvCORE_MAJOR:
                 clk_enable(clk_3dcore);
@@ -7037,9 +7070,12 @@
             default:
                 break;
             }
+            Os->gpu_clk_on[Core] = 1;
+            mutex_unlock(&Os->gpu_clk_mutex);
         }
     } else {
         if (oldClockState == gcvTRUE) {
+            mutex_lock(&Os->gpu_clk_mutex);
             switch (Core) {
             case gcvCORE_MAJOR:
                 if (cpu_is_mx6q())
@@ -7057,11 +7093,14 @@
             default:
                 break;
             }
+            Os->gpu_clk_on[Core] = 0;
+            mutex_unlock(&Os->gpu_clk_mutex);
         }
     }
 #else
     if (Clock == gcvTRUE) {
         if (oldClockState == gcvFALSE) {
+            mutex_lock(&Os->gpu_clk_mutex);
             switch (Core) {
             case gcvCORE_MAJOR:
                 clk_prepare(clk_3dcore);
@@ -7086,9 +7125,12 @@
             default:
                 break;
             }
+            Os->gpu_clk_on[Core] = 1;
+            mutex_unlock(&Os->gpu_clk_mutex);
         }
     } else {
         if (oldClockState == gcvTRUE) {
+            mutex_lock(&Os->gpu_clk_mutex);
             switch (Core) {
             case gcvCORE_MAJOR:
                 clk_disable(clk_3dshader);
@@ -7113,6 +7155,8 @@
             default:
                 break;
             }
+            Os->gpu_clk_on[Core] = 0;
+            mutex_unlock(&Os->gpu_clk_mutex);
         }
     }
 #endif
@@ -8696,6 +8740,20 @@
     return gcvSTATUS_OK;
 }
 
+gceSTATUS
+gckOS_GetVideoMemoryMutex(
+    IN gckOS Os,
+    OUT gctPOINTER *Mutex
+    )
+{
+    gcmkHEADER_ARG("Mutex=x%X", Mutex);
+
+    *Mutex = Os->vidmemMutex;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 #if gcdANDROID_NATIVE_FENCE_SYNC
 
 gceSTATUS
Index: drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c	(revision 1734)
@@ -1,7 +1,7 @@
 /****************************************************************************
 *
 *    Copyright (C) 2005 - 2013 by Vivante Corp.
-*    Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+*    Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -37,6 +37,9 @@
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
 #    include <linux/resmem_account.h>
+#endif
+
+#ifdef CONFIG_GPU_LOW_MEMORY_KILLER
 #    include <linux/kernel.h>
 #    include <linux/mm.h>
 #    include <linux/oom.h>
@@ -893,9 +896,11 @@
         /* Reset the base address */
         device->baseAddress = 0;
     }
+#ifdef CONFIG_GPU_LOW_MEMORY_KILLER
+    task_free_register(&task_nb);
+#endif
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
-    task_free_register(&task_nb);
     viv_gpu_resmem_handler.data = device->kernels[gcvCORE_MAJOR];
     register_reserved_memory_account(&viv_gpu_resmem_handler);
 #endif
@@ -980,8 +985,11 @@
 {
     gcmkHEADER();
 
+#ifdef CONFIG_GPU_LOW_MEMORY_KILLER
+    task_free_unregister(&task_nb);
+#endif
+
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
-    task_free_unregister(&task_nb);
     unregister_reserved_memory_account(&viv_gpu_resmem_handler);
 #endif
 
Index: drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
===================================================================
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c	(revision 513)
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c	(revision 1734)
@@ -509,6 +509,36 @@
          Identity->varyingsCount -= 1;
      }
 
+    Identity->chip2DControl = 0;
+    if (Identity->chipModel == gcv320)
+    {
+        gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Os,
+                                 Core,
+                                 0x0002C,
+                                 &data));
+
+        if ((data != 33956864) &&
+            ((Identity->chipRevision == 0x5007) ||
+            (Identity->chipRevision == 0x5220)))
+        {
+            Identity->chip2DControl |= 0xFF &
+                (Identity->chipRevision == 0x5220 ? 8 :
+                (Identity->chipRevision == 0x5007 ? 12 : 0));
+        }
+
+        if  (Identity->chipRevision == 0x5007)
+        {
+            /* Disable splitting rectangle. */
+            Identity->chip2DControl |= 0x100;
+
+            /* Enable 2D Flush. */
+            Identity->chip2DControl |= 0x200;
+        }
+    }
+
     /* Success. */
     gcmkFOOTER();
     return gcvSTATUS_OK;
@@ -1318,33 +1348,22 @@
         gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00414, axi_ot));
     }
 
-    if ((Hardware->identity.chipModel == gcv320)
-        && ((Hardware->identity.chipRevision == 0x5007)
-        || (Hardware->identity.chipRevision == 0x5220)))
+    if (Hardware->identity.chip2DControl & 0xFF)
     {
 		gctUINT32 data;
 
         gcmkONERROR(
             gckOS_ReadRegisterEx(Hardware->os,
                                  Hardware->core,
-                                 0x0002C,
+                                 0x00414,
                                  &data));
-        if (data != 33956864)
-        {
-            gcmkONERROR(
-                gckOS_ReadRegisterEx(Hardware->os,
-                                     Hardware->core,
-                                     0x00414,
-                                     &data));
+        data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (Hardware->identity.chip2DControl & 0xFF) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)));
 
-            data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (Hardware->identity.chipRevision == 0x5220 ? 8 : (Hardware->identity.chipRevision == 0x5007 ? 16 : 0)) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)));
-
-            gcmkONERROR(
-                gckOS_WriteRegisterEx(Hardware->os,
-                                      Hardware->core,
-                                      0x00414,
-                                      data));
-        }
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  0x00414,
+                                  data));
     }
 
     /* Update GPU AXI cache atttribute. */
@@ -1553,6 +1572,7 @@
     Identity->bufferSize             = Hardware->identity.bufferSize;
     Identity->varyingsCount          = Hardware->identity.varyingsCount;
     Identity->superTileMode          = Hardware->identity.superTileMode;
+    Identity->chip2DControl          = Hardware->identity.chip2DControl;
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -6539,6 +6559,17 @@
     dmaAddress1 = dmaAddress2 =
     dmaLow      = dmaHigh     = 0;
 
+    gckOS_Delay(gcvNULL, gcdPOWEROFF_TIMEOUT);
+
+    if (Hardware->chipPowerState != gcvPOWER_ON
+     && Hardware->chipPowerState != gcvPOWER_IDLE
+    )
+    {
+        gcmkPRINT("[galcore]: Can't dump when GPU is power off or clock off.");
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
     /* Verify whether DMA is running. */
     gcmkONERROR(_VerifyDMA(
         os, core, &dmaAddress1, &dmaAddress2, &dmaState1, &dmaState2
Index: drivers/thermal/imx_thermal.c
===================================================================
diff --git a/drivers/thermal/imx_thermal.c b/drivers/thermal/imx_thermal.c
--- a/drivers/thermal/imx_thermal.c	(revision 513)
+++ b/drivers/thermal/imx_thermal.c	(revision 1734)
@@ -55,14 +55,22 @@
  * It defines the temperature in millicelsius for passive trip point
  * that will trigger cooling action when crossed.
  */
+#ifdef CONFIG_ARCH_ADVANTECH
+#define IMX_TEMP_PASSIVE                190000
+#else
 #define IMX_TEMP_PASSIVE		85000
+#endif
 #define IMX_TEMP_PASSIVE_COOL_DELTA	10000
 
 /*
  * The maximum die temperature on imx parts is 105C, let's give some cushion
  * for noise and possible temperature rise between measurements.
  */
+#ifdef CONFIG_ARCH_ADVANTECH
+#define IMX_TEMP_CRITICAL               200000
+#else
 #define IMX_TEMP_CRITICAL		100000
+#endif
 
 #define IMX_POLLING_DELAY		2000 /* millisecond */
 #define IMX_PASSIVE_DELAY		1000
Index: drivers/input/apm-power.c
===================================================================
diff --git a/drivers/input/apm-power.c b/drivers/input/apm-power.c
--- a/drivers/input/apm-power.c	(revision 513)
+++ b/drivers/input/apm-power.c	(revision 1734)
@@ -20,12 +20,26 @@
 #include <linux/pm.h>
 #include <linux/apm-emulation.h>
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#include <linux/timer.h>
+long timer_diff,timer_1,timer_2;
+char suspend_key_flag = 0;
+extern char board_type[12];
+#endif
 static void system_power_event(unsigned int keycode)
 {
 	switch (keycode) {
 	case KEY_SUSPEND:
+#ifdef CONFIG_ARCH_ADVANTECH
+		if (!suspend_key_flag) {
+			apm_queue_event(APM_USER_SUSPEND);
+			pr_info("Requesting system suspend...\n");
+			suspend_key_flag = 1;
+		}
+#else
 		apm_queue_event(APM_USER_SUSPEND);
-		pr_info("Requesting system suspend...\n");
+		pr_info("Requesting system suspend...\n")
+#endif
 		break;
 	default:
 		break;
@@ -36,10 +50,38 @@
 			   unsigned int code, int value)
 {
 	/* only react on key down events */
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (strcmp(board_type, "ROM-5420") && strcmp(board_type, "ROM-3420")) {
+		if (value != 1)
+			return;
+	}
+#else
 	if (value != 1)
 		return;
-
+#endif
 	switch (type) {
+#ifdef CONFIG_ARCH_ADVANTECH
+	case EV_KEY:
+                pr_info("EV_PWR:value[%d],type[%d],code[%d]\n",value,type,code);
+                if (code == KEY_SUSPEND) {
+                        if (value) 
+                                timer_1 = jiffies;
+                        else {
+                                timer_2 = jiffies;
+                                if (timer_1 > timer_2)
+                                        timer_diff = timer_1 - timer_2;
+                                else
+                                        timer_diff = timer_2 - timer_1;
+                                if (timer_diff < 100 ) {
+                                        if (!suspend_key_flag) {
+                                                system_power_event(code);
+                                                suspend_key_flag = 1;
+                                        }
+                                }
+                        }
+                }
+		break;
+#endif	
 	case EV_PWR:
 		system_power_event(code);
 		break;
@@ -95,6 +137,12 @@
 		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
 		.evbit = { BIT_MASK(EV_PWR) },
 	},
+#ifdef CONFIG_ARCH_ADVANTECH
+        {
+                .flags = INPUT_DEVICE_ID_MATCH_KEYBIT,
+                .evbit = { BIT_MASK(EV_KEY) },
+        },
+#endif
 	{ },
 };
 
Index: drivers/watchdog/Makefile
===================================================================
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
--- a/drivers/watchdog/Makefile	(revision 513)
+++ b/drivers/watchdog/Makefile	(revision 1734)
@@ -171,3 +171,5 @@
 obj-$(CONFIG_WM8350_WATCHDOG) += wm8350_wdt.o
 obj-$(CONFIG_MAX63XX_WATCHDOG) += max63xx_wdt.o
 obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
+
+obj-$(CONFIG_ADVANTECH_RISC_WDT) += watchdog_advantech.o
Index: drivers/watchdog/Kconfig
===================================================================
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
--- a/drivers/watchdog/Kconfig	(revision 513)
+++ b/drivers/watchdog/Kconfig	(revision 1734)
@@ -367,6 +367,17 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called imx2_wdt.
 
+config ADVANTECH_RISC_WDT
+	tristate "ADVANTECH Watchdog"
+	depends on ARCH_MXC
+	help
+	  This is the driver for the hardware watchdog
+	  If you have one of these processors and wish to have
+	  watchdog support enabled, say Y, otherwise say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called adv_wdt.
+
 config UX500_WATCHDOG
 	tristate "ST-Ericsson Ux500 watchdog"
 	depends on MFD_DB8500_PRCMU
Index: drivers/watchdog/watchdog_advantech.c
===================================================================
diff --git a/drivers/watchdog/watchdog_advantech.c b/drivers/watchdog/watchdog_advantech.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/watchdog/watchdog_advantech.c	(revision 1734)
@@ -0,0 +1,477 @@
+/*
+ * Advantech Watchdog driver
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/watchdog.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+
+#define ADV_WDT_WCR		0x00		/* Control Register */
+#define ADV_WDT_WCR_WT		(0xFF << 8)	/* -> Watchdog Timeout Field */
+#define ADV_WDT_WCR_WRE	(1 << 3)	/* -> WDOG Reset Enable */
+#define ADV_WDT_WCR_WDE	(1 << 2)	/* -> Watchdog Enable */
+#define ADV_WDT_WCR_WDZST	(1 << 0)	/* -> Watchdog timer Suspend */
+
+#define ADV_WDT_WSR		0x02		/* Service Register */
+#define ADV_WDT_SEQ1		0x5555		/* -> service sequence 1 */
+#define ADV_WDT_SEQ2		0xAAAA		/* -> service sequence 2 */
+
+#define ADV_WDT_WRSR		0x04		/* Reset Status Register */
+#define ADV_WDT_WRSR_TOUT	(1 << 1)	/* -> Reset due to Timeout */
+
+#define ADV_WDT_MAX_TIME	65536
+#define ADV_WDT_DEFAULT_TIME	60		/* in seconds */
+
+#define WDOG_SEC_TO_COUNT(s)	(s * 10) //Time unite: 100ms -> 1s
+
+#define ADV_WDT_STATUS_OPEN	0
+#define ADV_WDT_STATUS_STARTED	1
+#define ADV_WDT_EXPECT_CLOSE	2
+
+#define DRIVER_NAME "adv-wdt-i2c"
+
+#define REG_WDT_WATCHDOG_TIME_OUT	0x15
+#define REG_WDT_POWER_OFF_TIME 		0x16
+#define REG_WDT_INT_PRE_TIME 			0x17
+#define REG_WDT_REMAIN_TIME_OUT		0x25
+#define REG_WDT_REMAIN_PRE_TIME 	0x26
+#define REG_WDT_VERSION 					0x27
+#define REG_WDT_POWER_BTN_MODE 		0x28
+
+static int gpio_wdt_en;
+static int gpio_wdt_ping;
+
+struct i2c_client *adv_client;
+
+static struct {
+	struct clk *clk;
+	unsigned timeout;
+	unsigned remain_time;
+	unsigned long status;
+	int wdt_ping_status;
+	char version[2];
+} adv_wdt;
+
+static struct miscdevice adv_wdt_miscdev;
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+
+module_param(nowayout, bool, 0);
+
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
+				__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+
+static unsigned timeout = ADV_WDT_DEFAULT_TIME;
+
+module_param(timeout, uint, 0);
+
+MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds (default="
+				__MODULE_STRING(ADV_WDT_DEFAULT_TIME) ")");
+
+struct watchdog_info adv_wdt_info = {
+	.identity = "Advantech watchdog",
+	.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE,
+	.firmware_version = 0,
+};
+
+static int adv_wdt_i2c_write_reg(struct i2c_client *client, u8 reg, void *buf, size_t len)
+{
+	u8 val[1 + len];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = sizeof(val),
+			.buf = val,
+		}
+	};
+
+	val[0] = reg;
+	memcpy(&val[1], buf, len);
+
+	if (i2c_transfer(client->adapter, msg, 1) != 1) {
+		dev_err(&client->dev, "adv_wdt_i2c_write: i2c transfer failed\n");
+		return -EIO;
+	}
+	
+	msleep(100);
+	return 0;
+}
+
+static int adv_wdt_i2c_read_reg(struct i2c_client *client, u8 reg, void *buf, size_t len)
+{
+	struct i2c_msg msg[2] = {
+		{
+			.addr	= client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	if (i2c_transfer(client->adapter, msg, 2) != 2) {
+		dev_err(&client->dev, "adv_wdt_i2c_read: i2c transfer failed\n");
+		return -EIO;
+	}
+	
+	msleep(100);
+	return 0;
+}
+
+int adv_wdt_i2c_set_timeout(struct i2c_client *client, int val)
+{
+	int ret = 0;
+	
+	val = WDOG_SEC_TO_COUNT(val);
+	ret = adv_wdt_i2c_write_reg(client, REG_WDT_WATCHDOG_TIME_OUT, &val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+int adv_wdt_i2c_read_timeout(struct i2c_client *client, int *val)
+{
+	int ret = 0;
+	
+	ret = adv_wdt_i2c_read_reg(client, REG_WDT_WATCHDOG_TIME_OUT, val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+int adv_wdt_i2c_read_remain_time(struct i2c_client *client, int *val)
+{
+	int ret = 0;
+	
+	ret = adv_wdt_i2c_read_reg(client, REG_WDT_REMAIN_TIME_OUT, val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+int adv_wdt_i2c_read_version(struct i2c_client *client, int *val)
+{
+	int ret = 0;
+	
+	ret = adv_wdt_i2c_read_reg(client, REG_WDT_VERSION, val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+static inline void adv_wdt_ping(void)
+{
+	msleep(800);
+	adv_wdt.wdt_ping_status= !adv_wdt.wdt_ping_status;
+	gpio_set_value(gpio_wdt_ping, adv_wdt.wdt_ping_status);
+	msleep(100);
+	//printk("adv_wdt_ping:%x\n", adv_wdt.wdt_ping_status);
+	//printk("wdt_en_ping:%x\n", gpio_get_value(gpio_wdt_en));
+}
+
+static void adv_wdt_start(void)
+{
+	if (!test_and_set_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status)) 
+	{
+		/* at our first start we enable clock and do initialisations */
+		gpio_set_value(gpio_wdt_en, 1);
+	} 
+
+	/* Watchdog is enabled - time to reload the timeout value */
+	adv_wdt_ping();
+}
+
+static void adv_wdt_stop(void)
+{
+	adv_wdt_ping();
+
+	/* we don't need a clk_disable, it cannot be disabled once started.
+	 * We use a timer to ping the watchdog while /dev/watchdog is closed */
+	gpio_set_value(gpio_wdt_en, 0);
+}
+
+static int adv_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(ADV_WDT_STATUS_OPEN, &adv_wdt.status))
+		return -EBUSY;
+	adv_wdt_start();
+	return nonseekable_open(inode, file);
+}
+
+static int adv_wdt_close(struct inode *inode, struct file *file)
+{
+	if (test_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status) && !nowayout)
+		adv_wdt_stop();
+	else {
+		dev_crit(adv_wdt_miscdev.parent,
+			"Unexpected close: Expect reboot!\n");
+		adv_wdt_ping();
+	}
+
+	clear_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status);
+	clear_bit(ADV_WDT_STATUS_OPEN, &adv_wdt.status);
+	clear_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status);
+	return 0;
+}
+
+static long adv_wdt_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int new_value = 0;
+//	u16 val;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		adv_wdt_ping();
+		return copy_to_user(argp, &adv_wdt_info,
+			sizeof(struct watchdog_info)) ? -EFAULT : 0;
+
+	case WDIOC_GETSTATUS:
+		return put_user(adv_wdt.status, p);
+/*
+	case WDIOC_GETBOOTSTATUS:
+		val = __raw_readw(adv_wdt.base + ADV_WDT_WRSR);
+		new_value = val & ADV_WDT_WRSR_TOUT ? WDIOF_CARDRESET : 0;
+		return put_user(new_value, p);
+*/
+	case WDIOC_KEEPALIVE:
+		adv_wdt_ping();
+		return 0;
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_value, p))
+			return -EFAULT;
+		if ((new_value < 1) || (new_value > ADV_WDT_MAX_TIME))
+		{
+			return -EINVAL;
+		}
+		adv_wdt.timeout = new_value;
+		adv_wdt_i2c_set_timeout(adv_client, adv_wdt.timeout);
+		adv_wdt_ping();
+	
+		/* Fallthrough to return current value */
+	case WDIOC_GETTIMEOUT:
+		adv_wdt_i2c_read_timeout(adv_client, &adv_wdt.timeout);
+		//printk("WDIOC_GETTIMEOUT:%x\n", adv_wdt.timeout);
+		return put_user(adv_wdt.timeout & 0xFFFF, p);
+
+	case WDIOC_GETTIMELEFT:
+		adv_wdt_i2c_read_remain_time(adv_client, &adv_wdt.remain_time);
+		//printk("WDIOC_GETTIMELEFT:%x\n", adv_wdt.remain_time);
+		return put_user(adv_wdt.remain_time & 0xFFFF, p);
+	
+	default:
+		return -ENOTTY;
+	}
+}
+
+static ssize_t adv_wdt_write(struct file *file, const char __user *data,
+						size_t len, loff_t *ppos)
+{
+	size_t i;
+	char c;
+
+	if (len == 0)	/* Can we see this even ? */
+		return 0;
+
+	clear_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status);
+	/* scan to see whether or not we got the magic character */
+	for (i = 0; i != len; i++) {
+		if (get_user(c, data + i))
+			return -EFAULT;
+		if (c == 'V')
+			set_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status);
+	}
+
+	adv_wdt_ping();
+	
+	return len;
+}
+
+static const struct file_operations adv_wdt_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.unlocked_ioctl = adv_wdt_ioctl,
+	.open = adv_wdt_open,
+	.release = adv_wdt_close,
+	.write = adv_wdt_write,
+};
+
+static struct miscdevice adv_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &adv_wdt_fops,
+};
+
+static int adv_wdt_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret;
+	int tmp_version;
+	struct device_node *np = client->dev.of_node;
+	enum of_gpio_flags flags;
+	
+	if (!np)
+	{
+		return -ENODEV;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+	{
+		return -ENODEV;
+	}	
+
+	i2c_set_clientdata(client, &adv_wdt);
+
+	adv_client = client;
+	//Setting GPIO
+	gpio_wdt_en = of_get_named_gpio_flags(np, "wdt-en", 0, &flags);
+	if (!gpio_is_valid(gpio_wdt_en))
+		return -ENODEV;	
+
+	ret = devm_gpio_request_one(&client->dev, gpio_wdt_en,
+				GPIOF_OUT_INIT_LOW, "adv_wdt.wdt_en");
+	if (ret < 0) {
+		dev_err(&client->dev, "request gpio failed: %d\n", ret);
+		return ret;
+	}
+	gpio_direction_output(gpio_wdt_en, flags);
+	
+	gpio_wdt_ping = of_get_named_gpio_flags(np, "wdt-ping", 0, &flags);
+	if (!gpio_is_valid(gpio_wdt_ping))
+		return -ENODEV;	
+
+	ret = devm_gpio_request_one(&client->dev, gpio_wdt_ping, 
+				GPIOF_OUT_INIT_LOW, "adv_wdt.wdt_ping");
+	if (ret < 0) {
+		dev_err(&client->dev, "request gpio failed: %d\n", ret);
+		return ret;
+	}
+	adv_wdt.wdt_ping_status=flags;
+	gpio_direction_output(gpio_wdt_ping, !flags);
+	msleep(10);
+	gpio_direction_output(gpio_wdt_ping, flags);
+
+	adv_wdt.timeout = clamp_t(unsigned, timeout, 1, ADV_WDT_MAX_TIME);
+	if (adv_wdt.timeout != timeout)
+		dev_warn(&client->dev, "Initial timeout out of range! "
+			"Clamped from %u to %u\n", timeout, adv_wdt.timeout);
+
+	adv_wdt_miscdev.parent = &client->dev;
+	ret = misc_register(&adv_wdt_miscdev);
+	if (ret)
+	{
+		pr_err("cannot register miscdev on minor=%d (err=%d)\n",
+	     WATCHDOG_MINOR, ret);
+		goto fail;
+	}
+	
+	ret = adv_wdt_i2c_read_version(client, &tmp_version);
+	
+	if (ret == 0 )
+	{
+     adv_wdt.version[0]= (tmp_version & 0xFF00) >> 8;
+     adv_wdt.version[1]= tmp_version & 0xFF;
+     adv_wdt_info.firmware_version = (int)(adv_wdt.version[1] - '0') * 10 + (int)(adv_wdt.version[0] - '0');
+	}
+	
+	dev_info(&client->dev,
+						"Advantech Watchdog Timer enabled. timeout=%ds (nowayout=%d), Ver.%d\n",
+						adv_wdt.timeout, nowayout, adv_wdt_info.firmware_version);
+	return 0;
+
+fail:
+	adv_wdt_miscdev.parent = NULL;
+	return ret;
+}
+
+static int __exit adv_wdt_i2c_remove(struct i2c_client *client)
+{
+	misc_deregister(&adv_wdt_miscdev);
+
+	if (test_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status))
+	{	
+		gpio_set_value(gpio_wdt_en, 0);
+		dev_crit(adv_wdt_miscdev.parent, "Device removed: Expect reboot!\n");
+	}
+	adv_wdt_miscdev.parent = NULL;
+	return 0;
+}
+
+static void adv_wdt_i2c_shutdown(struct i2c_client *client)
+{
+	if (test_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status)) {
+		/* we are running, we need to delete the timer but will give
+		 * max timeout before reboot will take place */
+		gpio_set_value(gpio_wdt_en, 0);		
+		adv_wdt_i2c_set_timeout(client, ADV_WDT_MAX_TIME);
+		adv_wdt_ping();
+
+		dev_crit(adv_wdt_miscdev.parent,
+			"Device shutdown: Expect reboot!\n");
+	}
+}
+
+static const struct i2c_device_id adv_wdt_i2c_id[] = {
+	{DRIVER_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, adv_wdt_i2c_id);
+
+static const struct of_device_id adv_wdt_i2c_dt_ids[] = {
+	{ .compatible = "fsl,adv-wdt-i2c", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, adv_wdt_i2c_dt_ids);
+
+static struct i2c_driver adv_wdt_i2c_driver = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = adv_wdt_i2c_dt_ids,
+		   },
+	.probe = adv_wdt_i2c_probe,
+	.remove = adv_wdt_i2c_remove,
+	.shutdown	= adv_wdt_i2c_shutdown,
+	.id_table = adv_wdt_i2c_id,
+};
+
+static int __init adv_wdt_i2c_init(void)
+{
+	return i2c_add_driver(&adv_wdt_i2c_driver);
+}
+
+static void __exit adv_wdt_i2c_exit(void)
+{
+	i2c_del_driver(&adv_wdt_i2c_driver);
+}
+
+module_init(adv_wdt_i2c_init);
+module_exit(adv_wdt_i2c_exit);
+
+MODULE_DESCRIPTION("Advantech Watchdog I2C Driver");
+MODULE_LICENSE("GPL");
Index: drivers/video/mxc/Kconfig
===================================================================
diff --git a/drivers/video/mxc/Kconfig b/drivers/video/mxc/Kconfig
--- a/drivers/video/mxc/Kconfig	(revision 513)
+++ b/drivers/video/mxc/Kconfig	(revision 1734)
@@ -18,6 +18,11 @@
 	depends on FB_MXC
 	tristate "Synchronous Panel Framebuffer"
 
+config FB_MXC_SYNC_PANEL_EDID
+	depends on FB_MXC_SYNC_PANEL
+	tristate "VGA Panel EDID Parser"
+	default n
+
 config FB_MXC_LDB
 	tristate "MXC LDB"
 	depends on FB_MXC_SYNC_PANEL
@@ -69,3 +74,7 @@
 	  function.  This function turns backlight density of a
 	  display panel automatically according to the content
 	  shown on the panel.
+
+config FB_MXC_CH7055
+	depends on FB_MXC_SYNC_PANEL
+	tristate "Chrontel CH7055 VGA Interface Chip"
\ No newline at end of file
Index: drivers/video/mxc/ldb.c
===================================================================
diff --git a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
--- a/drivers/video/mxc/ldb.c	(revision 513)
+++ b/drivers/video/mxc/ldb.c	(revision 1734)
@@ -135,6 +135,40 @@
 static int g_ldb_mode;
 
 static struct fb_videomode ldb_modedb[] = {
+#ifdef CONFIG_ARCH_ADVANTECH
+ 	 {
+	 "LDB-XGA", 60, 1024, 768, 15385,
+	 220, 40,
+	 21, 7,
+	 60, 10,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},
+	 {
+	 "LDB-WXGA", 60, 1360, 768, 14148,
+	 158, 1,
+	 14, 1,
+	 1, 1,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},
+	 {
+	 "LDB-1080P60", 60, 1920, 1080, 6734,
+	 148, 88,
+	 36, 4,
+	 44, 5,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_VESA},
+	 {
+	 "LDB-WUXGA", 60, 1920, 1200, 6413,
+	 120, 88,
+	 4, 4,
+	 16, 4,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_VESA},
+#else	
 	{
 	 "LDB-WXGA", 60, 1280, 800, 14065,
 	 40, 40,
@@ -159,6 +193,7 @@
 	 0,
 	 FB_VMODE_NONINTERLACED,
 	 FB_MODE_IS_DETAILED,},
+#endif	 
 };
 static int ldb_modedb_sz = ARRAY_SIZE(ldb_modedb);
 
Index: drivers/video/mxc/mxc_ipuv3_fb.c
===================================================================
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
--- a/drivers/video/mxc/mxc_ipuv3_fb.c	(revision 513)
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c	(revision 1734)
@@ -58,6 +58,11 @@
 
 /* Display port number */
 #define MXCFB_PORT_NUM	2
+
+#ifdef CONFIG_ARCH_ADVANTECH
+char fb_vga_fix_id[30];
+#endif
+
 /*!
  * Structure containing the MXC specific framebuffer information.
  */
@@ -577,6 +582,14 @@
 		}
 	}
 
+	/* overlay should be smaller than BG */
+	if (ovfbi_enable) {
+		if ((mxc_fbi->ovfbi->var.xres > fbi->var.xres) || (mxc_fbi->ovfbi->var.yres > fbi->var.yres)) {
+			mxc_fbi_fg->cur_blank = mxc_fbi_fg->next_blank = FB_BLANK_POWERDOWN;
+			ovfbi_enable = false;
+		}
+	}
+
 	_setup_disp_channel1(fbi);
 	if (ovfbi_enable)
 		_setup_disp_channel1(mxc_fbi->ovfbi);
@@ -1351,6 +1364,7 @@
 				return -EFAULT;
 			ipu_set_csc_coefficients(mxc_fbi->ipu, mxc_fbi->ipu_ch,
 						csc.param);
+			break;
 		}
 	default:
 		retval = -EINVAL;
@@ -1430,6 +1444,9 @@
 			return -EINVAL;
 		if (bg_mxcfbi->cur_blank != FB_BLANK_UNBLANK)
 			return -EINVAL;
+		/* overlay should be smaller than BG */
+		if ((info->var.xres > fbi_tmp->var.xres) || (info->var.yres > fbi_tmp->var.yres))
+			return -EINVAL;			
 	}
 	if (mxc_fbi->cur_blank != FB_BLANK_UNBLANK)
 		return -EINVAL;
@@ -1934,8 +1951,32 @@
 				setting.disp_id, setting.dev_id);
 	}
 
+#ifdef CONFIG_ARCH_ADVANTECH
+  /* dirty! need to fix */
+	if(!strcmp(disp_dev, "lcd"))
+	{
+		char bg0_id[] = "DISP3 BG";
+		char bg1_id[] = "DISP3 BG - DI1";
+		char fg_id[] = "DISP3 FG";
+
+		if (mxcfbi->ipu_di == 0) {
+			bg0_id[4] += mxcfbi->ipu_id;
+			strcpy(fb_vga_fix_id, bg0_id);
+		} else if (mxcfbi->ipu_di == 1) {
+			bg1_id[4] += mxcfbi->ipu_id;
+			strcpy(fb_vga_fix_id, bg1_id);
+		} else { /* Overlay */
+			fg_id[4] += mxcfbi->ipu_id;
+			strcpy(fb_vga_fix_id, fg_id);
+		}
+		printk("*****VGA fb name %s", fb_vga_fix_id);
+	}
+#endif
 	return ret;
 }
+#ifdef CONFIG_ARCH_ADVANTECH
+EXPORT_SYMBOL_GPL(fb_vga_fix_id);
+#endif
 
 /*
  * Parse user specified options (`video=trident:')
@@ -2425,11 +2466,17 @@
 		mxcfbi->ipu_ch_nf_irq = IPU_IRQ_BG_SYNC_NFACK;
 		mxcfbi->ipu_alp_ch_irq = IPU_IRQ_BG_ALPHA_SYNC_EOF;
 		mxcfbi->ipu_ch = MEM_BG_SYNC;
+
+#ifdef CONFIG_ARCH_ADVANTECH
+		/* Unblank all the fb by default */
+		mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_UNBLANK;
+#else
 		/* Unblank the primary fb only by default */
 		if (pdev->id == 0)
 			mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_UNBLANK;
 		else
 			mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_POWERDOWN;
+#endif
 
 		ret = mxcfb_register(fbi);
 		if (ret < 0)
Index: drivers/video/mxc/mxc_hdmi.c
===================================================================
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
--- a/drivers/video/mxc/mxc_hdmi.c	(revision 513)
+++ b/drivers/video/mxc/mxc_hdmi.c	(revision 1734)
@@ -80,6 +80,9 @@
 #define YCBCR422_8BITS		3
 #define XVYCC444            4
 
+#ifdef CONFIG_ARCH_ADVANTECH
+extern char board_type[12];
+#endif
 /*
  * We follow a flowchart which is in the "Synopsys DesignWare Courses
  * HDMI Transmitter Controller User Guide, 1.30a", section 3.1
@@ -875,7 +878,7 @@
 	hdmi_phy_wait_i2c_done(hdmi, 1000);
 }
 
-#if 0
+#ifdef CONFIG_ARCH_ADVANTECH
 static unsigned short hdmi_phy_i2c_read(struct mxc_hdmi *hdmi,
 					unsigned char addr)
 {
@@ -891,7 +894,8 @@
 	data = (msb << 8) | lsb;
 	return data;
 }
-
+#endif
+#if 0
 static int hdmi_phy_i2c_write_verify(struct mxc_hdmi *hdmi, unsigned short data,
 				     unsigned char addr)
 {
@@ -1205,13 +1209,42 @@
 
 	hdmi_phy_i2c_write(hdmi, 0x0000, 0x13);  /* PLLPHBYCTRL */
 	hdmi_phy_i2c_write(hdmi, 0x0006, 0x17);
-	/* RESISTANCE TERM 133Ohm Cfg */
-	hdmi_phy_i2c_write(hdmi, 0x0005, 0x19);  /* TXTERM */
-	/* PREEMP Cgf 0.00 */
-	hdmi_phy_i2c_write(hdmi, 0x800d, 0x09);  /* CKSYMTXCTRL */
-	/* TX/CK LVL 10 */
-	hdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);  /* VLEVCTRL */
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	if((strcmp(board_type, "ROM-3420")==0) || (strcmp(board_type, "ROM-5420")==0) || (strcmp(board_type, "ROM-5421")==0))
+	{
+		if(hdmi->fbi->var.yres == 480)
+		{
+			/* PLL/MPLL Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x1EA0, 0x06);
+			/* PREEMP Cgf 0.00 */
+			hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);  /* CKSYMTXCTRL */
+			/* TX/CK LVL 10 */
+			hdmi_phy_i2c_write(hdmi, 0x02B5, 0x0E);  /* VLEVCTRL */
+			/* RESISTANCE TERM 133Ohm Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x0, 0x19);  /* TXTERM */
+		}
+		else
+		{
+			/* PLL/MPLL Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x0AA0, 0x06);
+			/* PREEMP Cgf 0.00 */
+			hdmi_phy_i2c_write(hdmi, 0x800D, 0x09);  /* CKSYMTXCTRL */
+			/* TX/CK LVL 10 */
+			hdmi_phy_i2c_write(hdmi, 0x00C6, 0x0E);  /* VLEVCTRL */
+			/* RESISTANCE TERM 133Ohm Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x0004, 0x19);  /* TXTERM */
+		}
+	}
+	else
+#endif
+	{
+		/* RESISTANCE TERM 133Ohm Cfg */
+		hdmi_phy_i2c_write(hdmi, 0x0005, 0x19);  /* TXTERM */
+		/* PREEMP Cgf 0.00 */
+		hdmi_phy_i2c_write(hdmi, 0x800d, 0x09);  /* CKSYMTXCTRL */
+		/* TX/CK LVL 10 */
+		hdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);  /* VLEVCTRL */
+	}
 	/* Board specific setting for PHY register 0x09, 0x0e to pass HCT */
 	if (hdmi->phy_config.reg_cksymtx != 0)
 		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_cksymtx, 0x09);
@@ -2356,6 +2389,55 @@
 	return 0;
 }
 
+#ifdef CONFIG_ARCH_ADVANTECH
+static ssize_t mxc_hdmi_show_hdmi_phy_reg(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	unsigned short val = 0;
+
+	val = hdmi_phy_i2c_read(hdmi, 0x19);
+	printk("0x19: 0x%x\n", val);
+
+	val = hdmi_phy_i2c_read(hdmi, 0x09);
+	printk("0x09: 0x%x\n", val);
+
+	val = hdmi_phy_i2c_read(hdmi, 0x0E);
+	printk("0x0E: 0x%x\n", val);
+
+	val = hdmi_phy_i2c_read(hdmi, 0x06);
+	printk("0x06: 0x%x\n", val);
+
+	return strlen(buf);
+}
+static ssize_t mxc_hdmi_stroe_hdmi_phy_reg(struct device * dev, struct device_attribute *attr,
+                             const char * buf, size_t n)
+{
+	      unsigned char addr;
+	      unsigned short val;
+	      struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	      addr = simple_strtol(strsep(&buf, "="), NULL, 16);
+
+	      if(strstr(buf, "?"))//query
+	      {
+	      	val = hdmi_phy_i2c_read(hdmi, addr);
+				  printk("\n0x%x: 0x%x\n", addr, val);
+	      }
+	      else//assign
+	      {
+	      	val = simple_strtol(buf, NULL, 16);
+	      	printk("\naddr 0x%x\n", addr);
+	      	printk("value 0x%x\n", val);
+	      	hdmi_phy_i2c_write(hdmi, val, addr);
+	      }
+        return n;
+}
+
+
+static DEVICE_ATTR(hdmi_phy, 0777, mxc_hdmi_show_hdmi_phy_reg, mxc_hdmi_stroe_hdmi_phy_reg);
+#endif
+
 static void hdmi_init_route(struct mxc_hdmi *hdmi)
 {
 	uint32_t hdmi_mux_setting, reg;
@@ -2625,6 +2707,13 @@
 		dev_warn(&hdmi->pdev->dev,
 			"cound not create sys node for hdcp enable\n");
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_hdmi_phy);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for hdmi_phy\n");
+#endif
+
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 
 	hdmi_inited = true;
Index: drivers/video/mxc/mxc_lcdif.c
===================================================================
diff --git a/drivers/video/mxc/mxc_lcdif.c b/drivers/video/mxc/mxc_lcdif.c
--- a/drivers/video/mxc/mxc_lcdif.c	(revision 513)
+++ b/drivers/video/mxc/mxc_lcdif.c	(revision 1734)
@@ -22,6 +22,287 @@
 
 #include "mxc_dispdrv.h"
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#ifdef CONFIG_FB_MXC_SYNC_PANEL_EDID
+#include <linux/kthread.h>
+#include <video/mxc_edid.h>
+#include <linux/console.h>
+#include <linux/ipu-v3.h>
+
+//extern int enabled_video_mode_ext;
+//extern int solo_display;
+extern char fb_vga_fix_id[30];
+u8 edid[512];
+static struct mxc_edid_cfg edid_cfg;
+static struct fb_info *fbi = NULL;
+static struct task_struct  *task_kthread;
+#define POLLING_WAIT_TIME_MS    3000
+static struct i2c_client *vga_i2c;
+static int vga_i2c_initialized = 0;
+extern const struct fb_videomode mxc_cea_mode[64];
+int first_init_flag = 1;
+
+static const struct fb_videomode xga_mode = {
+	/* 13 1024x768-60 VESA */
+	NULL, 60, 1024, 768, 15384, 160, 24, 29, 3, 136, 6,
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
+};
+
+static const struct fb_videomode sxga_mode = {
+	/* 20 1280x1024-60 VESA */
+	NULL, 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,
+	FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
+};
+
+void vga_edid_rebuild_modelist(void)
+{
+	struct fb_videomode m;
+	const struct fb_videomode *mode;
+	int i;
+
+	console_lock();
+	//Only Destory the old EDID list when video extension is enabled
+	//if (enabled_video_mode_ext || solo_display)
+		fb_destroy_modelist(&fbi->modelist);
+
+	for (i = 0; i < fbi->monspecs.modedb_len; i++)
+	{
+		//not support interface display and bitrate over 170Mhz
+		if (!(fbi->monspecs.modedb[i].vmode & FB_VMODE_INTERLACED) && (fbi->monspecs.modedb[i].pixclock > 5882))
+		{
+			/*
+			printk( "Added mode %d:", i);
+			printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				fbi->monspecs.modedb[i].xres,
+				fbi->monspecs.modedb[i].yres,
+				fbi->monspecs.modedb[i].refresh,
+				fbi->monspecs.modedb[i].vmode,
+				fbi->monspecs.modedb[i].flag);
+			*/
+			fb_add_videomode(&fbi->monspecs.modedb[i], &fbi->modelist);
+		}
+	}
+	console_unlock();
+
+	fb_var_to_videomode(&m, &fbi->var);
+
+	mode = fb_find_nearest_mode(&m, &fbi->modelist);
+
+	if(!mode)
+	{
+		printk("%s: could not find mode in modelist\n", __func__);
+	}
+	else if (fb_mode_is_equal(&m, mode))
+	{
+		printk("vga: video mode is same as previous\n");
+	}
+	else
+	{
+		fb_videomode_to_var(&fbi->var, mode);
+
+		fbi->var.activate |= FB_ACTIVATE_FORCE;
+		console_lock();
+		fbi->flags |= FBINFO_MISC_USEREVENT;
+		fb_set_var(fbi, &fbi->var);
+		fbi->flags &= ~FBINFO_MISC_USEREVENT;
+		console_unlock();
+	}
+}
+
+void vga_default_modelist(void)
+{
+	const struct fb_videomode *temp_mode;
+	struct fb_videomode m;
+	const struct fb_videomode *mode;
+	int i;
+
+	console_lock();
+	//Only Destory the old EDID list when video extension is enabled
+	//if (enabled_video_mode_ext || solo_display)
+		fb_destroy_modelist(&fbi->modelist);
+
+	/*Add all no interlaced CEA mode to default modelist */
+	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
+		temp_mode = &mxc_cea_mode[i];
+		if (!(temp_mode->vmode & FB_VMODE_INTERLACED) && (temp_mode->pixclock > 5882))
+		{
+			/*
+			printk( "Added default mode %d:", i);
+			printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				temp_mode->xres,
+				temp_mode->yres,
+				temp_mode->refresh,
+				temp_mode->vmode,
+				temp_mode->flag);
+			*/
+			fb_add_videomode(temp_mode, &fbi->modelist);
+		}
+	}
+
+	/*Add XGA and SXGA to default modelist */
+	fb_add_videomode(&xga_mode, &fbi->modelist);
+
+	/*
+	printk( "Added default mode XGA:");
+	printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				xga_mode.xres,
+				xga_mode.yres,
+				xga_mode.refresh,
+				xga_mode.vmode,
+				xga_mode.flag);
+	*/
+
+	fb_add_videomode(&sxga_mode, &fbi->modelist);
+
+	/*
+	printk( "Added default mode SXGA:");
+	printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				sxga_mode.xres,
+				sxga_mode.yres,
+				sxga_mode.refresh,
+				sxga_mode.vmode,
+				sxga_mode.flag);
+	*/
+
+	console_unlock();
+
+	fb_var_to_videomode(&m, &fbi->var);
+	mode = fb_find_nearest_mode(&m, &fbi->modelist);
+
+	if(!mode)
+	{
+		printk("%s: could not find mode in modelist\n", __func__);
+	}
+	else if (fb_mode_is_equal(&m, mode))
+	{
+		printk("vga: video mode is same as previous\n");
+	}
+	else
+	{
+		fb_videomode_to_var(&fbi->var, mode);
+
+		fbi->var.activate |= FB_ACTIVATE_FORCE;
+		console_lock();
+		fbi->flags |= FBINFO_MISC_USEREVENT;
+		fb_set_var(fbi, &fbi->var);
+		fbi->flags &= ~FBINFO_MISC_USEREVENT;
+		console_unlock();
+	}
+}
+
+static void vga_edid_work(void)
+{
+	int wake_up_flag = 0;
+	wait_queue_head_t wait;
+	init_waitqueue_head(&wait);
+
+	while(1)
+	{
+		int i, j, ret;
+		u8 edid_old[512];
+
+		for (i = 0; i < num_registered_fb; i++)
+		{
+			if (strcmp(registered_fb[i]->fix.id, fb_vga_fix_id) == 0)
+			{
+				fbi = registered_fb[i];
+
+				/* back up edid  */
+				memcpy(edid_old, edid, 512);
+
+				ret = mxc_edid_read(vga_i2c->adapter, vga_i2c->addr, edid, &edid_cfg, fbi);
+
+				if (ret < 0)
+				{
+					memcpy(edid, edid_old, 512);
+					//printk("vga: read edid failed\n");
+					if(first_init_flag) {
+						vga_default_modelist();
+					}
+				}
+				else if(!memcmp(edid_old, edid, 512))
+				{
+					//printk("vga: same edid\n");
+				}
+				else if(fbi->monspecs.modedb_len == 0)
+				{
+					printk("vga:no modes read from edid\n");
+				}
+				else
+				{
+					/* receive new edid */
+					printk("vga: new edid\n");
+					/*
+					for (j = 0; j < 512/16; j++)
+					{
+						for (i = 0; i < 16; i++)
+						printk("0x%02X ", edid[j*16 + i]);
+						printk("\n");
+					}
+					*/
+					vga_edid_rebuild_modelist();
+				}
+
+				if(first_init_flag) {
+					first_init_flag = 0;
+				}
+			}
+		}
+
+		wait_event_interruptible_timeout(wait, wake_up_flag == 1, msecs_to_jiffies(POLLING_WAIT_TIME_MS));
+	}
+}
+
+static int mxc_vga_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))
+		return -ENODEV;
+	printk("**********mxc_vga_i2c_probe\n");
+	vga_i2c = client;
+	vga_i2c_initialized = 1;
+
+	return 0;
+}
+
+static int mxc_vga_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id mxc_vga_i2c_id[] = {
+	{ "mxc_vga_i2c", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, mxc_vga_i2c_id);
+
+static struct i2c_driver mxc_vga_i2c_driver = {
+	.driver = {
+		   .name = "mxc_vga_i2c",
+	},
+	.probe = mxc_vga_i2c_probe,
+	.remove = mxc_vga_i2c_remove,
+	.id_table = mxc_vga_i2c_id,
+};
+
+static int __init mxc_vga_i2c_init(void)
+{
+	return i2c_add_driver(&mxc_vga_i2c_driver);
+}
+
+static void __exit mxc_vga_i2c_exit(void)
+{
+	i2c_del_driver(&mxc_vga_i2c_driver);
+}
+
+module_init(mxc_vga_i2c_init);
+module_exit(mxc_vga_i2c_exit);
+#endif
+#endif
+
+
 struct mxc_lcd_platform_data {
 	u32 default_ifmt;
 	u32 ipu_id;
@@ -72,6 +353,14 @@
 		setting->if_fmt = plat_data->default_ifmt;
 	}
 
+#ifdef CONFIG_FB_MXC_SYNC_PANEL_EDID
+	task_kthread = kthread_run(vga_edid_work, NULL, "vga_edid_work");
+	if (IS_ERR(task_kthread))
+	{
+		PTR_ERR(task_kthread);
+		printk(KERN_INFO "kthread is  NOT created!!\n");
+	}
+#else
 	INIT_LIST_HEAD(&setting->fbi->modelist);
 	for (i = 0; i < modedb_sz; i++) {
 		struct fb_videomode m;
@@ -82,6 +371,7 @@
 			break;
 		}
 	}
+#endif
 
 	return ret;
 }
Index: drivers/video/mxc/mxcfb_ch7055.c
===================================================================
diff --git a/drivers/video/mxc/mxcfb_ch7055.c b/drivers/video/mxc/mxcfb_ch7055.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/video/mxc/mxcfb_ch7055.c	(revision 1734)
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb_epson_vga.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <linux/mxcfb.h>
+#include <linux/ipu.h>
+#include <linux/fsl_devices.h>
+//#include <hardware.h>
+
+static struct i2c_client *ch7055_client;
+
+static ssize_t ch7055_show_brightness(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{	
+	unsigned long val;
+	val = i2c_smbus_read_byte_data(ch7055_client, 0x04);
+	
+	return sprintf(buf, "%i\n", val);
+}
+
+static ssize_t ch7055_store_brightness(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	unsigned long val, value;
+	int ret;
+
+	if ((strict_strtoul(buf, 10, &val) < 0) ||
+	    (val > 127))
+		return -EINVAL;
+  
+  ret = i2c_smbus_write_byte_data(ch7055_client, 0x04, val);
+  ret = i2c_smbus_write_byte_data(ch7055_client, 0x05, val);
+  ret = i2c_smbus_write_byte_data(ch7055_client, 0x06, val);
+  
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR(brightness, S_IWUSR | S_IRUGO,
+		   ch7055_show_brightness, ch7055_store_brightness);
+
+static struct attribute *ch7055_attributes[] = {
+	&dev_attr_brightness.attr,
+	NULL
+};
+
+static const struct attribute_group ch7055_attr_group = {
+	.attrs = ch7055_attributes,
+};
+
+static int ch7055_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	int err, ret;
+	ch7055_client = client;	
+	
+	/* setup default brightness */
+	ret = i2c_smbus_write_byte_data(ch7055_client, 0x04, 0x40);
+  ret = i2c_smbus_write_byte_data(ch7055_client, 0x05, 0x40);
+  ret = i2c_smbus_write_byte_data(ch7055_client, 0x06, 0x40);
+  if (ret < 0)
+		return ret;
+	
+	/* register sys hook */
+	err = sysfs_create_group(&client->dev.kobj, &ch7055_attr_group);
+	if (err)
+		goto exit_kfree;
+	
+	exit_kfree:		
+	return 0;
+}
+
+static int ch7055_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int ch7055_suspend(struct i2c_client *client, pm_message_t message)
+{
+	return 0;
+}
+
+static int ch7055_resume(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id ch7055_id[] = {
+	{"ch7055", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, ch7055_id);
+
+static struct i2c_driver ch7055_driver = {
+	.driver = {
+		   .name = "ch7055",
+		   },
+	.probe = ch7055_probe,
+	.remove = ch7055_remove,
+	.suspend = ch7055_suspend,
+	.resume = ch7055_resume,
+	.id_table = ch7055_id,
+};
+
+static int __init ch7055_init(void)
+{
+	printk("ch7055_init\n");	
+	return i2c_add_driver(&ch7055_driver);
+}
+
+static void __exit ch7055_exit(void)
+{
+	i2c_del_driver(&ch7055_driver);
+}
+
+module_init(ch7055_init);
+module_exit(ch7055_exit);
+
+MODULE_DESCRIPTION("CH7055 VGA driver");
+MODULE_LICENSE("GPL");
+
Index: drivers/video/mxc/Makefile
===================================================================
diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
--- a/drivers/video/mxc/Makefile	(revision 513)
+++ b/drivers/video/mxc/Makefile	(revision 1734)
@@ -7,3 +7,4 @@
 obj-$(CONFIG_FB_MXC_EINK_PANEL)             += mxc_epdc_fb.o
 obj-$(CONFIG_FB_MXS_SII902X) += mxsfb_sii902x.o
 obj-$(CONFIG_HANNSTAR_CABC) += hannstar_cabc.o
+obj-$(CONFIG_FB_MXC_CH7055)				+= mxcfb_ch7055.o
\ No newline at end of file
Index: drivers/video/backlight/pwm_bl.c
===================================================================
diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
--- a/drivers/video/backlight/pwm_bl.c	(revision 513)
+++ b/drivers/video/backlight/pwm_bl.c	(revision 1734)
@@ -20,6 +20,10 @@
 #include <linux/pwm.h>
 #include <linux/pwm_backlight.h>
 #include <linux/slab.h>
+#ifdef CONFIG_ARCH_ADVANTECH
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#endif
 
 struct pwm_bl_data {
 	struct pwm_device	*pwm;
@@ -100,6 +104,12 @@
 	struct device_node *node = dev->of_node;
 	struct property *prop;
 	int length;
+#ifdef CONFIG_ARCH_ADVANTECH
+	int lvds_vcc_enable;
+	int lvds_bkl_enable;
+	enum of_gpio_flags lvds_vcc_flag;
+	enum of_gpio_flags lvds_bkl_flag;
+#endif
 	u32 value;
 	int ret;
 
@@ -143,6 +153,33 @@
 	 *       backlight power. Support for specifying these needs to be
 	 *       added.
 	 */
+#ifdef CONFIG_ARCH_ADVANTECH
+	lvds_vcc_enable = of_get_named_gpio_flags(node, "lvds-vcc-enable", 0, &lvds_vcc_flag);
+	if (lvds_vcc_enable > 0)
+	{
+		ret = gpio_request(lvds_vcc_enable,"lvds_vcc_enable");
+		if (ret < 0) {
+			printk("request lvds_vcc_enable failed: %d\n", ret);
+			return ret;
+		}
+		gpio_direction_output(lvds_vcc_enable, lvds_vcc_flag);
+	}
+	
+	mdelay(250);
+	
+	lvds_bkl_enable = of_get_named_gpio_flags(node, "lvds-bkl-enable", 0, &lvds_bkl_flag);
+	if (lvds_bkl_enable > 0)
+	{
+		ret = gpio_request(lvds_bkl_enable,"lvds_bkl_enable");
+		if (ret < 0) {
+			printk("request lvds_bkl_enable failed: %d\n", ret);
+			return ret;
+		}
+		gpio_direction_output(lvds_bkl_enable, lvds_bkl_flag);
+	}
+	
+	mdelay(30);
+#endif
 
 	return 0;
 }
Index: drivers/pci/host/pci-imx6.c
===================================================================
diff --git a/drivers/pci/host/pci-imx6.c b/drivers/pci/host/pci-imx6.c
--- a/drivers/pci/host/pci-imx6.c	(revision 513)
+++ b/drivers/pci/host/pci-imx6.c	(revision 1734)
@@ -31,6 +31,15 @@
 
 #include "pcie-designware.h"
 
+#ifdef CONFIG_ARCH_ADVANTECH
+bool pcie_testmode = true;
+u32 pcie_gen1_value = 0 << 0;
+u32 pcie_gen2_3p5db_vlaue = 0 << 6;
+u32 pcie_gen2_6db_value = 20 << 12;
+u32 pcie_swing_full_vlaue = 127 << 18;
+u32 pcie_swing_low_vlaue = 127 << 25;
+#endif
+
 #define to_imx6_pcie(x)	container_of(x, struct imx6_pcie, pp)
 
 /*
@@ -225,8 +234,10 @@
 
 	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 			IMX6Q_GPR1_PCIE_TEST_PD, 0 << 18);
-	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
-			IMX6Q_GPR1_PCIE_REF_CLK_EN, 1 << 16);
+#ifdef CONFIG_ARCH_ADVANTECH
+//	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
+//			IMX6Q_GPR1_PCIE_REF_CLK_EN, 1 << 16);
+#endif
 	request_bus_freq(BUS_FREQ_HIGH);
 
 	ret = clk_prepare_enable(imx6_pcie->sata_ref_100m);
@@ -256,6 +267,20 @@
 		goto err_pcie_axi;
 	}
 
+#ifdef CONFIG_ARCH_ADVANTECH
+//	if (!is_imx6sx_pcie(imx6_pcie)) {
+        {  
+		/*
+		 * This bit is not used anymore on imx6sx.
+		 * wailt for the pcie clks are stable.
+		 * ~4us is requried, let it to be 10us here.
+		 */
+		udelay(10);
+		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
+				IMX6Q_GPR1_PCIE_REF_CLK_EN, 1 << 16);
+	}
+#endif
+
 	/* allow the clocks to stabilize */
 	usleep_range(200, 500);
 
@@ -298,7 +323,19 @@
 	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 			IMX6Q_GPR12_LOS_LEVEL, 9 << 4);
 
+#ifdef CONFIG_ARCH_ADVANTECH
 	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
+			IMX6Q_GPR8_TX_DEEMPH_GEN1, pcie_gen1_value);
+	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
+			IMX6Q_GPR8_TX_DEEMPH_GEN2_3P5DB, pcie_gen2_3p5db_vlaue);
+	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
+			IMX6Q_GPR8_TX_DEEMPH_GEN2_6DB, pcie_gen2_6db_value);
+	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
+			IMX6Q_GPR8_TX_SWING_FULL, pcie_swing_full_vlaue);
+	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
+			IMX6Q_GPR8_TX_SWING_LOW, pcie_swing_low_vlaue);
+#else
+	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
 			IMX6Q_GPR8_TX_DEEMPH_GEN1, 0 << 0);
 	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
 			IMX6Q_GPR8_TX_DEEMPH_GEN2_3P5DB, 0 << 6);
@@ -308,6 +345,7 @@
 			IMX6Q_GPR8_TX_SWING_FULL, 127 << 18);
 	regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
 			IMX6Q_GPR8_TX_SWING_LOW, 127 << 25);
+#endif
 }
 
 static irqreturn_t imx_pcie_msi_irq_handler(int irq, void *arg)
Index: drivers/mmc/core/mmc.c
===================================================================
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
--- a/drivers/mmc/core/mmc.c	(revision 513)
+++ b/drivers/mmc/core/mmc.c	(revision 1734)
@@ -293,7 +293,11 @@
 	}
 
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (card->ext_csd.rev > 7) {
+#else
 	if (card->ext_csd.rev > 6) {
+#endif
 		pr_err("%s: unrecognised EXT_CSD revision %d\n",
 			mmc_hostname(card->host), card->ext_csd.rev);
 		err = -EINVAL;
Index: drivers/misc/Kconfig
===================================================================
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
--- a/drivers/misc/Kconfig	(revision 513)
+++ b/drivers/misc/Kconfig	(revision 1734)
@@ -527,6 +527,9 @@
 	  the genalloc API. It is supposed to be used for small on-chip SRAM
 	  areas found on many SoCs.
 
+config ADVANTECH_DUSTWSN
+	tristate "Support Advantech DustWSN module"
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
Index: drivers/misc/Makefile
===================================================================
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
--- a/drivers/misc/Makefile	(revision 513)
+++ b/drivers/misc/Makefile	(revision 1734)
@@ -53,3 +53,4 @@
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
+obj-$(CONFIG_ADVANTECH_DUSTWSN)	+= adv-dustwsn.o
Index: drivers/misc/adv-dustwsn.c
===================================================================
diff --git a/drivers/misc/adv-dustwsn.c b/drivers/misc/adv-dustwsn.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/misc/adv-dustwsn.c	(revision 1734)
@@ -0,0 +1,96 @@
+/*
+ * Advantech Dust WSN module
+ *
+ * Copyright (C) 2015 Advantech Co.,Ltd.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+
+#define IMX_GPIO_NR(bank, nr)		(((bank) - 1) * 32 + (nr))
+
+static int __init advantech_dustwsn_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	dev_info(&pdev->dev, "Advantech Dust WSN module init...\n");
+	/* no device tree device */
+	if (!np)
+	{
+		dev_err(&pdev->dev, "no device tree device...\n");
+		return -1;
+	}
+
+	/* Enable GPIO */
+    gpio_request(IMX_GPIO_NR(1,0), "gpio-0");
+    gpio_request(IMX_GPIO_NR(1,1), "gpio-1");
+    gpio_request(IMX_GPIO_NR(1,2), "gpio-2");
+    gpio_request(IMX_GPIO_NR(1,3), "gpio-3");
+    gpio_request(IMX_GPIO_NR(1,4), "gpio-4");
+    gpio_request(IMX_GPIO_NR(1,5), "gpio-5");
+    gpio_request(IMX_GPIO_NR(1,6), "gpio-6");
+    gpio_request(IMX_GPIO_NR(1,7), "gpio-7");
+
+    gpio_direction_output(IMX_GPIO_NR(1,0), 0);
+    gpio_direction_output(IMX_GPIO_NR(1,1), 0);
+    gpio_direction_output(IMX_GPIO_NR(1,2), 0);
+    gpio_direction_output(IMX_GPIO_NR(1,3), 0);
+    gpio_direction_output(IMX_GPIO_NR(1,4), 0);
+    gpio_direction_output(IMX_GPIO_NR(1,5), 0);
+    gpio_direction_output(IMX_GPIO_NR(1,6), 0);
+    gpio_direction_output(IMX_GPIO_NR(1,7), 0);
+
+    gpio_set_value(IMX_GPIO_NR(1,0), 0);
+    gpio_set_value(IMX_GPIO_NR(1,1), 0);
+    gpio_set_value(IMX_GPIO_NR(1,2), 0);
+    gpio_set_value(IMX_GPIO_NR(1,3), 0);
+    gpio_set_value(IMX_GPIO_NR(1,4), 0);
+    gpio_set_value(IMX_GPIO_NR(1,5), 0);
+    gpio_set_value(IMX_GPIO_NR(1,6), 0);
+    gpio_set_value(IMX_GPIO_NR(1,7), 0);
+
+    gpio_set_value(IMX_GPIO_NR(1,1), 1);
+    gpio_set_value(IMX_GPIO_NR(1,5), 1);
+    mdelay(5);
+    gpio_set_value(IMX_GPIO_NR(1,1), 0);
+    gpio_set_value(IMX_GPIO_NR(1,5), 0);
+
+	return 0;
+}
+
+static int __exit advantech_dustwsn_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "Remove Advantech Dust WSN module...\n");
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id advantech_dustwsn_dt_ids[] = {
+	{ .compatible = "adv,dustwsn" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, advantech_dustwsn_dt_ids);
+#else
+#define advantech_dustwsn_dt_ids NULL
+#endif
+
+static struct platform_driver advantech_dustwsn_driver = {
+	.driver = {
+		.name = "adv-dustwsn",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(advantech_dustwsn_dt_ids),
+	},
+	.remove = __exit_p(advantech_dustwsn_remove),
+};
+
+module_platform_driver_probe(advantech_dustwsn_driver, advantech_dustwsn_probe);
+
+MODULE_AUTHOR("Advantech");
+MODULE_DESCRIPTION("Advantech Dust WSN init Module");
+MODULE_LICENSE("GPL");
Index: drivers/power/Kconfig
===================================================================
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
--- a/drivers/power/Kconfig	(revision 513)
+++ b/drivers/power/Kconfig	(revision 1734)
@@ -143,6 +143,13 @@
 	help
 	  Say Y to enable support for battery measured by WM97xx aux port.
 
+config BATTERY_EC
+	tristate "EC battery driver"
+	depends on I2C
+	help
+	 Say Y to include support for TI BQ20z75 SBS-compliant
+	 gas gauge and protection IC.
+
 config BATTERY_SBS
         tristate "SBS Compliant gas gauge"
         depends on I2C
Index: drivers/power/ec_battery.c
===================================================================
diff --git a/drivers/power/ec_battery.c b/drivers/power/ec_battery.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/power/ec_battery.c	(revision 1734)
@@ -0,0 +1,828 @@
+/*
+ * Gas Gauge driver for TI's BQ20Z75
+ *
+ * Copyright (c) 2010, NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/power_supply.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+
+#include <linux/power/ec_battery.h>
+
+enum {
+	REG_MANUFACTURER_DATA,
+	REG_TEMPERATURE,
+	REG_VOLTAGE,
+	REG_CURRENT,
+	REG_CAPACITY,
+	REG_TIME_TO_EMPTY,
+	REG_TIME_TO_FULL,
+	REG_STATUS,
+	REG_CYCLE_COUNT,
+	REG_SERIAL_NUMBER,
+	REG_REMAINING_CAPACITY,
+	REG_REMAINING_CAPACITY_CHARGE,
+	REG_FULL_CHARGE_CAPACITY,
+	REG_FULL_CHARGE_CAPACITY_CHARGE,
+	REG_DESIGN_CAPACITY,
+	REG_DESIGN_CAPACITY_CHARGE,
+	REG_DESIGN_VOLTAGE,
+};
+
+#define BATTERY_UPDATE_INTERVAL 5*HZ /*seconds*/
+
+/* Battery Mode defines */
+#define BATTERY_MODE_OFFSET		0x03
+#define BATTERY_MODE_MASK		0x8000
+enum bq20z75_battery_mode {
+	BATTERY_MODE_AMPS,
+	BATTERY_MODE_WATTS
+};
+
+/* manufacturer access defines */
+#define MANUFACTURER_ACCESS_STATUS	0x0006
+#define MANUFACTURER_ACCESS_SLEEP	0x0011
+
+/* battery status value bits */
+#define BATTERY_DISCHARGING		0x40
+#define BATTERY_FULL_CHARGED		0x20
+#define BATTERY_FULL_DISCHARGED		0x10
+
+#define BQ20Z75_DATA(_psp, _addr, _min_value, _max_value) { \
+	.psp = _psp, \
+	.addr = _addr, \
+	.min_value = _min_value, \
+	.max_value = _max_value, \
+}
+
+static const struct bq20z75_device_data {
+	enum power_supply_property psp;
+	u8 addr;
+	int min_value;
+	int max_value;
+} bq20z75_data[] = {
+	[REG_MANUFACTURER_DATA] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_PRESENT, 0x00, 0, 65535),
+	[REG_TEMPERATURE] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_TEMP, 0x08, 0, 65535),
+	[REG_VOLTAGE] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_VOLTAGE_NOW, 0x09, 0, 20000),
+	[REG_CURRENT] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_CURRENT_NOW, 0x0A, -32768,
+			32767),
+	[REG_CAPACITY] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_CAPACITY, 0x0D, 0, 100),
+	[REG_REMAINING_CAPACITY] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_ENERGY_NOW, 0x0F, 0, 65535),
+	[REG_REMAINING_CAPACITY_CHARGE] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_CHARGE_NOW, 0x0F, 0, 65535),
+	[REG_FULL_CHARGE_CAPACITY] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_ENERGY_FULL, 0x10, 0, 65535),
+	[REG_FULL_CHARGE_CAPACITY_CHARGE] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_CHARGE_FULL, 0x10, 0, 65535),
+	[REG_TIME_TO_EMPTY] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG, 0x12, 0,
+			65535),
+	[REG_TIME_TO_FULL] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_TIME_TO_FULL_AVG, 0x13, 0,
+			65535),
+	[REG_STATUS] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_STATUS, 0x16, 0, 65535),
+	[REG_CYCLE_COUNT] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_CYCLE_COUNT, 0x17, 0, 65535),
+	[REG_DESIGN_CAPACITY] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN, 0x18, 0,
+			65535),
+	[REG_DESIGN_CAPACITY_CHARGE] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN, 0x18, 0,
+			65535),
+	[REG_DESIGN_VOLTAGE] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN, 0x19, 0,
+			65535),
+	[REG_SERIAL_NUMBER] =
+		BQ20Z75_DATA(POWER_SUPPLY_PROP_SERIAL_NUMBER, 0x1C, 0, 65535),
+};
+
+static enum power_supply_property bq20z75_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CYCLE_COUNT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_ENERGY_FULL,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+};
+
+struct bq20z75_info {
+	struct i2c_client		*client;
+	struct power_supply		power_supply;
+	struct bq20z75_platform_data	*pdata;
+	bool				is_present;
+	bool				gpio_detect;
+	bool				enable_detection;
+	int				irq;
+        struct delayed_work		work;
+};
+
+static int bq20z75_read_byte_data(struct i2c_client *client, u8 address)
+{
+	struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+	s32 ret = 0;
+
+	ret = i2c_smbus_read_byte_data(client, address);
+               // printk(KERN_INFO "[Battery]--> i2c_smbus_read_byte_data [0x%x] address[0x%x] \n",ret,address);
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"%s: i2c read at address 0x%x failed\n",
+			__func__, address);
+		return ret;
+	}
+	return ret;
+}
+static int bq20z75_read_word_data(struct i2c_client *client, u8 address)
+{
+	struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+	s32 ret = 0;
+	int retries = 1;
+
+	if (bq20z75_device->pdata)
+		retries = max(bq20z75_device->pdata->i2c_retry_count + 1, 1);
+
+	while (retries > 0) {
+		ret = i2c_smbus_read_word_data(client, address);
+        //        printk(KERN_INFO "[Battery]--> i2c_smbus_write_word_data ret[0x%x] address[0x%x] \n",ret,address);
+		if (ret >= 0)
+			break;
+		retries--;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"%s: i2c read at address 0x%x failed\n",
+			__func__, address);
+		return ret;
+	}
+
+	return le16_to_cpu(ret);
+}
+
+static int bq20z75_write_word_data(struct i2c_client *client, u8 address,
+	u16 value)
+{
+	struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+	s32 ret = 0;
+	int retries = 1;
+
+	if (bq20z75_device->pdata)
+		retries = max(bq20z75_device->pdata->i2c_retry_count + 1, 1);
+
+	while (retries > 0) {
+		ret = i2c_smbus_write_word_data(client, address,
+			le16_to_cpu(value));
+		if (ret >= 0)
+			break;
+		retries--;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"%s: i2c write to address 0x%x failed\n",
+			__func__, address);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int bq20z75_get_battery_presence(
+ 	struct i2c_client *client, enum power_supply_property psp,
+ 	union power_supply_propval *val)
+{
+        s32 ret;
+        struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+        ret = bq20z75_write_word_data(client, 0x82, 0x90); 
+        ret = bq20z75_read_byte_data(client, 0x80);
+
+        if (ret < 0)
+                return ret;
+            val->intval = ret;
+
+	        if (ret & 0x02)
+			val->intval = 1;
+		else
+			val->intval = 0;
+		bq20z75_device->is_present = val->intval;
+//		printk(KERN_INFO "[Battery]--> present [0x%x][0x%x] \n",bq20z75_device->is_present,val->intval);
+		return ret;
+}
+
+static int bq20z75_get_battery_health(
+	struct i2c_client *client, enum power_supply_property psp,
+	union power_supply_propval *val)
+{
+        s32 ret;
+        ret = bq20z75_write_word_data(client, 0x82, 0x90); 
+        ret = bq20z75_read_byte_data(client, 0x80);
+
+        if (ret < 0)
+                return ret;
+            val->intval = ret;
+	
+	        if (ret & 0x02)
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		else
+		        val->intval = POWER_SUPPLY_HEALTH_DEAD;
+                //printk(KERN_INFO "[Battery]--> bq20z75_get_battery_health[0x%x] \n",ret);
+		return ret;
+}
+
+static int bq20z75_get_battery_voltage_property(struct i2c_client *client,
+        int reg_offset, enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+        s32 ret, ret1;
+        ret = bq20z75_write_word_data(client, 0x82, 0x03); //by clayder
+        ret = bq20z75_read_word_data(client, 0x80);
+        ret1 = ((ret & 0xff00) >> 8 | (ret & 0x00ff) << 8);
+        if (ret < 0)
+                return ret1;
+
+//            printk(KERN_INFO "[Battery]--> bq20z75_get_battery_voltage_property[0x%x] \n",ret);
+            val->intval = ret1;
+
+        return 0;
+}
+
+static int bq20z75_get_battery_current_property(struct i2c_client *client,
+        int reg_offset, enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+        s32 ret, ret1;
+        ret = bq20z75_write_word_data(client, 0x82, 0x07); //by clayder
+        ret = bq20z75_read_word_data(client, 0x80);
+        ret1 = ((ret & 0xff00) >> 8 | (ret & 0x00ff) << 8);
+        if (ret < 0)
+                return ret1;
+            val->intval = ret1;
+
+        return 0;
+}
+
+static int bq20z75_get_battery_temp_property(struct i2c_client *client,
+        int reg_offset, enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+        s32 ret;
+        ret = bq20z75_write_word_data(client, 0x82, 0x02); //by clayder
+        ret = bq20z75_read_byte_data(client, 0x80);
+
+        if (ret < 0)
+                return ret;
+            val->intval = ret;
+
+        return 0;
+}
+
+static int bq20z75_get_battery_status_property(struct i2c_client *client,
+        int reg_offset, enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+        s32 ret;
+        struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+
+        ret = bq20z75_write_word_data(client, 0x82, 0x01); //by clayder
+        ret = bq20z75_read_byte_data(client, 0x80);
+        if (ret < 0)
+                return ret;
+
+        /* returned values are 16 bit */
+        if (bq20z75_data[reg_offset].min_value < 0)
+                ret = (s16)ret;
+        //printk(KERN_INFO "[Battery]--> bq20z75_get_battery_status_property[0x%x] \n",ret);
+        if (ret >= bq20z75_data[reg_offset].min_value &&
+            ret <= bq20z75_data[reg_offset].max_value) {
+                val->intval = ret;
+                if (psp == POWER_SUPPLY_PROP_STATUS) {
+                        if (ret & BATTERY_FULL_CHARGED)
+                                val->intval = POWER_SUPPLY_STATUS_FULL;
+                        else if (ret & BATTERY_FULL_DISCHARGED)
+                                val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+                        else if (ret & BATTERY_DISCHARGING)
+                                val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+                        else
+                                val->intval = POWER_SUPPLY_STATUS_CHARGING;
+                }
+        } else {
+                if (psp == POWER_SUPPLY_PROP_STATUS)
+                        val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+                else
+                        val->intval = 0;
+        }
+
+        if(!bq20z75_device->is_present)
+            val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+
+        return 0;
+}
+
+static int bq20z75_get_battery_property(struct i2c_client *client,
+	int reg_offset, enum power_supply_property psp,
+	union power_supply_propval *val)
+{
+	s32 ret;
+
+	ret = bq20z75_read_word_data(client,
+		bq20z75_data[reg_offset].addr);
+	if (ret < 0)
+		return ret;
+
+	/* returned values are 16 bit */
+	if (bq20z75_data[reg_offset].min_value < 0)
+		ret = (s16)ret;
+
+	if (ret >= bq20z75_data[reg_offset].min_value &&
+	    ret <= bq20z75_data[reg_offset].max_value) {
+		val->intval = ret;
+		if (psp == POWER_SUPPLY_PROP_STATUS) {
+			if (ret & BATTERY_FULL_CHARGED)
+				val->intval = POWER_SUPPLY_STATUS_FULL;
+			else if (ret & BATTERY_FULL_DISCHARGED)
+				val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			else if (ret & BATTERY_DISCHARGING)
+				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+			else
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		}
+	} else {
+		if (psp == POWER_SUPPLY_PROP_STATUS)
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		else
+			val->intval = 0;
+	}
+
+	return 0;
+}
+
+static void  bq20z75_unit_adjustment(struct i2c_client *client,
+	enum power_supply_property psp, union power_supply_propval *val)
+{
+#define BASE_UNIT_CONVERSION		1000
+#define BATTERY_MODE_CAP_MULT_WATT	(10 * BASE_UNIT_CONVERSION)
+#define TIME_UNIT_CONVERSION		60
+#define TEMP_KELVIN_TO_CELSIUS		2731
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		/* bq20z75 provides energy in units of 10mWh.
+		 * Convert to Wh
+		 */
+		val->intval *= BATTERY_MODE_CAP_MULT_WATT;
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+//		val->intval *= BASE_UNIT_CONVERSION;
+		break;
+
+	case POWER_SUPPLY_PROP_TEMP:
+		/* bq20z75 provides battery temperature in 0.1K
+		 * so convert it to 0.1C
+		 */
+	//	val->intval -= TEMP_KELVIN_TO_CELSIUS;
+		break;
+
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:
+		/* bq20z75 provides time to empty and time to full in minutes.
+		 * Convert to seconds
+		 */
+		val->intval *= TIME_UNIT_CONVERSION;
+		break;
+
+	default:
+		dev_dbg(&client->dev,
+			"%s: no need for unit conversion %d\n", __func__, psp);
+	}
+}
+
+static enum bq20z75_battery_mode
+bq20z75_set_battery_mode(struct i2c_client *client,
+	enum bq20z75_battery_mode mode)
+{
+	int ret, original_val;
+
+	original_val = bq20z75_read_word_data(client, BATTERY_MODE_OFFSET);
+	if (original_val < 0)
+		return original_val;
+
+	if ((original_val & BATTERY_MODE_MASK) == mode)
+		return mode;
+
+	if (mode == BATTERY_MODE_AMPS)
+		ret = original_val & ~BATTERY_MODE_MASK;
+	else
+		ret = original_val | BATTERY_MODE_MASK;
+
+	ret = bq20z75_write_word_data(client, BATTERY_MODE_OFFSET, ret);
+	if (ret < 0)
+		return ret;
+
+	return original_val & BATTERY_MODE_MASK;
+}
+
+static int bq20z75_get_battery_capacity(struct i2c_client *client,
+	int reg_offset, enum power_supply_property psp,
+	union power_supply_propval *val)
+{
+	s32 ret;
+        ret = bq20z75_write_word_data(client, 0X82, 0x0D); //by clayder
+        ret = bq20z75_read_byte_data(client, 0X80);
+	//ret = bq20z75_read_word_data(client, 0X80);
+	if (ret < 0)
+		return ret;
+       // printk(KERN_INFO "[Battery]--> bq20z75_get_battery_capacity ret[0x%x]  \n",ret);
+	if (psp == POWER_SUPPLY_PROP_CAPACITY) {
+		/* bq20z75 spec says that this can be >100 %
+		* even if max value is 100 % */
+		val->intval = min(ret, 100);
+	} else
+		val->intval = ret;
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static char bq20z75_serial[5];
+static int bq20z75_get_battery_serial_number(struct i2c_client *client,
+	union power_supply_propval *val)
+{
+	int ret;
+
+	ret = bq20z75_read_word_data(client,
+		bq20z75_data[REG_SERIAL_NUMBER].addr);
+	if (ret < 0)
+		return ret;
+
+	ret = sprintf(bq20z75_serial, "%04x", ret);
+	val->strval = bq20z75_serial;
+
+	return 0;
+}
+
+static int bq20z75_get_property_index(struct i2c_client *client,
+	enum power_supply_property psp)
+{
+	int count;
+	for (count = 0; count < ARRAY_SIZE(bq20z75_data); count++)
+		if (psp == bq20z75_data[count].psp)
+			return count;
+
+	dev_warn(&client->dev,
+		"%s: Invalid Property - %d\n", __func__, psp);
+
+	return -EINVAL;
+}
+
+static int bq20z75_get_property(struct power_supply *psy,
+	enum power_supply_property psp,
+	union power_supply_propval *val)
+{
+	int ret = 0;
+	struct bq20z75_info *bq20z75_device = container_of(psy,
+				struct bq20z75_info, power_supply);
+	struct i2c_client *client = bq20z75_device->client;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		ret = bq20z75_get_battery_presence(client, psp, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		ret = bq20z75_get_battery_health(client, psp, val);
+		break;
+
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+                break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		ret = bq20z75_get_battery_capacity(client, ret, psp, val);
+		break;
+
+	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
+		ret = bq20z75_get_battery_serial_number(client, val);
+		break;
+
+	case POWER_SUPPLY_PROP_STATUS:
+                ret = bq20z75_get_battery_status_property(client, ret, psp, val);
+                break;
+	case POWER_SUPPLY_PROP_CYCLE_COUNT:
+                break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+                ret = bq20z75_get_battery_voltage_property(client, ret, psp, val);
+                break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+                ret = bq20z75_get_battery_current_property(client, ret, psp, val);
+                break;
+	case POWER_SUPPLY_PROP_TEMP:
+                ret = bq20z75_get_battery_temp_property(client, ret, psp, val);
+                break;
+
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		ret = bq20z75_get_property_index(client, psp);
+		if (ret < 0)
+			break;
+
+		ret = bq20z75_get_battery_property(client, ret, psp, val);
+		break;
+
+	default:
+		dev_err(&client->dev,
+			"%s: INVALID property\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!bq20z75_device->enable_detection)
+		goto done;
+
+	if (!bq20z75_device->gpio_detect &&
+		bq20z75_device->is_present != (ret >= 0)) {
+		bq20z75_device->is_present = (ret >= 0);
+		power_supply_changed(&bq20z75_device->power_supply);
+		printk(KERN_INFO "power_supply_changed\n");    
+	}
+
+done:
+	if (!ret) {
+		/* Convert units to match requirements for power supply class */
+		bq20z75_unit_adjustment(client, psp, val);
+	}
+
+	dev_dbg(&client->dev,
+		"%s: property = %d, value = %x\n", __func__, psp, val->intval);
+
+	if (ret && bq20z75_device->is_present)
+		return ret;
+
+	/* battery not present, so return NODATA for properties */
+	//if (ret)
+	//	return -ENODATA;
+
+	return 0;
+}
+
+static irqreturn_t bq20z75_irq(int irq, void *devid)
+{
+	struct power_supply *battery = devid;
+
+	power_supply_changed(battery);
+
+	return IRQ_HANDLED;
+}
+
+static void bq20z75_battery_work(struct work_struct *work)
+{
+	struct bq20z75_info *bq20z75_device;
+	bq20z75_device = container_of(work, struct bq20z75_info, work.work);
+
+	power_supply_changed(&bq20z75_device->power_supply);
+
+	/* reschedule for the next time */
+	schedule_delayed_work(&bq20z75_device->work, BATTERY_UPDATE_INTERVAL);
+}
+
+static int bq20z75_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+	struct bq20z75_info *bq20z75_device;
+	struct bq20z75_platform_data *pdata = client->dev.platform_data;
+	int rc;
+	int irq;
+
+        printk(KERN_INFO "[EC_Battery]----> EC  bq20z75_probe\n");
+	bq20z75_device = kzalloc(sizeof(struct bq20z75_info), GFP_KERNEL);
+	if (!bq20z75_device)
+		return -ENOMEM;
+
+	bq20z75_device->client = client;
+	bq20z75_device->enable_detection = false;
+	bq20z75_device->gpio_detect = false;
+	bq20z75_device->power_supply.name = "battery";
+	bq20z75_device->power_supply.type = POWER_SUPPLY_TYPE_BATTERY;
+	bq20z75_device->power_supply.properties = bq20z75_properties;
+	bq20z75_device->power_supply.num_properties =
+		ARRAY_SIZE(bq20z75_properties);
+	bq20z75_device->power_supply.get_property = bq20z75_get_property;
+
+	if (pdata) {
+		bq20z75_device->gpio_detect =
+			gpio_is_valid(pdata->battery_detect);
+		bq20z75_device->pdata = pdata;
+	}
+
+	i2c_set_clientdata(client, bq20z75_device);
+
+        rc = bq20z75_read_byte_data(bq20z75_device->client, 0x80); //Check whether EC Battery Charger exists
+        if(rc != 0) {
+                printk("%s: No Battery Charger %d\n",__func__,rc);
+                goto exit_psupply;
+        }
+
+	if (!bq20z75_device->gpio_detect)
+		goto skip_gpio;
+
+	rc = gpio_request(pdata->battery_detect, dev_name(&client->dev));
+	if (rc) {
+		dev_warn(&client->dev, "Failed to request gpio: %d\n", rc);
+		bq20z75_device->gpio_detect = false;
+		goto skip_gpio;
+	}
+
+	rc = gpio_direction_input(pdata->battery_detect);
+	if (rc) {
+		dev_warn(&client->dev, "Failed to get gpio as input: %d\n", rc);
+		gpio_free(pdata->battery_detect);
+		bq20z75_device->gpio_detect = false;
+		goto skip_gpio;
+	}
+
+	irq = gpio_to_irq(pdata->battery_detect);
+	if (irq <= 0) {
+		dev_warn(&client->dev, "Failed to get gpio as irq: %d\n", irq);
+		gpio_free(pdata->battery_detect);
+		bq20z75_device->gpio_detect = false;
+		goto skip_gpio;
+	}
+
+	rc = request_irq(irq, bq20z75_irq,
+		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+		dev_name(&client->dev), &bq20z75_device->power_supply);
+	if (rc) {
+		dev_warn(&client->dev, "Failed to request irq: %d\n", rc);
+		gpio_free(pdata->battery_detect);
+		bq20z75_device->gpio_detect = false;
+		goto skip_gpio;
+	}
+
+	bq20z75_device->irq = irq;
+
+skip_gpio:
+
+	rc = power_supply_register(&client->dev, &bq20z75_device->power_supply);
+	if (rc) {
+		dev_err(&client->dev,
+			"%s: Failed to register power supply\n", __func__);
+		goto exit_psupply;
+	}
+
+	dev_info(&client->dev,
+		"%s: battery gas gauge device registered\n", client->name);
+
+	//[Advantech] Add delay work to update battery status frequently
+	INIT_DEFERRABLE_WORK(&bq20z75_device->work, bq20z75_battery_work);
+	schedule_delayed_work(&bq20z75_device->work, BATTERY_UPDATE_INTERVAL);
+
+	return 0;
+
+exit_psupply:
+	if (bq20z75_device->irq)
+		free_irq(bq20z75_device->irq, &bq20z75_device->power_supply);
+	if (bq20z75_device->gpio_detect)
+		gpio_free(pdata->battery_detect);
+
+	kfree(bq20z75_device);
+
+	return rc;
+}
+
+static int bq20z75_remove(struct i2c_client *client)
+{
+	struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+
+	if (bq20z75_device->irq)
+		free_irq(bq20z75_device->irq, &bq20z75_device->power_supply);
+	if (bq20z75_device->gpio_detect)
+		gpio_free(bq20z75_device->pdata->battery_detect);
+
+        cancel_delayed_work_sync(&bq20z75_device->work);
+	
+        power_supply_unregister(&bq20z75_device->power_supply);
+	kfree(bq20z75_device);
+	bq20z75_device = NULL;
+
+	return 0;
+}
+
+#if defined CONFIG_PM
+static int bq20z75_suspend(struct i2c_client *client,
+	pm_message_t state)
+{
+	struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+	s32 ret;
+
+        cancel_delayed_work(&bq20z75_device->work);
+
+	/* write to manufacturer access with sleep command */
+	ret = bq20z75_write_word_data(client,
+		bq20z75_data[REG_MANUFACTURER_DATA].addr,
+		MANUFACTURER_ACCESS_SLEEP);
+	if (bq20z75_device->is_present && ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int bq20z75_resume(struct i2c_client *client)
+{
+	struct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);
+
+	schedule_delayed_work(&bq20z75_device->work, BATTERY_UPDATE_INTERVAL);
+
+	return 0;
+}
+
+#else
+#define bq20z75_suspend		NULL
+//#endif
+/* any smbus transaction will wake up bq20z75 */
+#define bq20z75_resume		NULL
+#endif
+
+static const struct i2c_device_id bq20z75_id[] = {
+	{ "ec", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, bq20z75_id);
+
+static struct i2c_driver bq20z75_battery_driver = {
+	.probe		= bq20z75_probe,
+	.remove		= bq20z75_remove,
+	.suspend	= bq20z75_suspend,
+	.resume		= bq20z75_resume,
+	.id_table	= bq20z75_id,
+	.driver = {
+		.name	= "ec-battery",
+	},
+};
+
+static int __init bq20z75_battery_init(void)
+{
+	return i2c_add_driver(&bq20z75_battery_driver);
+}
+module_init(bq20z75_battery_init);
+
+static void __exit bq20z75_battery_exit(void)
+{
+	i2c_del_driver(&bq20z75_battery_driver);
+}
+module_exit(bq20z75_battery_exit);
+
+MODULE_DESCRIPTION("EC battery monitor driver");
+MODULE_LICENSE("GPL");
Index: drivers/power/Makefile
===================================================================
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
--- a/drivers/power/Makefile	(revision 513)
+++ b/drivers/power/Makefile	(revision 1734)
@@ -26,6 +26,7 @@
 obj-$(CONFIG_BATTERY_TOSA)	+= tosa_battery.o
 obj-$(CONFIG_BATTERY_COLLIE)	+= collie_battery.o
 obj-$(CONFIG_BATTERY_WM97XX)	+= wm97xx_battery.o
+obj-$(CONFIG_BATTERY_EC)        += ec_battery.o
 obj-$(CONFIG_BATTERY_SBS)	+= sbs-battery.o
 obj-$(CONFIG_BATTERY_BQ27x00)	+= bq27x00_battery.o
 obj-$(CONFIG_BATTERY_DA9030)	+= da9030_battery.o
Index: drivers/regulator/Kconfig
===================================================================
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
--- a/drivers/regulator/Kconfig	(revision 513)
+++ b/drivers/regulator/Kconfig	(revision 1734)
@@ -305,12 +305,12 @@
 	 on PCF50633
 
 config REGULATOR_PFUZE100
-	tristate "Support regulators on Freescale PFUZE100 PMIC"
+	tristate "Freescale PFUZE100/PFUZE200 regulator driver"
 	depends on I2C
 	select REGMAP_I2C
 	help
-	  Say y here to support the regulators found on the Freescale PFUZE100
-	  PMIC.
+	  Say y here to support the regulators found on the Freescale
+	  PFUZE100/PFUZE200 PMIC.
 
 config REGULATOR_RC5T583
 	tristate "RICOH RC5T583 Power regulators"
Index: drivers/regulator/pfuze100-regulator.c
===================================================================
diff --git a/drivers/regulator/pfuze100-regulator.c b/drivers/regulator/pfuze100-regulator.c
--- a/drivers/regulator/pfuze100-regulator.c	(revision 513)
+++ b/drivers/regulator/pfuze100-regulator.c	(revision 1734)
@@ -38,7 +38,7 @@
 
 #define PFUZE100_DEVICEID	0x0
 #define PFUZE100_REVID		0x3
-#define PFUZE100_FABID		0x3
+#define PFUZE100_FABID		0x4
 
 #define PFUZE100_SW1ABVOL	0x20
 #define PFUZE100_SW1CVOL	0x2e
@@ -56,6 +56,8 @@
 #define PFUZE100_VGEN5VOL	0x70
 #define PFUZE100_VGEN6VOL	0x71
 
+enum chips { PFUZE100, PFUZE200 };
+
 struct pfuze_regulator {
 	struct regulator_desc desc;
 	unsigned char stby_reg;
@@ -63,6 +65,7 @@
 };
 
 struct pfuze_chip {
+	int	chip_id;
 	struct regmap *regmap;
 	struct device *dev;
 	struct pfuze_regulator regulator_descs[PFUZE100_MAX_REGULATOR];
@@ -78,14 +81,16 @@
 };
 
 static const struct i2c_device_id pfuze_device_id[] = {
-	{.name = "pfuze100"},
-	{},
+	{.name = "pfuze100", .driver_data = PFUZE100},
+	{.name = "pfuze200", .driver_data = PFUZE200},
+	{ }
 };
 MODULE_DEVICE_TABLE(i2c, pfuze_device_id);
 
 static const struct of_device_id pfuze_dt_ids[] = {
-	{ .compatible = "fsl,pfuze100" },
-	{},
+	{ .compatible = "fsl,pfuze100", .data = (void *)PFUZE100},
+	{ .compatible = "fsl,pfuze200", .data = (void *)PFUZE200},
+	{ }
 };
 MODULE_DEVICE_TABLE(of, pfuze_dt_ids);
 
@@ -139,14 +144,14 @@
 
 };
 
-#define PFUZE100_FIXED_REG(_name, base, voltage)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_FIXED_REG(_chip, _name, base, voltage)	\
+	[_chip ## _ ## _name] = {	\
 		.desc = {	\
 			.name = #_name,	\
 			.n_voltages = 1,	\
 			.ops = &pfuze100_fixed_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.min_uV = (voltage),	\
 			.enable_reg = (base),	\
@@ -154,14 +159,14 @@
 		},	\
 	}
 
-#define PFUZE100_SW_REG(_name, base, min, max, step)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_SW_REG(_chip, _name, base, min, max, step)	\
+	[_chip ## _ ## _name] = {	\
 		.desc = {	\
 			.name = #_name,\
 			.n_voltages = ((max) - (min)) / (step) + 1,	\
 			.ops = &pfuze100_sw_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.min_uV = (min),	\
 			.uV_step = (step),	\
@@ -172,14 +177,14 @@
 		.stby_mask = 0x3f,	\
 	}
 
-#define PFUZE100_SWB_REG(_name, base, mask, voltages)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_SWB_REG(_chip, _name, base, mask, voltages)	\
+	[_chip ## _ ##  _name] = {	\
 		.desc = {	\
 			.name = #_name,	\
 			.n_voltages = ARRAY_SIZE(voltages),	\
 			.ops = &pfuze100_swb_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.volt_table = voltages,	\
 			.vsel_reg = (base),	\
@@ -187,14 +192,14 @@
 		},	\
 	}
 
-#define PFUZE100_VGEN_REG(_name, base, min, max, step)	\
-	[PFUZE100_ ## _name] = {	\
+#define PFUZE100_VGEN_REG(_chip, _name, base, min, max, step)	\
+	[_chip ## _ ## _name] = {	\
 		.desc = {	\
 			.name = #_name,	\
 			.n_voltages = ((max) - (min)) / (step) + 1,	\
 			.ops = &pfuze100_ldo_regulator_ops,	\
 			.type = REGULATOR_VOLTAGE,	\
-			.id = PFUZE100_ ## _name,	\
+			.id = _chip ## _ ## _name,	\
 			.owner = THIS_MODULE,	\
 			.min_uV = (min),	\
 			.uV_step = (step),	\
@@ -207,25 +212,45 @@
 		.stby_mask = 0x20,	\
 	}
 
+/* PFUZE100 */
 static struct pfuze_regulator pfuze100_regulators[] = {
-	PFUZE100_SW_REG(SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),
-	PFUZE100_SW_REG(SW1C, PFUZE100_SW1CVOL, 300000, 1875000, 25000),
-	PFUZE100_SW_REG(SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),
-	PFUZE100_SW_REG(SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),
-	PFUZE100_SW_REG(SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),
-	PFUZE100_SW_REG(SW4, PFUZE100_SW4VOL, 400000, 1975000, 25000),
-	PFUZE100_SWB_REG(SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),
-	PFUZE100_SWB_REG(VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),
-	PFUZE100_FIXED_REG(VREFDDR, PFUZE100_VREFDDRCON, 750000),
-	PFUZE100_VGEN_REG(VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),
-	PFUZE100_VGEN_REG(VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),
-	PFUZE100_VGEN_REG(VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),
-	PFUZE100_VGEN_REG(VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),
-	PFUZE100_VGEN_REG(VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),
-	PFUZE100_VGEN_REG(VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),
+	PFUZE100_SW_REG(PFUZE100, SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW1C, PFUZE100_SW1CVOL, 300000, 1875000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE100, SW4, PFUZE100_SW4VOL, 400000, 1975000, 25000),
+	PFUZE100_SWB_REG(PFUZE100, SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),
+	PFUZE100_SWB_REG(PFUZE100, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),
+	PFUZE100_FIXED_REG(PFUZE100, VREFDDR, PFUZE100_VREFDDRCON, 750000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE100, VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),
 };
 
+static struct pfuze_regulator pfuze200_regulators[] = {
+	PFUZE100_SW_REG(PFUZE200, SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),
+	PFUZE100_SW_REG(PFUZE200, SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE200, SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),
+	PFUZE100_SW_REG(PFUZE200, SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),
+	PFUZE100_SWB_REG(PFUZE200, SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),
+	PFUZE100_SWB_REG(PFUZE200, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),
+	PFUZE100_FIXED_REG(PFUZE200, VREFDDR, PFUZE100_VREFDDRCON, 750000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),
+	PFUZE100_VGEN_REG(PFUZE200, VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),
+};
+
+static struct pfuze_regulator *pfuze_regulators;
+
 #ifdef CONFIG_OF
+/* PFUZE100 */
 static struct of_regulator_match pfuze100_matches[] = {
 	{ .name = "sw1ab",	},
 	{ .name = "sw1c",	},
@@ -244,25 +269,57 @@
 	{ .name = "vgen6",	},
 };
 
+/* PFUZE200 */
+static struct of_regulator_match pfuze200_matches[] = {
+
+	{ .name = "sw1ab",	},
+	{ .name = "sw2",	},
+	{ .name = "sw3a",	},
+	{ .name = "sw3b",	},
+	{ .name = "swbst",	},
+	{ .name = "vsnvs",	},
+	{ .name = "vrefddr",	},
+	{ .name = "vgen1",	},
+	{ .name = "vgen2",	},
+	{ .name = "vgen3",	},
+	{ .name = "vgen4",	},
+	{ .name = "vgen5",	},
+	{ .name = "vgen6",	},
+};
+
+static struct of_regulator_match *pfuze_matches;
+
 static int pfuze_parse_regulators_dt(struct pfuze_chip *chip)
 {
 	struct device *dev = chip->dev;
 	struct device_node *np, *parent;
 	int ret;
 
-	np = of_node_get(dev->parent->of_node);
+	np = of_node_get(dev->of_node);
 	if (!np)
 		return 0;
 
-	parent = of_find_node_by_name(np, "regulators");
+	parent = of_get_child_by_name(np, "regulators");
 	if (!parent) {
 		dev_err(dev, "regulators node not found\n");
 		return -EINVAL;
 	}
 
-	ret = of_regulator_match(dev, parent, pfuze100_matches,
-				 ARRAY_SIZE(pfuze100_matches));
+	switch (chip->chip_id) {
+	case PFUZE200:
+		pfuze_matches = pfuze200_matches;
+		ret = of_regulator_match(dev, parent, pfuze200_matches,
+					 ARRAY_SIZE(pfuze200_matches));
+		break;
 
+	case PFUZE100:
+	default:
+		pfuze_matches = pfuze100_matches;
+		ret = of_regulator_match(dev, parent, pfuze100_matches,
+					 ARRAY_SIZE(pfuze100_matches));
+		break;
+	}
+
 	of_node_put(parent);
 	if (ret < 0) {
 		dev_err(dev, "Error parsing regulator init data: %d\n",
@@ -275,12 +332,12 @@
 
 static inline struct regulator_init_data *match_init_data(int index)
 {
-	return pfuze100_matches[index].init_data;
+	return pfuze_matches[index].init_data;
 }
 
 static inline struct device_node *match_of_node(int index)
 {
-	return pfuze100_matches[index].of_node;
+	return pfuze_matches[index].of_node;
 }
 #else
 static int pfuze_parse_regulators_dt(struct pfuze_chip *chip)
@@ -308,7 +365,8 @@
 	if (ret)
 		return ret;
 
-	if (value & 0x0f) {
+	if ((value & 0x0f) != pfuze_chip->chip_id) {
+		/* device id NOT match with your setting */
 		dev_warn(pfuze_chip->dev, "Illegal ID: %x\n", value);
 		return -ENODEV;
 	}
@@ -344,17 +402,31 @@
 	    dev_get_platdata(&client->dev);
 	struct regulator_config config = { };
 	int i, ret;
+	const struct of_device_id *match;
+	u32 regulator_num;
+	u32 sw_check_start, sw_check_end;
 
 	pfuze_chip = devm_kzalloc(&client->dev, sizeof(*pfuze_chip),
 			GFP_KERNEL);
 	if (!pfuze_chip)
 		return -ENOMEM;
 
+	if (client->dev.of_node) {
+		match = of_match_device(of_match_ptr(pfuze_dt_ids),
+				&client->dev);
+		if (!match) {
+			dev_err(&client->dev, "Error: No device match found\n");
+			return -ENODEV;
+		}
+		pfuze_chip->chip_id = (int)(long)match->data;
+	} else if (id) {
+		pfuze_chip->chip_id = id->driver_data;
+	} else {
+		dev_err(&client->dev, "No dts match or id table match found\n");
+		return -ENODEV;
+	}
+
 	i2c_set_clientdata(client, pfuze_chip);
-
-	memcpy(pfuze_chip->regulator_descs, pfuze100_regulators,
-		sizeof(pfuze_chip->regulator_descs));
-
 	pfuze_chip->dev = &client->dev;
 
 	pfuze_chip->regmap = devm_regmap_init_i2c(client, &pfuze_regmap_config);
@@ -371,11 +443,34 @@
 		return ret;
 	}
 
+	/* use the right regulators after identify the right device */
+	switch (pfuze_chip->chip_id) {
+	case PFUZE200:
+		pfuze_regulators = pfuze200_regulators;
+		regulator_num = ARRAY_SIZE(pfuze200_regulators);
+		sw_check_start = PFUZE200_SW2;
+		sw_check_end = PFUZE200_SW3B;
+		break;
+
+	case PFUZE100:
+	default:
+		pfuze_regulators = pfuze100_regulators;
+		regulator_num = ARRAY_SIZE(pfuze100_regulators);
+		sw_check_start = PFUZE100_SW2;
+		sw_check_end = PFUZE100_SW4;
+		break;
+	}
+	dev_info(&client->dev, "pfuze%s found.\n",
+		(pfuze_chip->chip_id == PFUZE100) ? "100" : "200");
+
+	memcpy(pfuze_chip->regulator_descs, pfuze_regulators,
+		sizeof(pfuze_chip->regulator_descs));
+
 	ret = pfuze_parse_regulators_dt(pfuze_chip);
 	if (ret)
 		return ret;
 
-	for (i = 0; i < PFUZE100_MAX_REGULATOR; i++) {
+	for (i = 0; i < regulator_num; i++) {
 		struct regulator_init_data *init_data;
 		struct regulator_desc *desc;
 		int val;
@@ -388,7 +483,7 @@
 			init_data = match_init_data(i);
 
 		/* SW2~SW4 high bit check and modify the voltage value table */
-		if (i > PFUZE100_SW1C && i < PFUZE100_SWBST) {
+		if (i >= sw_check_start && i <= sw_check_end) {
 			regmap_read(pfuze_chip->regmap, desc->vsel_reg, &val);
 			if (val & 0x40) {
 				desc->min_uV = 800000;
@@ -440,6 +535,6 @@
 module_i2c_driver(pfuze_driver);
 
 MODULE_AUTHOR("Robin Gong <b38343@freescale.com>");
-MODULE_DESCRIPTION("Regulator Driver for Freescale PFUZE100 PMIC");
+MODULE_DESCRIPTION("Regulator Driver for Freescale PFUZE100/PFUZE200 PMIC");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("i2c:pfuze100-regulator");
Index: drivers/crypto/caam/ctrl.c
===================================================================
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
--- a/drivers/crypto/caam/ctrl.c	(revision 513)
+++ b/drivers/crypto/caam/ctrl.c	(revision 1734)
@@ -169,14 +169,17 @@
 	/* put RNG4 into program mode */
 	setbits32(&r4tst->rtmctl, RTMCTL_PRGM);
 	/* Set clocks per sample to the default, and divider to zero */
+
 	val = rd_reg32(&r4tst->rtsdctl);
-	val = (val & ~RTSDCTL_ENT_DLY_MASK) |
-	       (RNG4_ENT_CLOCKS_SAMPLE << RTSDCTL_ENT_DLY_SHIFT);
+	val = (val & ~RTSDCTL_ENT_DLY_MASK) | (RNG4_ENT_CLOCKS_SAMPLE << RTSDCTL_ENT_DLY_SHIFT);
 	wr_reg32(&r4tst->rtsdctl, val);
+
 	/* min. freq. count */
 	wr_reg32(&r4tst->rtfrqmin, RNG4_ENT_CLOCKS_SAMPLE / 4);
+
 	/* max. freq. count */
 	wr_reg32(&r4tst->rtfrqmax, RNG4_ENT_CLOCKS_SAMPLE * 8);
+
 	/* put RNG4 into run mode */
 	clrbits32(&r4tst->rtmctl, RTMCTL_PRGM);
 }
Index: drivers/crypto/caam/intern.h
===================================================================
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
--- a/drivers/crypto/caam/intern.h	(revision 513)
+++ b/drivers/crypto/caam/intern.h	(revision 1734)
@@ -13,7 +13,11 @@
 #define JOBR_ASSIGNED 1
 
 /* Default clock/sample settings for an RNG4 entropy source */
+#ifdef CONFIG_ARCH_ADVANTECH
+#define RNG4_ENT_CLOCKS_SAMPLE 3200
+#else
 #define RNG4_ENT_CLOCKS_SAMPLE 1600
+#endif
 
 /* Currently comes from Kconfig param as a ^2 (driver-required) */
 #define JOBR_DEPTH (1 << CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE)
Index: drivers/tty/serial/Makefile
===================================================================
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
--- a/drivers/tty/serial/Makefile	(revision 513)
+++ b/drivers/tty/serial/Makefile	(revision 1734)
@@ -86,3 +86,4 @@
 obj-$(CONFIG_SERIAL_ARC)	+= arc_uart.o
 obj-$(CONFIG_SERIAL_RP2)	+= rp2.o
 obj-$(CONFIG_SERIAL_FSL_LPUART)	+= fsl_lpuart.o
+obj-$(CONFIG_SERIAL_XR275X)	+= xr16l2751.o
Index: drivers/tty/serial/xr16l2751.c
===================================================================
diff --git a/drivers/tty/serial/xr16l2751.c b/drivers/tty/serial/xr16l2751.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/tty/serial/xr16l2751.c	(revision 1734)
@@ -0,0 +1,1219 @@
+/*****************************************************************************/
+/*
+*      
+*
+*      Copyright (C) 2012 Exar Corporation.
+*
+*      Based on Linux 2.6 Kernel's  drivers/serial/8250.c
+*
+*      This program is free software; you can redistribute it and/or modify
+*      it under the terms of the GNU General Public License as published by
+*      the Free Software Foundation; either version 2 of the License, or
+*      (at your option) any later version.
+*
+*      This program is distributed in the hope that it will be useful,
+*      but WITHOUT ANY WARRANTY; without even the implied warranty of
+*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*      GNU General Public License for more details.
+*
+*      You should have received a copy of the GNU General Public License
+*      along with this program; if not, write to the Free Software
+*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*
+*	   XR16L275x driver for
+*	   for			: 3.11.x 
+*	   date			: apil 2015
+*	   version		: 1.0
+*
+*	Check Release Notes for information on what has changed in the new
+*	version.
+*/
+#include <linux/platform_device.h>
+#include <../../../../arch/arm/mach-imx/hardware.h>
+#include <linux/irq.h>
+#include <linux/of_gpio.h>
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_reg.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/byteorder.h>
+#include <asm/serial.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include "linux/version.h"
+
+#define  CCM_BASE_ADDR 0x020c4000
+#define WEIM_BASE_ADDR 0x021b8000
+
+static int gpio_sysbus_int1;
+static int gpio_sysbus_int2;
+static int sysbus_int1_irq, sysbus_int2_irq;
+
+//#define ENABLE_RS485_AUTO_MODE  
+//#define UART_FCTR  0x01   
+
+#define _INLINE_ inline
+
+#define SERIALEXAR_SHARE_IRQS 1
+unsigned int share_irqs = SERIALEXAR_SHARE_IRQS;
+
+#define UART_XR275x_NR	2
+
+#define XR_275x_MAJOR       40
+#define XR_275x_MINOR       0
+
+#define PASS_LIMIT	256
+
+/*
+ * We default to IRQ0 for the "no irq" hack.   Some
+ * machine types want others as well - they're free
+ * to redefine this in their header file.
+ */
+#define is_real_interrupt(irq)	((irq) != 0)
+
+
+struct uart_xr_port {
+	struct uart_port	port;
+	struct timer_list	timer;		/* "no irq" timer */
+	struct list_head	list;		/* ports on this IRQ */
+	unsigned int		capabilities;	/* port capabilities */
+	unsigned short		rev;
+	unsigned char		acr;
+	unsigned char		ier;
+	unsigned char		lcr;
+	unsigned char		mcr_mask;	/* mask of user bits */
+	unsigned char		mcr_force;	/* mask of forced bits */
+	unsigned char		lsr_break_flag;
+
+	/*
+	 * We provide a per-port pm hook.
+	 */
+	void			(*pm)(struct uart_port *port,
+				      unsigned int state, unsigned int old);
+};
+
+struct irq_info {
+	spinlock_t		lock;
+	struct list_head	*head;
+};
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 8, 0)
+struct serial_uart_config {
+	char	*name;
+	int	dfl_xmit_fifo_size;
+	int	flags;
+};
+#endif
+
+static struct irq_info irq_lists[NR_IRQS];
+
+/*
+ * Here we define the default xmit fifo size used for each type of UART.
+ */
+#define PORT_MAX_XR 1 
+#define XR275x_TYPE 1 // the second entry that is [1] in the array
+static const struct serial_uart_config uart_config[PORT_MAX_XR+1] = {
+	{ "Unknown",	1,	0 },
+	{ "XR275x",		64,	0 },
+};
+
+void __iomem *in_membase_prev = 0;
+int in_offset_prev = -1;
+
+static _INLINE_ unsigned int serial_in(struct uart_xr_port *up, int offset)
+{
+	offset <<= up->port.regshift;
+
+	switch (up->port.iotype) {
+	case SERIAL_IO_HUB6:
+		outb(up->port.hub6 - 1 + offset, up->port.iobase);
+		return inb(up->port.iobase + 1);
+
+	case SERIAL_IO_MEM:
+		return readb(up->port.membase + offset);
+
+	default:
+		return inb(up->port.iobase + offset);
+	}
+}
+
+void __iomem *out_membase_prev = 0;
+int out_offset_prev = -1;
+int out_value=-1;
+
+static _INLINE_ void
+serial_out(struct uart_xr_port *up, int offset, int value)
+{
+	offset <<= up->port.regshift;
+
+	switch (up->port.iotype) {
+	case SERIAL_IO_HUB6:
+		outb(up->port.hub6 - 1 + offset, up->port.iobase);
+		outb(value, up->port.iobase + 1);
+		break;
+
+	case SERIAL_IO_MEM:
+		writeb(value, up->port.membase + offset);
+		break;
+
+	default:
+		outb(value, up->port.iobase + offset);
+	}
+}
+
+/*
+ * We used to support using pause I/O for certain machines.  We
+ * haven't supported this for a while, but just in case it's badly
+ * needed for certain old 386 machines, I've left these #define's
+ * in....
+ */
+#define serial_inp(up, offset)		serial_in(up, offset)
+#define serial_outp(up, offset, value)	serial_out(up, offset, value)
+
+static void serialxr275x_stop_tx(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+
+	if (up->ier & UART_IER_THRI) {
+		up->ier &= ~UART_IER_THRI;
+		serial_out(up, UART_IER, up->ier);
+	}
+}
+
+static void serialxr275x_start_tx(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+
+	if (!(up->ier & UART_IER_THRI)) {
+		up->ier |= UART_IER_THRI;
+		serial_out(up, UART_IER, up->ier);
+	}
+}
+
+static void serialxr275x_stop_rx(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+
+	up->ier &= ~UART_IER_RLSI;
+	up->port.read_status_mask &= ~UART_LSR_DR;
+	serial_out(up, UART_IER, up->ier);
+}
+
+static void serialxr275x_enable_ms(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+
+	up->ier |= UART_IER_MSI;
+	serial_out(up, UART_IER, up->ier);
+}
+
+static _INLINE_ void
+receive_chars(struct uart_xr_port *up, int *status)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 9, 0)	
+	struct uart_port *port = &up->port;
+#else
+	struct tty_struct *tty = up->port.state->port.tty;
+#endif
+	unsigned char ch, lsr = *status;
+	int max_count = 256;
+	char flag;
+
+	do {
+		ch = serial_inp(up, UART_RX);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(lsr & (UART_LSR_BI | UART_LSR_PE |
+				    UART_LSR_FE | UART_LSR_OE))) {
+			/*
+			 * For statistics only
+			 */
+			if (lsr & UART_LSR_BI) {
+				lsr &= ~(UART_LSR_FE | UART_LSR_PE);
+				up->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(&up->port))
+					goto ignore_char;
+			} else if (lsr & UART_LSR_PE)
+				up->port.icount.parity++;
+			else if (lsr & UART_LSR_FE)
+				up->port.icount.frame++;
+			if (lsr & UART_LSR_OE)
+				up->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ingored.
+			 */
+			lsr &= up->port.read_status_mask;
+
+			if (lsr & UART_LSR_BI) {
+				//DEBUG_INTR("handling break....");
+				flag = TTY_BREAK;
+			} else if (lsr & UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (lsr & UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+		if (uart_handle_sysrq_char(&up->port, ch))
+			goto ignore_char;
+
+		uart_insert_char(&up->port, lsr, UART_LSR_OE, ch, flag);
+
+	ignore_char:
+		lsr = serial_inp(up, UART_LSR);
+	} while ((lsr & UART_LSR_DR) && (max_count-- > 0));
+	spin_unlock(&up->port.lock);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 9, 0)
+	tty_flip_buffer_push(&port->state->port);
+#else
+	tty_flip_buffer_push(tty);
+#endif
+	spin_lock(&up->port.lock);
+	*status = lsr;
+}
+
+static _INLINE_ void transmit_chars(struct uart_xr_port *up)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int count;
+
+	if (up->port.x_char) {
+		serial_outp(up, UART_TX, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
+		serialxr275x_stop_tx(&up->port);
+		return;
+	}
+
+	count = up->port.fifosize;
+	do {
+		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+	
+	if (uart_circ_empty(xmit))
+		serialxr275x_stop_tx(&up->port);
+}
+
+static _INLINE_ void check_modem_status(struct uart_xr_port *up)
+{
+	int status;
+
+	status = serial_in(up, UART_MSR);
+
+	if ((status & UART_MSR_ANY_DELTA) == 0)
+		return;
+
+	if (status & UART_MSR_TERI)
+		up->port.icount.rng++;
+	if (status & UART_MSR_DDSR)
+		up->port.icount.dsr++;
+	if (status & UART_MSR_DDCD)
+		uart_handle_dcd_change(&up->port, status & UART_MSR_DCD);
+	if (status & UART_MSR_DCTS)
+		uart_handle_cts_change(&up->port, status & UART_MSR_CTS);
+
+	wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+}
+
+/*
+ * This handles the interrupt from one port.
+ */
+static inline void
+serialxr275x_handle_port(struct uart_xr_port *up)
+{
+	unsigned int status = serial_inp(up, UART_LSR);
+
+	if (status & UART_LSR_DR)
+		receive_chars(up, &status);
+	check_modem_status(up);
+	if (status & UART_LSR_THRE)
+		transmit_chars(up);
+}
+
+/*
+ * This is the serial driver's interrupt routine.
+ *
+ * Arjan thinks the old way was overly complex, so it got simplified.
+ * Alan disagrees, saying that need the complexity to handle the weird
+ * nature of ISA shared interrupts.  (This is a special exception.)
+ *
+ * In order to handle ISA shared interrupts properly, we need to check
+ * that all ports have been serviced, and therefore the ISA interrupt
+ * line has been de-asserted.
+ *
+ * This means we need to loop through all ports. checking that they
+ * don't have an interrupt pending.
+ */
+static irqreturn_t serialxr275x_interrupt(int irq, void *dev_id)
+{
+	struct irq_info *i = dev_id;
+	struct list_head *l, *end = NULL;
+	int pass_counter = 0;
+
+	spin_lock(&i->lock);
+
+	l = i->head;
+	do {
+		struct uart_xr_port *up;
+		unsigned int iir;
+		
+		up = list_entry(l, struct uart_xr_port, list);
+		iir = serial_in(up, UART_IIR);
+
+		if (!(iir & UART_IIR_NO_INT)) {
+			spin_lock(&up->port.lock);
+			serialxr275x_handle_port(up);
+			spin_unlock(&up->port.lock);
+
+			end = NULL;
+		} else if (end == NULL)
+			end = l;
+
+		l = l->next;
+
+		if (l == i->head && pass_counter++ > PASS_LIMIT) {
+			/* If we hit this, we're dead. */
+			printk(KERN_ERR "serialxr275x: too much work for "
+				"irq%d\n", irq);
+			break;
+		}
+	} while (l != end);
+
+	spin_unlock(&i->lock);
+
+	//DEBUG_INTR("end.\n");
+	/* FIXME! Was it really ours? */
+	return IRQ_HANDLED;
+}
+
+/*
+ * To support ISA shared interrupts, we need to have one interrupt
+ * handler that ensures that the IRQ line has been deasserted
+ * before returning.  Failing to do this will result in the IRQ
+ * line being stuck active, and, since ISA irqs are edge triggered,
+ * no more IRQs will be seen.
+ */
+static void serial_do_unlink(struct irq_info *i, struct uart_xr_port *up)
+{
+	spin_lock_irq(&i->lock);
+
+	if (!list_empty(i->head)) {
+		if (i->head == &up->list)
+			i->head = i->head->next;
+		list_del(&up->list);
+	} else {
+		BUG_ON(i->head != &up->list);
+		i->head = NULL;
+	}
+
+	spin_unlock_irq(&i->lock);
+}
+
+static void set_serial_irq_type(int irq) {	
+	if(irq == sysbus_int1_irq)
+		irq_set_irq_type(sysbus_int1_irq, IRQ_TYPE_LEVEL_HIGH);
+	else if(irq == sysbus_int2_irq)
+		irq_set_irq_type(sysbus_int2_irq, IRQ_TYPE_LEVEL_HIGH);
+	else
+		printk("\n[set_serial_irq_type] Error irq:%d\n", irq);
+}
+
+static int serial_link_irq_chain(struct uart_xr_port *up)
+{
+	struct irq_info *i = irq_lists + up->port.irq;
+	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+
+	spin_lock_irq(&i->lock);
+
+	if (i->head) {
+		list_add(&up->list, i->head);
+		spin_unlock_irq(&i->lock);
+
+		ret = 0;
+	} else {
+		INIT_LIST_HEAD(&up->list);
+		i->head = &up->list;
+		spin_unlock_irq(&i->lock);
+
+#if 0 //alex
+		ret = request_irq(up->port.irq, serialxr275x_interrupt,
+				  irq_flags, "xrserial", i);
+#else
+		set_serial_irq_type(up->port.irq);
+		ret = request_irq(up->port.irq, serialxr275x_interrupt,
+				  irq_flags|IRQF_TRIGGER_HIGH, "xrserial", i);
+#endif
+
+		if (ret < 0)
+			serial_do_unlink(i, up);
+	}
+
+	return ret;
+}
+
+static void serial_unlink_irq_chain(struct uart_xr_port *up)
+{
+	struct irq_info *i = irq_lists + up->port.irq;
+
+	BUG_ON(i->head == NULL);
+
+	if (list_empty(i->head))
+		free_irq(up->port.irq, i);
+
+	serial_do_unlink(i, up);
+}
+
+/*
+ * This function is used to handle ports that do not have an
+ * interrupt.  This doesn't work very well for 16450's, but gives
+ * barely passable results for a 16550A.  (Although at the expense
+ * of much CPU overhead).
+ */
+static void serialxr275x_timeout(unsigned long data)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)data;
+	unsigned int timeout;
+	unsigned int iir;
+	
+	iir = serial_in(up, UART_IIR);
+	if (!(iir & UART_IIR_NO_INT)) {
+		spin_lock(&up->port.lock);
+		serialxr275x_handle_port(up);
+		spin_unlock(&up->port.lock);
+	}
+
+	timeout = up->port.timeout;
+	timeout = timeout > 6 ? (timeout / 2 - 2) : 1;
+	mod_timer(&up->timer, jiffies + timeout);
+}
+
+static unsigned int serialxr275x_tx_empty(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	unsigned long flags;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	ret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return ret;
+}
+
+static unsigned int serialxr275x_get_mctrl(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	unsigned long flags;
+	unsigned char status;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	status = serial_in(up, UART_MSR);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	ret = 0;
+	if (status & UART_MSR_DCD)
+		ret |= TIOCM_CAR;
+	if (status & UART_MSR_RI)
+		ret |= TIOCM_RNG;
+	if (status & UART_MSR_DSR)
+		ret |= TIOCM_DSR;
+	if (status & UART_MSR_CTS)
+		ret |= TIOCM_CTS;
+	return ret;
+}
+
+static void serialxr275x_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	unsigned char mcr = 0;
+
+	if (mctrl & TIOCM_RTS)
+		mcr |= UART_MCR_RTS;
+	if (mctrl & TIOCM_DTR)
+		mcr |= UART_MCR_DTR;
+	if (mctrl & TIOCM_OUT1)
+		mcr |= UART_MCR_OUT1;
+	if (mctrl & TIOCM_OUT2)
+		mcr |= UART_MCR_OUT2;
+	if (mctrl & TIOCM_LOOP)
+		mcr |= UART_MCR_LOOP;
+
+	mcr = (mcr & up->mcr_mask) | up->mcr_force;
+
+	serial_out(up, UART_MCR, mcr);
+}
+
+static void serialxr275x_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (break_state == -1)
+		up->lcr |= UART_LCR_SBC;
+	else
+		up->lcr &= ~UART_LCR_SBC;
+	serial_out(up, UART_LCR, up->lcr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int serialxr275x_startup(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	unsigned long flags;
+	int retval;
+
+#ifdef ENABLE_RS485_AUTO_MODE
+    unsigned char tmp;
+#endif
+
+	up->capabilities = uart_config[up->port.type].flags;
+
+	/*
+	 * Clear the FIFO buffers and disable them.
+	 * (they will be reeanbled in set_termios())
+	 */
+	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |
+			UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+
+	serial_outp(up, UART_FCR, 0);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) serial_inp(up, UART_LSR);
+	(void) serial_inp(up, UART_RX);
+	(void) serial_inp(up, UART_IIR);
+	(void) serial_inp(up, UART_MSR);
+
+	/*
+	 * If the "interrupt" for this port doesn't correspond with any
+	 * hardware interrupt, we use a timer-based system.  The original
+	 * driver used to do this with IRQ0.
+	 */
+	if (!is_real_interrupt(up->port.irq)) {
+		unsigned int timeout = up->port.timeout;
+
+		timeout = timeout > 6 ? (timeout / 2 - 2) : 1;
+
+		up->timer.data = (unsigned long)up;
+		mod_timer(&up->timer, jiffies + timeout);
+	} else {
+		retval = serial_link_irq_chain(up);
+		if (retval)
+			return retval;
+	}
+	
+#ifdef ENABLE_RS485_AUTO_MODE
+    serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_B);
+	tmp = serial_in(up, UART_FCTR);
+	tmp |= (1<<3);//enable Auto RS485 Half-Duplex
+	serial_outp(up, UART_FCTR, tmp);
+#endif	
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_outp(up, UART_LCR, UART_LCR_WLEN8);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+		
+	/*
+	* Most PC uarts need OUT2 raised to enable interrupts.
+	*/
+	if (is_real_interrupt(up->port.irq))
+		up->port.mctrl |= TIOCM_OUT2;
+
+	serialxr275x_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/*
+	 * Finally, enable interrupts.  Note: Modem status interrupts
+	 * are set via set_termios(), which will be occurring imminently
+	 * anyway, so we don't enable them here.
+	 */
+	up->ier = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;	
+	serial_outp(up, UART_IER, up->ier);
+
+	/*
+	 * And clear the interrupt registers again for luck.
+	 */
+	(void) serial_inp(up, UART_LSR);
+	(void) serial_inp(up, UART_RX);
+	(void) serial_inp(up, UART_IIR);
+	(void) serial_inp(up, UART_MSR);
+
+	return 0;
+}
+
+static void serialxr275x_shutdown(struct uart_port *port)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	unsigned long flags;
+	
+	/*
+	 * Disable interrupts from this port
+	 */
+	up->ier = 0;
+	serial_outp(up, UART_IER, 0);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	
+	up->port.mctrl &= ~TIOCM_OUT2;
+
+	serialxr275x_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/*
+	 * Disable break condition and FIFOs
+	 */
+	serial_out(up, UART_LCR, serial_inp(up, UART_LCR) & ~UART_LCR_SBC);
+	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |
+				  UART_FCR_CLEAR_RCVR |
+				  UART_FCR_CLEAR_XMIT);
+	serial_outp(up, UART_FCR, 0);
+
+	/*
+	 * Read data port to reset things, and then unlink from
+	 * the IRQ chain.
+	 */
+	(void) serial_in(up, UART_RX);
+
+	if (!is_real_interrupt(up->port.irq))
+		del_timer_sync(&up->timer);
+	else
+		serial_unlink_irq_chain(up);
+}
+
+static unsigned int serialxr275x_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	unsigned int quot;
+
+	quot = uart_get_divisor(port, baud);
+
+	return quot;
+}
+
+static void
+serialxr275x_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	unsigned char cval;
+	unsigned long flags;
+	unsigned int baud, quot, quot_fraction;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		cval = 0x00;
+		break;
+	case CS6:
+		cval = 0x01;
+		break;
+	case CS7:
+		cval = 0x02;
+		break;
+	default:
+	case CS8:
+		cval = 0x03;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		cval |= 0x04;
+	if (termios->c_cflag & PARENB)
+		cval |= UART_LCR_PARITY;
+	if (!(termios->c_cflag & PARODD))
+		cval |= UART_LCR_EPAR;
+#ifdef CMSPAR
+	if (termios->c_cflag & CMSPAR)
+		cval |= UART_LCR_SPAR;
+#endif
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
+	quot = serialxr275x_get_divisor(port, baud);
+	quot_fraction = ( (port->uartclk/baud) - (16*quot));
+	
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	up->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= UART_LSR_BI;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= UART_LSR_OE;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= UART_LSR_DR;
+
+	/*
+	 * CTS flow control flag and modem status interrupts
+	 */
+	up->ier &= ~UART_IER_MSI;
+	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
+		up->ier |= UART_IER_MSI;
+
+	serial_out(up, UART_IER, up->ier);
+
+	serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+	
+	serial_outp(up, UART_DLL, quot & 0xff);		/* LS of divisor */
+	serial_outp(up, UART_DLM, quot >> 8);		/* MS of divisor */
+
+	serial_outp(up, UART_LCR, cval);		/* reset DLAB */
+	up->lcr = cval;					/* Save LCR */
+	
+	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);/* set fcr */
+	
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+/*
+ *      EXAR ioctls
+ */
+//#define 	FIOQSIZE		0x5460 
+#define		EXAR_READ_REG      	(FIOQSIZE + 1)
+#define 	EXAR_WRITE_REG     	(FIOQSIZE + 2)
+
+struct xrioctl_rw_reg {
+	unsigned char reg;
+	unsigned char regvalue;
+};
+/*
+ * This function is used to handle Exar Device specific ioctl calls
+ * The user level application should have defined the above ioctl
+ * commands with the above values to access these ioctls and the 
+ * input parameters for these ioctls should be struct xrioctl_rw_reg
+ * The Ioctl functioning is pretty much self explanatory here in the code,
+ * and the register values should be standard UART offsets.
+ */
+
+static int
+serialxr275x_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	int ret = -ENOIOCTLCMD;
+	struct xrioctl_rw_reg ioctlrwarg;
+
+	switch (cmd)
+	{
+		case EXAR_READ_REG:
+		if (copy_from_user(&ioctlrwarg, (void *)arg, sizeof(ioctlrwarg)))
+			return -EFAULT;
+		ioctlrwarg.regvalue = serial_inp(up, ioctlrwarg.reg);
+		if (copy_to_user((void *)arg, &ioctlrwarg, sizeof(ioctlrwarg)))
+			return -EFAULT;
+		ret = 0;
+		break;
+		
+		case EXAR_WRITE_REG:
+		if (copy_from_user(&ioctlrwarg, (void *)arg, sizeof(ioctlrwarg)))
+			return -EFAULT;
+		serial_outp(up, ioctlrwarg.reg, ioctlrwarg.regvalue);
+		ret = 0;
+		break;
+	}
+	
+	return ret;
+}
+	      
+static void
+serialxr275x_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	if (state) {
+		/* sleep */
+		serial_outp(up, UART_IER, UART_IERX_SLEEP);
+						
+		if (up->pm)
+			up->pm(port, state, oldstate);
+	} else {
+		/* wake */
+		
+		/* Wake up UART */
+		serial_outp(up, UART_IER, 0);
+		
+		if (up->pm)
+			up->pm(port, state, oldstate);
+	}
+}
+
+static void serialxr275x_release_port(struct uart_port *port)
+{	
+}
+
+static int serialxr275x_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void serialxr275x_config_port(struct uart_port *port, int flags)
+{
+	struct uart_xr_port *up = (struct uart_xr_port *)port;
+	
+	if (flags & UART_CONFIG_TYPE)
+	{
+		up->port.type = XR275x_TYPE;
+		up->port.fifosize = uart_config[up->port.type].dfl_xmit_fifo_size;
+		up->capabilities = uart_config[up->port.type].flags;
+	}
+}
+
+static const char *
+serialxr275x_type(struct uart_port *port)
+{
+	int type = port->type;
+	
+	if (type >= ARRAY_SIZE(uart_config))
+		type = 0;
+	return uart_config[type].name;
+}
+
+static struct uart_ops serialxr275x_pops = {
+	.tx_empty	= serialxr275x_tx_empty,
+	.set_mctrl	= serialxr275x_set_mctrl,
+	.get_mctrl	= serialxr275x_get_mctrl,
+	.stop_tx	= serialxr275x_stop_tx,
+	.start_tx	= serialxr275x_start_tx,
+	.stop_rx	= serialxr275x_stop_rx,
+	.enable_ms	= serialxr275x_enable_ms,
+	.break_ctl	= serialxr275x_break_ctl,
+	.startup	= serialxr275x_startup,
+	.shutdown	= serialxr275x_shutdown,
+	.set_termios	= serialxr275x_set_termios,
+	.pm		= serialxr275x_pm,
+	.type		= serialxr275x_type,
+	.release_port	= serialxr275x_release_port,
+	.request_port	= serialxr275x_request_port,
+	.config_port	= serialxr275x_config_port,
+	.ioctl		= serialxr275x_ioctl,
+};
+
+static struct uart_xr_port serialxr275x_ports[UART_XR275x_NR];
+
+#define XR275x_BASE1		0x08000000
+#define XR275x_BASE2		0x0C000000
+#define XR275x_UART_OFFSET 	0x4000000 //64 MB
+
+static int Get_IRQ_Num(int num)
+{
+	if(num == 0)
+	{
+		sysbus_int1_irq = gpio_to_irq(gpio_sysbus_int1);
+
+		if (sysbus_int1_irq < 0)
+		{
+			printk("\n[Get_IRQ_Num] Get error sysbus_int1_irq\n");
+			return 0;
+		}
+
+		return sysbus_int1_irq;
+	}
+	else if(num == 1)
+	{	
+		sysbus_int2_irq = gpio_to_irq(gpio_sysbus_int2);
+
+		if (sysbus_int1_irq < 0)
+		{
+			printk("\n[Get_IRQ_Num] Get error sysbus_int2_irq\n");
+			return 0;
+		}
+
+		return sysbus_int2_irq;
+	}
+	else
+	{
+		printk("\n[Get_IRQ_Num] Error Num:%d\n", num);
+		return 0;
+	}
+}
+
+static void __init serial275x_init_ports(void)
+{
+	struct uart_xr_port *up;
+	static int first = 1;
+	int i;
+	
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0, up = serialxr275x_ports; i < ARRAY_SIZE(serialxr275x_ports);
+	     i++, up++) {
+		up->port.iobase   = 0; 
+
+		if(i == 0)
+			up->port.mapbase = 	XR275x_BASE1;
+		else if (i == 1)
+			up->port.mapbase = 	XR275x_BASE2;
+
+		up->port.irq      = Get_IRQ_Num(i);
+		up->port.uartclk  = 921600 * 16; // 14.7 MHz clock rate
+		up->port.flags    = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;
+		up->port.hub6     = 0;
+		up->port.membase  = ioremap(XR275x_BASE1 + (i*XR275x_UART_OFFSET), XR275x_UART_OFFSET);  // memory mapped
+		up->port.iotype   = SERIAL_IO_MEM; 
+		up->port.regshift = 2; // Address Data Line Shift - SYSBUS_A2 start
+		up->port.ops      = &serialxr275x_pops;
+		
+		if (share_irqs)
+			up->port.flags |= UPF_SHARE_IRQ;
+	}
+//for (i=0; i<8; i++)  
+//   printk(KERN_INFO "xr16m275x.c: membase UART reg offset %d=0x%x\n",i,readb((port->membase) + i));
+}
+
+static void __init serialxr275x_register_ports(struct uart_driver *drv)
+{
+	int i;
+	
+	serial275x_init_ports();
+	
+	for (i = 0; i < UART_XR275x_NR; i++) {
+		struct uart_xr_port *up = &serialxr275x_ports[i];
+
+		up->port.line = i;
+		up->port.ops = &serialxr275x_pops;
+		init_timer(&up->timer);
+		up->timer.function = serialxr275x_timeout;
+		
+		/*
+		 * ALPHA_KLUDGE_MCR needs to be killed.
+		 */
+		up->mcr_mask = ~(0x0); //~ALPHA_KLUDGE_MCR;
+		up->mcr_force = 0; // ALPHA_KLUDGE_MCR;
+		uart_add_one_port(drv, &up->port);
+	}
+}
+
+#define SERIALXR_CONSOLE	NULL
+
+static struct uart_driver serialxr275x_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "xrserial",
+	.dev_name		= "ttyS",
+	.major			= XR_275x_MAJOR,
+	.minor			= XR_275x_MINOR,
+	.nr			= UART_XR275x_NR,
+	.cons			= SERIALXR_CONSOLE,
+};
+
+static int serialxr275x_init(void)
+{
+	int ret, i;
+
+	printk(KERN_INFO "XR16M275x specific serial driver $Revision: 1.0 $ "
+		"%d ports, IRQ sharing %sabled\n", (int) UART_XR275x_NR,
+		share_irqs ? "en" : "dis");
+
+	for (i = 0; i < NR_IRQS; i++)
+		spin_lock_init(&irq_lists[i].lock);
+
+	ret = uart_register_driver(&serialxr275x_reg);
+	
+	if (ret >= 0)
+		serialxr275x_register_ports(&serialxr275x_reg);
+		
+	return ret;
+}
+
+static void serialxr275x_exit(void)
+{
+	int i;
+			
+	for (i = 0; i < UART_XR275x_NR; i++)
+		uart_remove_one_port(&serialxr275x_reg, &serialxr275x_ports[i].port);
+	
+	uart_unregister_driver(&serialxr275x_reg);
+}
+
+/* Config CS0 and CS1 settings */
+static void weim_cs_config(void)
+{
+	u32 reg;
+	void __iomem *weim_base, *iomuxc_base;
+
+	weim_base = ioremap(WEIM_BASE_ADDR, SZ_4K);
+
+	/* CS0 */
+	writel(0x7E20001, (weim_base)); //8 bit port resides on DATA[23:16]
+	writel(0x0, (weim_base + 0x4));
+	writel(0x16004422, (weim_base + 0x8));
+	writel(0x00000002, (weim_base + 0xC));
+	writel(0x16002982, (weim_base + 0x10));
+	writel(0x00000000, (weim_base + 0x14));
+	writel(0x00000000, (weim_base + 0x90)); // interrupt high or low active - at present - low active
+
+	/* CS1 */
+	writel(0x7E20001, (weim_base + 0x18));
+	writel(0x0, (weim_base + 0x1C));
+	writel(0x16004422, (weim_base + 0x20));
+	writel(0x00000002, (weim_base + 0x24));
+	writel(0x16002982, (weim_base + 0x28));
+	writel(0x00000000, (weim_base + 0x2C));
+	writel(0x00000000, (weim_base + 0x90)); // interrupt high or low active - at present - low active
+
+	/* specify 64 MB on CS1 and CS0 on GPR1 */
+	iomuxc_base = ioremap(MX6Q_IOMUXC_BASE_ADDR, SZ_4K);
+	reg = readl(iomuxc_base + 0x4);
+	reg &= ~0x3F;
+	reg |= 0x1B;
+
+	writel(reg, (iomuxc_base + 0x4));
+
+	iounmap(iomuxc_base);
+	iounmap(weim_base);
+}
+
+static int adv_init_extuart(void)
+{
+	return serialxr275x_init();
+}
+
+static int adv_sysbus_uart_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int err;
+
+	gpio_sysbus_int1 = of_get_named_gpio(np, "sysbus-int1", 0);
+
+	if (!gpio_is_valid(gpio_sysbus_int1))
+	{
+		printk("\n[adv_sysbus_uart_probe] No gpio_sysbus_int1");
+		return -ENODEV;	
+	}
+
+	err = devm_gpio_request(&pdev->dev, gpio_sysbus_int1, "GPIO sysbus-int1");
+
+	if (err)
+	{
+		printk("\n[adv_sysbus_uart_probe] Request gpio_sysbus_int1 failed");
+		return err;
+	}
+
+	gpio_direction_input(gpio_sysbus_int1);
+
+	gpio_sysbus_int2 = of_get_named_gpio(np, "sysbus-int2", 0);
+
+	if (!gpio_is_valid(gpio_sysbus_int2))
+		return -ENODEV;	
+
+	err = devm_gpio_request(&pdev->dev, gpio_sysbus_int2, "GPIO sysbus-int2");
+
+	if (err)
+	{
+		printk("\n[adv_sysbus_uart_probe] Request gpio_sysbus_int2 failed");
+		return err;
+	}
+
+	gpio_direction_input(gpio_sysbus_int2);
+
+	weim_cs_config();
+
+	adv_init_extuart();
+	
+	return 0;
+}
+
+static int adv_sysbus_uart_remove(struct platform_device *pdev)
+{
+	serialxr275x_exit();
+
+	return 0;
+}
+
+static const struct of_device_id adv_sysbus_uart_dt_ids[] = {
+	{ .compatible = "adv-sysbus-uart", },
+	{},
+};
+
+static struct platform_driver adv_sysbus_uart_driver = {
+	.probe = adv_sysbus_uart_probe,
+	.remove	= adv_sysbus_uart_remove,
+	.driver = {
+		.name = "adv-sysbus-uart",
+		.owner = THIS_MODULE,
+		.of_match_table = adv_sysbus_uart_dt_ids,
+	},
+};
+
+static int __init adv_sysbus_uart_init(void)
+{
+	return platform_driver_register(&adv_sysbus_uart_driver);
+}
+
+static void __exit adv_sysbus_uart_exit(void)
+{
+	platform_driver_unregister(&adv_sysbus_uart_driver);
+}
+
+module_init(adv_sysbus_uart_init);
+module_exit(adv_sysbus_uart_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("XR16M275x specific serial driver $Revision: 1.0 $");
+MODULE_ALIAS("platform:Advantech System Bus Uart Driver");
+
Index: drivers/tty/serial/Kconfig
===================================================================
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
--- a/drivers/tty/serial/Kconfig	(revision 513)
+++ b/drivers/tty/serial/Kconfig	(revision 1734)
@@ -1484,6 +1484,11 @@
 	  If multiple cards are present, the default limit of 32 ports may
 	  need to be increased.
 
+config SERIAL_XR275X
+	tristate "XR275X serial port support"
+	help
+	  This driver supports the XR275X UART port.
+
 config SERIAL_FSL_LPUART
 	tristate "Freescale lpuart serial port support"
 	select SERIAL_CORE
Index: drivers/tty/serial/imx.c
===================================================================
diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
--- a/drivers/tty/serial/imx.c	(revision 513)
+++ b/drivers/tty/serial/imx.c	(revision 1734)
@@ -51,6 +51,7 @@
 #include <linux/dma-mapping.h>
 
 #include <asm/irq.h>
+#include <asm/uaccess.h>
 #include <linux/platform_data/serial-imx.h>
 #include <linux/platform_data/dma-imx.h>
 
@@ -72,6 +73,7 @@
 #define IMX21_ONEMS 0xb0 /* One Millisecond register */
 #define IMX1_UTS 0xd0 /* UART Test Register on i.mx1 */
 #define IMX21_UTS 0xb4 /* UART Test Register on all other i.mx*/
+#define UMCR  0xb8 /* UART RS-485 Mode Control Register */
 
 /* UART Control Register Bit Fields.*/
 #define URXD_CHARRDY	(1<<15)
@@ -169,6 +171,12 @@
 #define UTS_TXFULL	 (1<<4)	 /* TxFIFO full */
 #define UTS_RXFULL	 (1<<3)	 /* RxFIFO full */
 #define UTS_SOFTRST	 (1<<0)	 /* Software reset */
+#define UMCR_SLADDR_SHF 8       /* RS-485 slave address shift */
+#define UMCR_SLADDR_MASK	 0xFF  /* RS-485 slave address is 8 bits wide */
+#define UMCR_SADEN	 (1<<3)  /* RS-485 slave address detected interrupt enable */
+#define UMCR_TXB8	 (1<<2)  /* Transmit RS-485 bit 8 */
+#define UMCR_SLAM	 (1<<1)  /* RS-485 slave address detect mode selection */
+#define UMCR_MDEN	 (1<<0)  /* RS-485 mode enable */
 
 /* We've been assigned a range on the "Low-density serial ports" major */
 #define SERIAL_IMX_MAJOR	207
@@ -226,6 +234,10 @@
 	unsigned int		tx_bytes;
 	unsigned int		dma_tx_nents;
 	wait_queue_head_t	dma_wait;
+#ifdef CONFIG_ARCH_ADVANTECH
+	/* RS-485 fields */
+	struct serial_rs485	rs485;
+#endif
 };
 
 struct imx_port_ucrs {
@@ -298,7 +310,84 @@
 {
 	return sport->devdata->devtype == IMX6Q_UART;
 }
+
+#ifdef CONFIG_ARCH_ADVANTECH
 /*
+ * RS-485
+ */
+#define USE_RS485(sport) ((sport)->rs485.flags & SER_RS485_ENABLED)
+#define SLADDR 0xA5
+
+static void imx_rs485_stop_tx(struct imx_port *imx_uart_port)
+{
+	unsigned int temp;
+
+	temp = readl(imx_uart_port->port.membase + UCR2);
+	temp &= ~UCR2_CTS;
+	writel(temp, imx_uart_port->port.membase + UCR2);
+}
+
+static void imx_rs485_start_tx(struct imx_port *imx_uart_port)
+{
+	unsigned int temp;
+
+	temp = readl(imx_uart_port->port.membase + UCR2);
+	temp |= UCR2_CTS;
+	writel(temp, imx_uart_port->port.membase + UCR2);
+}
+
+/* 
+ * Enable or disable RS-485 support
+ */
+void imx_rs485_config(struct uart_port *port, struct serial_rs485 *rs485conf)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	unsigned long flags;
+	unsigned int temp;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* copy rs485 structure */
+	sport->rs485 = *rs485conf;
+
+	if (rs485conf->flags & SER_RS485_ENABLED) {
+		//printk(KERN_INFO "\nSet UART to RS-485\n");
+		/* Ignore RTS pin and set CTS as receiver mode by default */
+		temp = readl(port->membase + UCR2);
+		temp |= UCR2_IRTS;
+		temp &= ~UCR2_CTSC;
+		temp &= ~UCR2_CTS;
+		writel(temp, port->membase + UCR2);
+#if 0
+		/* Set UMCR for 9 bit RS-485 mode */
+		temp = readl(port->membase + UMCR);
+		temp &= ~(UMCR_SLADDR_MASK << UMCR_SLADDR_SHF);
+		temp |= SLADDR << UMCR_SLADDR_SHF;
+		temp &= ~UMCR_TXB8;
+		temp |= (UMCR_SADEN | UMCR_SLAM | UMCR_MDEN);
+		writel(temp, port->membase + UMCR);
+#endif
+	} else {
+		//printk(KERN_INFO "\nSet UART to RS-232\n");
+		/* Enable CTS Pin Control */
+		temp = readl(port->membase + UCR2);
+		temp &= ~UCR2_IRTS;
+		temp |= UCR2_CTSC;
+		writel(temp, port->membase + UCR2);
+#if 0
+		/* Set UMCR back to RS-232 */
+		temp = readl(port->membase + UMCR);
+		temp &= ~(UMCR_SLADDR_MASK << UMCR_SLADDR_SHF);
+		temp &= ~(UMCR_SADEN | UMCR_TXB8 | UMCR_SLAM | UMCR_MDEN);
+		writel(temp, port->membase + UMCR);
+#endif
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+#endif
+
+/*
  * Save and restore functions for UCR1, UCR2 and UCR3 registers
  */
 #if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_IMX_CONSOLE)
@@ -374,7 +463,11 @@
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_IRDA(sport) || USE_RS485(sport)) {
+#else
 	if (USE_IRDA(sport)) {
+#endif
 		/* half duplex - wait for end of transmission */
 		int n = 256;
 		while ((--n > 0) &&
@@ -382,11 +475,18 @@
 			udelay(5);
 			barrier();
 		}
+#ifdef CONFIG_ARCH_ADVANTECH
+		if (USE_RS485(sport)) {
+			imx_rs485_stop_tx(sport);
+		}
+#endif
 		/*
 		 * irda transceiver - wait a bit more to avoid
 		 * cutoff, hardware dependent
 		 */
-		udelay(sport->trcv_delay);
+		if (USE_IRDA(sport)) {
+			udelay(sport->trcv_delay);
+		}
 
 		/*
 		 * half duplex - reactivate receive mode,
@@ -564,7 +664,11 @@
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_IRDA(sport) || USE_RS485(sport)) {
+#else
 	if (USE_IRDA(sport)) {
+#endif
 		/* half duplex in IrDA mode; have to disable receive mode */
 		temp = readl(sport->port.membase + UCR4);
 		temp &= ~(UCR4_DREN);
@@ -586,8 +690,11 @@
 		temp = readl(sport->port.membase + UCR1);
 		writel(temp | UCR1_TXMPTYEN, sport->port.membase + UCR1);
 	}
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_IRDA(sport) || USE_RS485(sport)) {
+#else
 	if (USE_IRDA(sport)) {
+#endif
 		temp = readl(sport->port.membase + UCR1);
 		temp |= UCR1_TRDYEN;
 		writel(temp, sport->port.membase + UCR1);
@@ -596,7 +703,11 @@
 		temp |= UCR4_TCEN;
 		writel(temp, sport->port.membase + UCR4);
 	}
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_RS485(sport)) {
+		imx_rs485_start_tx(sport);
+	}
+#endif
 	if (sport->dma_is_enabled) {
 		imx_dma_tx(sport);
 		return;
@@ -817,6 +928,10 @@
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_RS485(sport))
+		return;
+#endif
 	temp = readl(sport->port.membase + UCR2) & ~UCR2_CTS;
 
 	if (mctrl & TIOCM_RTS)
@@ -1250,7 +1365,14 @@
 		if (pdata->irda_enable)
 			pdata->irda_enable(0);
 	}
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	/* Turn back to RS-232 when the port closes */
+	if (USE_RS485(sport)) {
+		imx_rs485_stop_tx(sport);
+		sport->rs485.flags &= ~SER_RS485_ENABLED;
+		imx_rs485_config(port, &sport->rs485);
+	}
+#endif
 	/*
 	 * Stop our timer.
 	 */
@@ -1539,6 +1661,38 @@
 	return ret;
 }
 
+#ifdef CONFIG_ARCH_ADVANTECH
+/*
+ * Handle TIOCSRS485 & TIOCSRS485 ioctl for RS-485 support
+ */
+static int imx_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	struct serial_rs485 rs485conf;
+	struct imx_port *sport = (struct imx_port *)port;
+
+	switch (cmd) {
+		case TIOCSRS485:
+			if (copy_from_user(&rs485conf,
+			    (struct serial_rs485 *) arg,
+			    sizeof(rs485conf)))
+				return -EFAULT;
+			imx_rs485_config(port, &rs485conf);
+			break;
+
+		case TIOCGRS485:
+			if (copy_to_user((struct serial_rs485 *) arg,
+			    &(sport->rs485),
+			    sizeof(rs485conf)))
+				return -EFAULT;
+			break;
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+#endif
+
 #if defined(CONFIG_CONSOLE_POLL)
 static int imx_poll_get_char(struct uart_port *port)
 {
@@ -1621,6 +1775,9 @@
 	.request_port	= imx_request_port,
 	.config_port	= imx_config_port,
 	.verify_port	= imx_verify_port,
+#if defined(CONFIG_ARCH_ADVANTECH)
+	.ioctl		= imx_ioctl,
+#endif
 #if defined(CONFIG_CONSOLE_POLL)
 	.poll_get_char  = imx_poll_get_char,
 	.poll_put_char  = imx_poll_put_char,
Index: drivers/net/phy/phy.c
===================================================================
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
--- a/drivers/net/phy/phy.c	(revision 513)
+++ b/drivers/net/phy/phy.c	(revision 1734)
@@ -397,6 +397,10 @@
 	if (AUTONEG_DISABLE == phydev->autoneg)
 		phy_sanitize_settings(phydev);
 
+	if (phydev->state == PHY_DOWN) {
+ 		goto out_unlock;
+	}
+
 	err = phydev->drv->config_aneg(phydev);
 
 	if (err < 0)
Index: drivers/net/phy/realtek.c
===================================================================
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
--- a/drivers/net/phy/realtek.c	(revision 513)
+++ b/drivers/net/phy/realtek.c	(revision 1734)
@@ -23,7 +23,11 @@
 #define RTL821x_INER_INIT	0x6400
 #define RTL821x_INSR		0x13
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#define	RTL8211E_INER_LINK_STAT	0x400
+#else
 #define	RTL8211E_INER_LINK_STAT	0x10
+#endif
 
 MODULE_DESCRIPTION("Realtek PHY driver");
 MODULE_AUTHOR("Johnson Leung");
Index: drivers/net/ethernet/freescale/fec_main.c
===================================================================
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
--- a/drivers/net/ethernet/freescale/fec_main.c	(revision 513)
+++ b/drivers/net/ethernet/freescale/fec_main.c	(revision 1734)
@@ -63,6 +63,11 @@
 
 #include "fec.h"
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#include <linux/proc_fs.h>
+struct platform_device *gdev= NULL;
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 #include <linux/busfreq-imx6.h>
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
@@ -1109,12 +1114,14 @@
 			const char *mac = of_get_mac_address(np);
 			if (mac)
 				iap = (unsigned char *) mac;
-		}
+		}				
 	}
 
 	/*
 	 * 3) from flash or fuse (via platform data)
 	 */
+#ifndef CONFIG_ARCH_ADVANTECH
+/* we use 3 to set mac address without OCTOP */	 	 
 	if (!is_valid_ether_addr(iap)) {
 #ifdef CONFIG_M5272
 		if (FEC_FLASHMAC)
@@ -1124,7 +1131,7 @@
 			iap = (unsigned char *)&pdata->mac;
 #endif
 	}
-
+#endif
 	/*
 	 * 4) FEC mac registers set by bootloader
 	 */
@@ -1389,7 +1396,15 @@
 	 * Reference Manual has an error on this, and gets fixed on i.MX6Q
 	 * document.
 	 */
+	/*
+	 * Fixed Freescale S6-0027 issue:
+	   MDC frequency setting value and actual measured value are difference between the two
+	 */	 
+#if defined (CONFIG_ARCH_ADVANTECH)
+	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->clk_ipg), FEC_ENET_MII_CLK);
+#else	 
 	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->clk_ipg), 5000000);
+#endif	
 	if (id_entry->driver_data & FEC_QUIRK_ENET_MAC)
 		fep->phy_speed--;
 	fep->phy_speed <<= 1;
@@ -2138,7 +2153,75 @@
 	}
 }
 
+#ifdef CONFIG_ARCH_ADVANTECH
+extern char board_type[12];
+
 static int
+fec_proc_write(struct file *file, const char __user * buffer,
+               size_t count, loff_t *offset)                  
+{
+    int i;
+    char line[8];
+    int ret;
+    struct platform_device *pdev = (struct platform_device *)gdev;
+    struct net_device *ndev = platform_get_drvdata(pdev);
+    struct fec_enet_private *fep = netdev_priv(ndev);
+
+       ret = copy_from_user(line, buffer, count);
+       if (ret)
+               return -EFAULT;
+
+    for (i = 0 ; i < PHY_MAX_ADDR; i++)
+    {
+        if (fep->mii_bus->phy_map[i])
+            break;
+    }
+
+	if(!strcmp(board_type, "UBC-220"))
+	{
+		/* Access RTL8211E internal register to measure IEEE waveform */
+		fep->mii_bus->write(fep->mii_bus, i, 0x1f, 0x0005);
+		fep->mii_bus->write(fep->mii_bus, i, 0x05, 0x8b86);
+		fep->mii_bus->write(fep->mii_bus, i, 0x06, 0xe200);
+		fep->mii_bus->write(fep->mii_bus, i, 0x1f, 0x0007);
+		fep->mii_bus->write(fep->mii_bus, i, 0x1e, 0x0020);
+		fep->mii_bus->write(fep->mii_bus, i, 0x15, 0x0108);
+		fep->mii_bus->write(fep->mii_bus, i, 0x1f, 0x0000);
+	}
+	else
+	{
+    	fep->mii_bus->write(fep->mii_bus, i, 0x1d, 0x000b);
+    	fep->mii_bus->write(fep->mii_bus, i, 0x1e, 0x0009);
+    	fep->mii_bus->write(fep->mii_bus, i, 0x00, 0x8140);
+	}
+	
+    if (strstr(line, "1"))
+    	fep->mii_bus->write(fep->mii_bus, i, 0x09, 0x2200);
+    else if (strstr(line, "2"))
+    	fep->mii_bus->write(fep->mii_bus, i, 0x09, 0x4200);	
+    else if (strstr(line, "3")	)
+    	fep->mii_bus->write(fep->mii_bus, i, 0x09, 0x6200);
+    else if (strstr(line, "4"))
+    	fep->mii_bus->write(fep->mii_bus, i, 0x09, 0x8200);
+    else
+      goto out; /* Disable test mode */		
+      
+      
+    //value = fep->mii_bus->read(fep->mii_bus, i, 0x09);
+    //printk("mii reg: 0x%x\n", value);
+    
+out:
+       return count;
+}
+
+static const struct file_operations net_testmode_fops = {
+	.owner = THIS_MODULE,
+	.write = fec_proc_write,
+};
+
+#endif
+
+static int
 fec_probe(struct platform_device *pdev)
 {
 	struct fec_enet_private *fep;
@@ -2148,6 +2231,9 @@
 	struct resource *r;
 	const struct of_device_id *of_id;
 	static int dev_id;
+#ifdef CONFIG_ARCH_ADVANTECH
+	struct proc_dir_entry *proc_entry = NULL;
+#endif
 
 	of_id = of_match_device(fec_dt_ids, &pdev->dev);
 	if (of_id)
@@ -2287,6 +2373,17 @@
 		netdev_info(ndev, "registered PHC device %d\n", fep->dev_id);
 
 	INIT_DELAYED_WORK(&(fep->delay_work.delay_work), fec_enet_work);
+
+#ifdef CONFIG_ARCH_ADVANTECH
+	gdev = pdev;
+	proc_entry = proc_create("net_testmode", 0777, NULL, &net_testmode_fops);
+/*
+	if (proc_entry) {
+		proc_entry->data = gdev;
+	}
+*/
+#endif
+	
 	return 0;
 
 failed_register:
Index: drivers/net/ethernet/freescale/fec.h
===================================================================
diff --git a/drivers/net/ethernet/freescale/fec.h b/drivers/net/ethernet/freescale/fec.h
--- a/drivers/net/ethernet/freescale/fec.h	(revision 513)
+++ b/drivers/net/ethernet/freescale/fec.h	(revision 1734)
@@ -276,6 +276,10 @@
 #define FEC_ENET_TS_AVAIL       ((uint)0x00010000)
 #define FEC_ENET_TS_TIMER       ((uint)0x00008000)
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#define FEC_ENET_MII_CLK				((uint)2500000)
+#endif
+
 #define FEC_DEFAULT_IMASK (FEC_ENET_TXF | FEC_ENET_RXF | FEC_ENET_MII | FEC_ENET_TS_TIMER)
 #define FEC_RX_DISABLED_IMASK (FEC_DEFAULT_IMASK & (~FEC_ENET_RXF))
 
Index: drivers/usb/serial/option.c
===================================================================
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
--- a/drivers/usb/serial/option.c	(revision 513)
+++ b/drivers/usb/serial/option.c	(revision 1734)
@@ -1223,6 +1223,9 @@
   	  .driver_info = (kernel_ulong_t)&four_g_w14_blacklist
   	},
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
+#ifdef CONFIG_ARCH_ADVANTECH
+	{ USB_DEVICE(0x1546, 0x1102) }, //for EWM-C109F601E
+#endif
 	{ USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_CE100) },
 	/* Pirelli  */
 	{ USB_DEVICE_INTERFACE_CLASS(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_C100_1, 0xff) },
Index: drivers/gpio/Makefile
===================================================================
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
--- a/drivers/gpio/Makefile	(revision 513)
+++ b/drivers/gpio/Makefile	(revision 1734)
@@ -87,3 +87,4 @@
 obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
+obj-$(CONFIG_GPIO_ARCH_ADVANTECH)	+= gpio-set-direction.o
Index: drivers/gpio/gpio-set-direction.c
===================================================================
diff --git a/drivers/gpio/gpio-set-direction.c b/drivers/gpio/gpio-set-direction.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/gpio/gpio-set-direction.c	(revision 1734)
@@ -0,0 +1,187 @@
+
+#include <linux/of_platform.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+
+struct gpio_direction_data {
+	int usb_host_pwr_en_gpio;
+	int usb_host_oc_gpio;
+	int wifi_det_gpio;
+	int det_3g_gpio;
+	int off_3g_gpio;
+	int pcie_h_wlan_led_gpio;
+	int pcie_h_wwan_led_gpio;
+	int pcie_f_wlan_led_gpio;
+	int pcie_f_wwan_led_gpio;
+};
+
+static const struct of_device_id of_gpio_direction_match[] = {
+	{ .compatible = "gpio-set-direction", },
+	{},
+};
+
+static int gpio_direction_probe(struct platform_device *pdev)
+{
+	struct gpio_direction_data *gpio;
+	struct device_node *np = pdev->dev.of_node;
+	enum of_gpio_flags usb_host_pwr_flag;
+	unsigned long flags;
+	int ret = 0;
+
+	gpio = devm_kzalloc(&pdev->dev, sizeof(struct gpio_direction_data), GFP_KERNEL);
+	
+	if (!gpio) {
+		printk("\n [gpio_direction_probe] Allocate gpio memory error... \n");
+		return -ENOMEM;
+	}
+
+	/* Fetch GPIOs */
+	/* USB Config */
+	gpio->usb_host_pwr_en_gpio = of_get_named_gpio_flags(np, "usb-host-pwr-en", 0, &usb_host_pwr_flag);
+
+	if (gpio_is_valid(gpio->usb_host_pwr_en_gpio)) {
+		if(usb_host_pwr_flag)
+			flags = GPIOF_OUT_INIT_HIGH;
+		else
+			flags = GPIOF_OUT_INIT_LOW;
+
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->usb_host_pwr_en_gpio,
+					flags,
+					"usb-host-pwr-en");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get usb_host_pwr_en_gpio\n");
+			return ret;
+		}
+	}
+	
+	gpio->usb_host_oc_gpio = of_get_named_gpio(np, "usb-host-oc", 0);
+
+	if (gpio_is_valid(gpio->usb_host_oc_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->usb_host_oc_gpio,
+					GPIOF_IN,
+					"usb-host-oc");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get usb_host_oc_gpio\n");
+			return ret;
+		}
+	}
+	
+	/* WIFI Config */
+	gpio->wifi_det_gpio = of_get_named_gpio(np, "wifi-det", 0);
+
+	if (gpio_is_valid(gpio->wifi_det_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->wifi_det_gpio,
+					GPIOF_IN,
+					"wifi-det");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get wifi_det_gpio\n");
+			return ret;
+		}
+	}
+	
+	/* 3G Config */
+	gpio->det_3g_gpio = of_get_named_gpio(np, "det-3g", 0);
+
+	if (gpio_is_valid(gpio->det_3g_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->det_3g_gpio,
+					GPIOF_IN,
+					"3g-det");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get det_3g_gpio\n");
+			return ret;
+		}
+	}
+	
+	gpio->off_3g_gpio = of_get_named_gpio(np, "off-3g", 0);
+
+	if (gpio_is_valid(gpio->off_3g_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->off_3g_gpio,
+					GPIOF_IN,
+					"3g-off");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get off_3g_gpio\n");
+			return ret;
+		}
+	}
+	
+	/* PCIE LED Config */
+	gpio->pcie_h_wlan_led_gpio = of_get_named_gpio(np, "pcie-h-wlan-led", 0);
+
+	if (gpio_is_valid(gpio->pcie_h_wlan_led_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->pcie_h_wlan_led_gpio,
+					GPIOF_IN,
+					"pcie-h-wlan-led");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get pcie_h_wlan_led_gpio\n");
+			return ret;
+		}
+	}
+	
+	gpio->pcie_h_wwan_led_gpio = of_get_named_gpio(np, "pcie-h-wwan-led", 0);
+
+	if (gpio_is_valid(gpio->pcie_h_wwan_led_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->pcie_h_wwan_led_gpio,
+					GPIOF_IN,
+					"pcie-h-wwan-led");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get pcie_h_wwan_led_gpio\n");
+			return ret;
+		}
+	}
+
+	gpio->pcie_f_wlan_led_gpio = of_get_named_gpio(np, "pcie-f-wlan-led", 0);
+
+	if (gpio_is_valid(gpio->pcie_f_wlan_led_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->pcie_f_wlan_led_gpio,
+					GPIOF_IN,
+					"pcie-f-wlan-led");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get pcie_f_wlan_led_gpio\n");
+			return ret;
+		}
+	}
+
+	gpio->pcie_f_wwan_led_gpio = of_get_named_gpio(np, "pcie-f-wwan-led", 0);
+
+	if (gpio_is_valid(gpio->pcie_f_wwan_led_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+					gpio->pcie_f_wwan_led_gpio,
+					GPIOF_IN,
+					"pcie-f-wwan-led");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get pcie_f_wwan_led_gpio\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct platform_driver gpio_direction_driver = {
+	.driver		= {
+		.name	= "gpio-direction",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(of_gpio_direction_match),
+	},
+};
+
+static int __init gpio_direction_init(void)
+{
+	return platform_driver_probe(&gpio_direction_driver, gpio_direction_probe);
+}
+
+subsys_initcall(gpio_direction_init);
+
+MODULE_AUTHOR("Advantech");
+MODULE_DESCRIPTION("GIPO SET DIRECTION driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:gpio-set-direction");
+
Index: drivers/gpio/gpiolib.c
===================================================================
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
--- a/drivers/gpio/gpiolib.c	(revision 513)
+++ b/drivers/gpio/gpiolib.c	(revision 1734)
@@ -734,7 +734,8 @@
 	.class_attrs =	gpio_class_attrs,
 };
 
-
+/* Rename gpio nodes in /sys/class/gpio */
+static int gpio_count = 1;
 /**
  * gpio_export - export a GPIO through sysfs
  * @gpio: gpio to make available, already requested
@@ -791,9 +792,10 @@
 	if (desc->chip->names && desc->chip->names[offset])
 		ioname = desc->chip->names[offset];
 
-	dev = device_create(&gpio_class, desc->chip->dev, MKDEV(0, 0),
-			    desc, ioname ? ioname : "gpio%u",
-			    desc_to_gpio(desc));
+		dev = device_create(&gpio_class, desc->chip->dev, MKDEV(0, 0),
+				desc, ioname ? ioname : "gpio%u", gpio_count);
+		gpio_count++;
+		
 	if (IS_ERR(dev)) {
 		status = PTR_ERR(dev);
 		goto fail_unlock;
@@ -964,6 +966,7 @@
 		if (dev) {
 			gpio_setup_irq(desc, dev, 0);
 			clear_bit(FLAG_EXPORT, &desc->flags);
+			gpio_count--;
 		} else
 			status = -ENODEV;
 	}
Index: drivers/gpio/Kconfig
===================================================================
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
--- a/drivers/gpio/Kconfig	(revision 513)
+++ b/drivers/gpio/Kconfig	(revision 1734)
@@ -184,6 +184,12 @@
 	select GPIO_GENERIC
 	select GENERIC_IRQ_CHIP
 
+config GPIO_ARCH_ADVANTECH
+	def_bool y
+	depends on GPIO_DEVRES
+	help
+		Set GPIO direction.
+
 config GPIO_MXS
 	def_bool y
 	depends on ARCH_MXS
Index: drivers/gpio/gpio-mxc.c
===================================================================
diff --git a/drivers/gpio/gpio-mxc.c b/drivers/gpio/gpio-mxc.c
--- a/drivers/gpio/gpio-mxc.c	(revision 513)
+++ b/drivers/gpio/gpio-mxc.c	(revision 1734)
@@ -457,10 +457,18 @@
 		}
 	}
 
+#ifdef CONFIG_ARCH_ADVANTECH
 	err = bgpio_init(&port->bgc, &pdev->dev, 4,
+			 port->base + GPIO_DR,
+			 port->base + GPIO_DR, NULL,
+			 port->base + GPIO_GDIR, NULL, 0);
+#else
+	err = bgpio_init(&port->bgc, &pdev->dev, 4,
 			 port->base + GPIO_PSR,
 			 port->base + GPIO_DR, NULL,
 			 port->base + GPIO_GDIR, NULL, 0);
+#endif
+			 
 	if (err)
 		goto out_iounmap;
 
Index: drivers/ata/ahci_platform.c
===================================================================
diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
--- a/drivers/ata/ahci_platform.c	(revision 513)
+++ b/drivers/ata/ahci_platform.c	(revision 1734)
@@ -208,7 +208,6 @@
 	rc = ahci_reset_controller(host);
 	if (rc)
 		goto pdata_exit;
-
 	ahci_init_controller(host);
 	ahci_print_info(host, "platform");
 
Index: drivers/ata/ahci_imx.c
===================================================================
diff --git a/drivers/ata/ahci_imx.c b/drivers/ata/ahci_imx.c
--- a/drivers/ata/ahci_imx.c	(revision 513)
+++ b/drivers/ata/ahci_imx.c	(revision 1734)
@@ -29,6 +29,12 @@
 #include <linux/busfreq-imx6.h>
 #include "ahci.h"
 
+#ifdef CONFIG_ARCH_ADVANTECH
+extern char board_type[12];
+extern char board_cpu[20];
+u32 g_speed;
+#endif
+
 enum {
 	HOST_TIMER1MS = 0xe0,			/* Timer 1-ms */
 	PORT_PHY_CTL = 0x178,			/* Port0 PHY Control */
@@ -224,6 +230,29 @@
 	unsigned int reg_val;
 	struct imx_ahci_priv *imxpriv = dev_get_drvdata(dev->parent);
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	u32 tmpmask, tmpdata;
+	u32 sata_gen_phy_reg[3];
+	u32 orig_value = IMX6Q_GPR13_SATA_RX_EQ_VAL_3_0_DB \
+									| IMX6Q_GPR13_SATA_RX_LOS_LVL_SATA2M \
+									| IMX6Q_GPR13_SATA_RX_DPLL_MODE_2P_4F \
+									| IMX6Q_GPR13_SATA_SPD_MODE_3P0G \
+									| IMX6Q_GPR13_SATA_MPLL_SS_EN \
+									| IMX6Q_GPR13_SATA_TX_ATTEN_9_16 \
+									| IMX6Q_GPR13_SATA_TX_BOOST_3_33_DB \
+									| IMX6Q_GPR13_SATA_TX_LVL_1_104_V;
+	u32 orig_mask = IMX6Q_GPR13_SATA_RX_EQ_VAL_MASK \
+									| IMX6Q_GPR13_SATA_RX_LOS_LVL_MASK \
+									| IMX6Q_GPR13_SATA_RX_DPLL_MODE_MASK \
+									| IMX6Q_GPR13_SATA_SPD_MODE_MASK \
+									| IMX6Q_GPR13_SATA_MPLL_SS_EN \
+									| IMX6Q_GPR13_SATA_TX_ATTEN_MASK \
+									| IMX6Q_GPR13_SATA_TX_BOOST_MASK \
+									| IMX6Q_GPR13_SATA_TX_LVL_MASK \
+									| IMX6Q_GPR13_SATA_TX_EDGE_RATE \
+									| IMX6Q_GPR13_SATA_MPLL_CLK_EN;
+#endif
+
 	imxpriv->gpr =
 		syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
 	if (IS_ERR(imxpriv->gpr)) {
@@ -238,6 +267,60 @@
 	}
 	request_bus_freq(BUS_FREQ_HIGH);
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	tmpmask = 0x07FFFFFF;
+	if((strcmp(board_type, "ROM-5420"))==0 )
+	{
+   sata_gen_phy_reg[0] = 0x059180E6; 
+   sata_gen_phy_reg[1] = 0x059180E6;
+   sata_gen_phy_reg[2] = 0x059180E6;
+ 	}
+	else if((strcmp(board_type, "ROM-3420"))==0 )
+  {
+   sata_gen_phy_reg[0] = 0x05911672; 
+   sata_gen_phy_reg[1] = 0x05918732;
+   sata_gen_phy_reg[2] = 0x05918732;
+	}
+	else
+	{
+   sata_gen_phy_reg[0] = orig_value; 
+   sata_gen_phy_reg[1] = orig_value;
+   sata_gen_phy_reg[2] = orig_value;
+   tmpmask = orig_mask;
+	}
+	
+	if (g_speed == 1) //Gen-1: 1.5 Gbps
+	{
+		//printk(KERN_INFO "*** [ahci_probe] SATA Gen-1\n");
+
+		tmpdata = sata_gen_phy_reg[0];
+	}
+	else if (g_speed == 2) //Gen-2: 3 Gbps
+	{
+		//printk(KERN_INFO "***[ahci_probe] SATA Gen-2\n");
+
+		tmpdata = sata_gen_phy_reg[1];
+	}
+	else if (g_speed == 3) //Gen-3: 6 Gbps
+	{
+		//printk(KERN_INFO "*** [ahci_probe] SATA Gen-3\n");
+
+		tmpdata = sata_gen_phy_reg[2];
+	}
+	else
+	{
+		//printk(KERN_INFO "*** [ahci_probe] SATA Unknow Gen-?\n");
+		tmpdata = sata_gen_phy_reg[1];
+	}
+
+	//printk(KERN_INFO "*** [ahci_probe] tmpdata1:0x%08X\n", tmpdata1);
+
+	regmap_update_bits(imxpriv->gpr, 0x34, tmpmask, tmpdata);
+
+	regmap_update_bits(imxpriv->gpr, 0x34, IMX6Q_GPR13_SATA_MPLL_CLK_EN,
+			IMX6Q_GPR13_SATA_MPLL_CLK_EN);
+	usleep_range(100, 200);
+#else
 	/*
 	 * set PHY Paremeters, two steps to configure the GPR13,
 	 * one write for rest of parameters, mask of first write
@@ -265,6 +348,7 @@
 	regmap_update_bits(imxpriv->gpr, 0x34, IMX6Q_GPR13_SATA_MPLL_CLK_EN,
 			IMX6Q_GPR13_SATA_MPLL_CLK_EN);
 	usleep_range(100, 200);
+#endif
 
 	sata_phy_cr_addr(SATA_PHY_CR_CLOCK_RESET, mmio);
 	sata_phy_cr_write(SATA_PHY_CR_RESET_EN, mmio);
@@ -401,6 +485,11 @@
 	struct platform_device *ahci_pdev;
 	int ret;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	struct ata_host *host;
+	struct ahci_host_priv *hpriv;
+#endif
+
 	imxpriv = devm_kzalloc(dev, sizeof(*imxpriv), GFP_KERNEL);
 	if (!imxpriv) {
 		dev_err(dev, "can't alloc ahci_host_priv\n");
@@ -471,6 +560,12 @@
 		return ret;
 	}
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	host = dev_get_drvdata(ahci_dev);
+	hpriv = host->private_data;
+	g_speed = (hpriv->cap >> 20) & 0xf;
+#endif
+
 	return 0;
 }
 
Index: drivers/i2c/muxes/i2c-mux-pca954x.c
===================================================================
diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c
--- a/drivers/i2c/muxes/i2c-mux-pca954x.c	(revision 513)
+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c	(revision 1734)
@@ -284,7 +284,22 @@
 	.id_table	= pca954x_id,
 };
 
+#ifdef CONFIG_ARCH_ADVANTECH
+static int __init pca954x_init(void)
+{
+	return i2c_add_driver(&pca954x_driver);
+}
+
+static void __exit pca954x_exit(void)
+{
+	i2c_del_driver(&pca954x_driver);
+}
+
+subsys_initcall(pca954x_init);
+module_exit(pca954x_exit);
+#else
 module_i2c_driver(pca954x_driver);
+#endif
 
 MODULE_AUTHOR("Rodolfo Giometti <giometti@linux.it>");
 MODULE_DESCRIPTION("PCA954x I2C mux/switch driver");
