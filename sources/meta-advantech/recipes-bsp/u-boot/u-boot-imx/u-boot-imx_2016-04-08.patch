Index: include/spl.h
===================================================================
diff --git a/include/spl.h b/include/spl.h
--- a/include/spl.h	(revision 512)
+++ b/include/spl.h	(revision 1734)
@@ -66,8 +66,15 @@
 void spl_nor_load_image(void);
 
 /* MMC SPL functions */
+#ifdef CONFIG_ADVANTECH
+int spl_mmc_load_image(unsigned int dev);
+#else
 void spl_mmc_load_image(void);
+#endif
 
+/* SATA SPL functions */
+int spl_sata_load_image(unsigned int dev);
+
 /* YMODEM SPL functions */
 void spl_ymodem_load_image(void);
 
Index: include/imx_spi.h
===================================================================
diff --git a/include/imx_spi.h b/include/imx_spi.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/imx_spi.h	(revision 1734)
@@ -0,0 +1,96 @@
+/*
+ * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __IMX_SPI_H__
+#define __IMX_SPI_H__
+
+#include <spi.h>
+
+#undef IMX_SPI_DEBUG
+
+#define IMX_SPI_ACTIVE_HIGH     1
+#define IMX_SPI_ACTIVE_LOW      0
+#define SPI_RETRY_TIMES         100
+
+#if defined(IMX_CSPI_VER_0_7)
+	#define	SPI_RX_DATA		0x0
+	#define SPI_TX_DATA		0x4
+	#define SPI_CON_REG		0x8
+	#define SPI_INT_REG		0xC
+	#define SPI_DMA_REG		0x10
+	#define SPI_STAT_REG		0x14
+	#define SPI_PERIOD_REG		0x18
+
+	#define SPI_CTRL_EN		(1 << 0)
+	#define SPI_CTRL_MODE		(1 << 1)
+	#define SPI_CTRL_REG_XCH_BIT	(1 << 2)
+	#define SPI_CTRL_SSPOL		(1 << 7)
+	#define SPI_CTRL_SSPOL_OFF	(7)
+	#define SPI_CTRL_SSCTL		(1 << 6)
+	#define SPI_CTRL_SSCTL_OFF	(6)
+	#define SPI_CTRL_SCLK_POL	(1 << 4)
+	#define SPI_CTRL_SCLK_POL_OFF	(4)
+	#define SPI_CTRL_SCLK_PHA	(1 << 5)
+	#define SPI_CTRL_SCLK_PHA_OFF	(5)
+	#define SPI_CTRL_SS_OFF		(12)
+	#define SPI_CTRL_SS_MASK	(3 << 12)
+	#define SPI_CTRL_DATA_OFF	(16)
+	#define SPI_CTRL_DATA_MASK	(7 << 16)
+	#define SPI_CTRL_BURST_OFF	(20)
+	#define SPI_CTRL_BURST_MASK	(0xFFF << 20)
+	#define SPI_INT_STAT_TC		(1 << 7)
+
+#elif defined(IMX_CSPI_VER_2_3)
+	#define	SPI_RX_DATA		0x0
+	#define SPI_TX_DATA		0x4
+	#define SPI_CON_REG		0x8
+	#define SPI_CFG_REG		0xC
+	#define SPI_INT_REG		0x10
+	#define SPI_DMA_REG		0x14
+	#define SPI_STAT_REG		0x18
+	#define SPI_PERIOD_REG		0x1C
+#endif
+
+struct spi_reg_t {
+	u32 ctrl_reg;
+	u32 cfg_reg;
+};
+
+struct imx_spi_dev_t {
+	struct spi_slave slave;
+	u32 base;      /* base address of SPI module the device is connected to */
+	u32 freq;      /* desired clock freq in Hz for this device */
+	u32 ss_pol;    /* ss polarity: 1=active high; 0=active low */
+	u32 ss;        /* slave select */
+	u32 in_sctl;   /* inactive sclk ctl: 1=stay low; 0=stay high */
+	u32 in_dctl;   /* inactive data ctl: 1=stay low; 0=stay high */
+	u32 ssctl;     /* single burst mode vs multiple: 0=single; 1=multi */
+	u32 sclkpol;   /* sclk polarity: active high=0; active low=1 */
+	u32 sclkpha;   /* sclk phase: 0=phase 0; 1=phase1 */
+	u32 fifo_sz;   /* fifo size in bytes for either tx or rx. Don't add them up! */
+	u32 us_delay;  /* us delay in each xfer */
+	struct spi_reg_t reg; /* pointer to a set of SPI registers */
+};
+
+extern void spi_io_init(struct imx_spi_dev_t *dev);
+
+#endif /* __IMX_SPI_H__ */
Index: include/configs/mx6dlubc220.h
===================================================================
diff --git a/include/configs/mx6dlubc220.h b/include/configs/mx6dlubc220.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6dlubc220.h	(revision 1734)
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_UBC220
+#define CONFIG_MMC_CLOCK_DOWNGRADE
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH 
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#define CONFIG_SUPPORT_LVDS
+#ifdef CONFIG_SUPPORT_LVDS
+#define IOMUX_LCD_BKLT_PWM 	MX6_PAD_SD1_CMD__GPIO_1_18
+#define IOMUX_LCD_BKLT_EN		MX6_PAD_KEY_COL0__GPIO_4_6
+#define IOMUX_LCD_VDD_EN 		MX6_PAD_KEY_ROW0__GPIO_4_7
+#define LCD_BKLT_PWM 				IMX_GPIO_NR(1, 18)
+#define LCD_BKLT_EN 				IMX_GPIO_NR(4, 6)
+#define LCD_VDD_EN 					IMX_GPIO_NR(4, 7)	
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/configs/mx6qubc220.h
===================================================================
diff --git a/include/configs/mx6qubc220.h b/include/configs/mx6qubc220.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qubc220.h	(revision 1734)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 9)<<8))
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH 
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/configs/mx6qrom7420.h
===================================================================
diff --git a/include/configs/mx6qrom7420.h b/include/configs/mx6qrom7420.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qrom7420.h	(revision 1734)
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_ROM7420
+
+/* support SATA boot */
+#define CONFIG_SATA_BOOT
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   		1
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#define CONFIG_SUPPORT_LVDS
+#ifdef CONFIG_SUPPORT_LVDS
+#define IOMUX_LCD_BKLT_PWM	MX6_PAD_SD1_DAT3__GPIO_1_21
+#define IOMUX_LCD_BKLT_EN		MX6_PAD_NANDF_WP_B__GPIO_6_9
+#define IOMUX_LCD_VDD_EN		MX6_PAD_NANDF_CLE__GPIO_6_7
+#define LCD_BKLT_PWM 				IMX_GPIO_NR(1, 21)
+#define LCD_BKLT_EN 				IMX_GPIO_NR(6, 9)
+#define LCD_VDD_EN 					IMX_GPIO_NR(6, 7)	
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/configs/mx6qadvantech_common.h
===================================================================
diff --git a/include/configs/mx6qadvantech_common.h b/include/configs/mx6qadvantech_common.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qadvantech_common.h	(revision 1734)
@@ -0,0 +1,524 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRE_COMMON_CONFIG_H
+#define __MX6QSABRE_COMMON_CONFIG_H
+
+#define CONFIG_MX6
+
+#define CONFIG_SYS_L2_PL310
+#define CONFIG_SYS_PL310_BASE		0x00A02000
+#define CONFIG_SYS_CACHELINE_SIZE	32
+
+#ifdef CONFIG_MX6SOLO
+#define CONFIG_MX6DL
+#endif
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+#define CONFIG_ARCH_MISC_INIT
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#include "mx6_common.h"
+#include <asm/sizes.h>
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#include <asm/arch/imx-regs.h>
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+
+/* OCOTP Config */
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+
+#define CONFIG_PHYLIB
+
+#ifdef CONFIG_UBC220
+#define CONFIG_FEC_MXC_PHYADDR		7
+#define CONFIG_PHY_REALTEK
+#else
+#if defined(CONFIG_ROM3420) || defined(CONFIG_ROM5420)
+#define CONFIG_FEC_MXC_PHYADDR		0
+#else
+#define CONFIG_FEC_MXC_PHYADDR		4
+#endif
+#define CONFIG_PHY_ATHEROS
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX              1
+#define CONFIG_BAUDRATE                        115200
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_BMODE
+#define CONFIG_CMD_BOOTZ
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY               1
+
+#define CONFIG_LOADADDR			0x12000000
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_TEXT_BASE		0x26800000
+#else
+#define CONFIG_SYS_TEXT_BASE		0x17800000
+#endif
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#define CONFIG_SYS_UBOOT_START		CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_MONITOR_LEN		(600 * 1024) /* Reserve 600 kB for Monitor */
+
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:16m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+/*
+ * For the SPI/WEIM NOR, it can't store all the images into it due to it's
+ * capacity, we need one default mmc device to load the left image or rootfs.
+ * The end user need change the default setting according to their needs.
+ * For NAND/SATA boot, the storage is big enough to hold all the stuff.
+ * For SD/MMC boot, mmcdev is dynamiclly created due to the boot SD/MMC slot.
+ */
+#if defined(CONFIG_SYS_BOOT_EIMNOR) || defined(CONFIG_SYS_BOOT_SPINOR)
+#define CONFIG_MMC_DEV_SET "mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV)
+#else
+#define CONFIG_MMC_DEV_SET " "
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+		"initrd_addr=0x12C00000\0" \
+		"initrd_high=0xffffffff\0" \
+		"bootcmd_mfg=run mfgtool_args;bootm ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+	/*
+	 * The dts also enables the WEIN NOR which is mtd0.
+	 * So the partions' layout for NAND is:
+	 *     mtd1: 16M      (uboot)
+	 *     mtd2: 16M      (kernel)
+	 *     mtd3: 16M      (dtb)
+	 *     mtd4: left     (rootfs)
+	 */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:16m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x1000000 0x800000;"\
+		"nand read ${fdt_addr} 0x2000000 0x100000;"\
+		"bootm ${loadaddr} - ${fdt_addr}\0"
+
+#elif defined(CONFIG_SYS_BOOT_SATA)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"   \
+	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
+	"bootargs_sata=setenv bootargs ${bootargs} " \
+		"root=/dev/sda1 rootwait rw \0" \
+	"bootcmd_sata=run bootargs_sata; sata init; " \
+		"sata read ${loadaddr} 0x800  0x4000; " \
+		"sata read ${fdt_addr} 0x8000 0x800; " \
+		"bootm ${loadaddr} - ${fdt_addr} \0" \
+	"bootcmd=run bootcmd_sata \0"
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"uimage=uImage\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONFIG_CONSOLE_DEV "\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+	CONFIG_MMC_DEV_SET \
+	"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"smp=" CONFIG_SYS_NOSMP "\0"\
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=${mmcroot} ${bootargs}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loaduimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${uimage}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootm; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootm; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp ${bootargs}\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${uimage}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootm; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootm; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev};" \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+		"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run netboot; " \
+			"fi; " \
+		"fi; " \
+	"else run netboot; fi"
+#endif
+#define CONFIG_ARP_TIMEOUT     200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_SYS_PROMPT              "U-Boot > "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE              1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS             16
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+#define CONFIG_SYS_HZ                  1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE               (128 * 1024)
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#ifndef CONFIG_SYS_NOSMP
+#define CONFIG_SYS_NOSMP
+#endif
+
+/* Monitor at beginning of flash */
+/* #define CONFIG_FSL_ENV_IN_MMC */
+/* #define CONFIG_FSL_ENV_IN_NAND */
+/* #define CONFIG_FSL_ENV_IN_SATA */
+#define CONFIG_FSL_ENV_IN_SF
+
+#if defined(CONFIG_FSL_ENV_IN_NAND)
+	#define CONFIG_ENV_IS_IN_NAND 1
+#elif defined(CONFIG_FSL_ENV_IN_MMC)
+	#define CONFIG_ENV_IS_IN_MMC	1
+#elif defined(CONFIG_FSL_ENV_IN_SF)
+	#define CONFIG_ENV_IS_IN_SPI_FLASH	1
+#else
+	#define CONFIG_ENV_IS_NOWHERE	1
+#endif
+
+#ifdef CONFIG_SATA_BOOT
+#define CONFIG_CMD_SATA
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	#define CONFIG_CMD_SF
+
+	#ifdef CONFIG_ROM3420
+		#define CONFIG_SF_DEFAULT_BUS  4
+	#else
+		#define CONFIG_SF_DEFAULT_BUS  0
+	#endif
+
+	#define CONFIG_SF_DEFAULT_SPEED 20000000
+	#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+/*
+ * SPI Configs
+ */
+#ifdef CONFIG_CMD_SF
+	#define CONFIG_FSL_SF		1
+	#define CONFIG_SPI_FLASH_IMX_M25PXX	1
+	#ifdef CONFIG_ROM7420
+		#define CONFIG_SPI_FLASH_CS	1
+	#else
+		#define CONFIG_SPI_FLASH_CS	0
+	#endif
+	#define IMX_CSPI_VER_2_3	1
+	#define CONFIG_IMX_ECSPI
+#endif
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE	(128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE			CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET		(4 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(8 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_SATA_ENV_DEV		0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
+#endif
+
+#define CONFIG_OF_LIBFDT
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+/*
+ * I2C configs
+ */
+#define CONFIG_CMD_I2C
+#define CONFIG_HARD_I2C         1
+#define CONFIG_I2C_MXC          1
+#define CONFIG_SYS_I2C_BASE             I2C2_BASE_ADDR
+#define CONFIG_SYS_I2C_SPEED            100000
+#define CONFIG_SYS_I2C_SLAVE            0x8
+
+#ifndef CONFIG_ADVANTECH
+/* Framebuffer */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_MX6DL
+#define CONFIG_IPUV3_CLK 198000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
+#define CONFIG_IMX_HDMI
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6qsabreandroid_common.h"
+#endif
+
+/*
+ * SPL
+ */
+#define CONFIG_SPL
+#define CONFIG_SPL_FRAMEWORK
+/*
+use following command to make SPL with command line support
+$ SPL_CMD_MODE=1 make -j4 LDFLAGS=
+*/
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/cpu/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBDISK_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR	0x3 /* address 0x600 = 512*3 */
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS	0x4B0 /* 600 KB */
+
+#define CONFIG_SPL_BOARD_INIT
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+
+#ifdef CONFIG_SATA_BOOT
+#define CONFIG_SPL_SATA_SUPPORT
+#endif
+
+#ifdef CONFIG_SPI_BOOT
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	(512*3)
+/* Need to define CONFIG_SPL_SPI_BUS & CONFIG_SPL_SPI_CS in project H file */
+#endif
+
+#define CONFIG_SPL_TEXT_BASE		0x27800000
+#define CONFIG_SPL_MAX_SIZE		(192 * 1024)
+#define CONFIG_SPL_STACK		0x27F00000
+#define CONFIG_SPL_STACK_SIZE		(8 * 1024)
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x3F000000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x80000
+#define CONFIG_SPL_BSS_START_ADDR	0x3F080000	/* End of RAM */
+#define CONFIG_SPL_BSS_MAX_SIZE 	0x80000
+
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+#ifdef CONFIG_SPL_CMD_MODE
+#define CONFIG_SPL_NET_SUPPORT
+#define CONFIG_SPL_ETH_SUPPORT
+#define CONFIG_SPL_SYS_PROMPT "SPL > "
+#endif
+
+#endif                         /* __MX6QSABRE_COMMON_CONFIG_H */
Index: include/configs/mx6qubcds31.h
===================================================================
diff --git a/include/configs/mx6qubcds31.h b/include/configs/mx6qubcds31.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qubcds31.h	(revision 1734)
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_UBCDS31
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   		0
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/configs/mx6qwise3310.h
===================================================================
diff --git a/include/configs/mx6qwise3310.h b/include/configs/mx6qwise3310.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qwise3310.h	(revision 1734)
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_WISE3310
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   		0
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/configs/mx6qrsb4410.h
===================================================================
diff --git a/include/configs/mx6qrsb4410.h b/include/configs/mx6qrsb4410.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qrsb4410.h	(revision 1734)
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_RSB4410
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   		0
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#define CONFIG_SUPPORT_LVDS
+#ifdef CONFIG_SUPPORT_LVDS
+#define IOMUX_LCD_BKLT_PWM 	MX6_PAD_GPIO_1__GPIO_1_1
+#define IOMUX_LCD_BKLT_EN		MX6_PAD_KEY_COL0__GPIO_4_6
+#define IOMUX_LCD_VDD_EN		MX6_PAD_KEY_ROW0__GPIO_4_7
+#define LCD_BKLT_PWM 				IMX_GPIO_NR(1, 1)
+#define LCD_BKLT_EN 				IMX_GPIO_NR(4, 6)
+#define LCD_VDD_EN 					IMX_GPIO_NR(4, 7)	
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/configs/mx6qrom3420.h
===================================================================
diff --git a/include/configs/mx6qrom3420.h b/include/configs/mx6qrom3420.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qrom3420.h	(revision 1734)
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_ROM3420
+
+/* support SATA boot */
+#define CONFIG_SATA_BOOT
+
+/* support SPI boot */
+#define CONFIG_SPI_BOOT
+#define CONFIG_SPL_SPI_BUS	0
+#define CONFIG_SPL_SPI_CS	0
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_BOOT_SELECT
+#endif
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#define CONFIG_SUPPORT_LVDS
+#ifdef CONFIG_SUPPORT_LVDS
+#define IOMUX_LCD_BKLT_PWM 	MX6_PAD_GPIO_9__GPIO_1_9
+#define IOMUX_LCD_BKLT_EN		MX6_PAD_CSI0_VSYNC__GPIO_5_21
+#define IOMUX_LCD_VDD_EN		MX6_PAD_CSI0_DATA_EN__GPIO_5_20
+#define LCD_BKLT_PWM 				IMX_GPIO_NR(1, 9)
+#define LCD_BKLT_EN 				IMX_GPIO_NR(5, 21)
+#define LCD_VDD_EN 					IMX_GPIO_NR(5, 20)
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/configs/mx6qrom5420.h
===================================================================
diff --git a/include/configs/mx6qrom5420.h b/include/configs/mx6qrom5420.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/configs/mx6qrom5420.h	(revision 1734)
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MX6QSABRESD_CONFIG_H
+#define __MX6QSABRESD_CONFIG_H
+
+#define CONFIG_ADVANTECH
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc0"
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
+#define CONFIG_ROM5420
+
+/* support SATA boot */
+#define CONFIG_SATA_BOOT
+
+/* support SPI boot */
+#define CONFIG_SPI_BOOT
+#define CONFIG_SPL_SPI_BUS	4
+#define CONFIG_SPL_SPI_CS	0
+
+#include "mx6qadvantech_common.h"
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_BOOT_SELECT
+#endif
+
+/* don't use pmic */
+#undef CONFIG_LDO_BYPASS_CHECK
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+#ifdef CONFIG_ADVANTECH
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifndef CONFIG_ADVANTECH 
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+#endif
+
+#define CONFIG_SUPPORT_LVDS
+#ifdef CONFIG_SUPPORT_LVDS
+#define IOMUX_LCD_BKLT_PWM 	MX6_PAD_GPIO_9__GPIO_1_9
+#define IOMUX_LCD_BKLT_EN 	MX6_PAD_KEY_COL0__GPIO_4_6
+#define IOMUX_LCD_VDD_EN		MX6_PAD_KEY_ROW0__GPIO_4_7
+#define LCD_BKLT_PWM 				IMX_GPIO_NR(1, 9)
+#define LCD_BKLT_EN 				IMX_GPIO_NR(4, 6)
+#define LCD_VDD_EN 					IMX_GPIO_NR(4, 7)	
+#endif
+
+#endif                         /* __MX6QSABRESD_CONFIG_H */
Index: include/config_uncmd_spl.h
===================================================================
diff --git a/include/config_uncmd_spl.h b/include/config_uncmd_spl.h
--- a/include/config_uncmd_spl.h	(revision 512)
+++ b/include/config_uncmd_spl.h	(revision 1734)
@@ -31,11 +31,13 @@
 #ifdef CONFIG_SPL_BUILD
 /* SPL needs only BOOTP + TFTP so undefine other stuff to save space */
 #undef CONFIG_CMD_CDP
-#undef CONFIG_CMD_DHCP
 #undef CONFIG_CMD_DNS
 #undef CONFIG_CMD_LINK_LOCAL
+#ifndef CONFIG_SPL_CMD_MODE
+#undef CONFIG_CMD_DHCP
 #undef CONFIG_CMD_NFS
 #undef CONFIG_CMD_PING
+#endif
 #undef CONFIG_CMD_RARP
 #undef CONFIG_CMD_SNTP
 #undef CONFIG_CMD_TFTPPUT
Index: include/imx_spi_nor.h
===================================================================
diff --git a/include/imx_spi_nor.h b/include/imx_spi_nor.h
new file mode 10644
--- /dev/null	(revision 0)
+++ b/include/imx_spi_nor.h	(revision 1734)
@@ -0,0 +1,85 @@
+/*
+ * (C) Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _IMX_SPI_NOR_H_
+#define _IMX_SPI_NOR_H_
+
+#define READ        0x03    /* tx:1 byte cmd + 3 byte addr;rx:variable bytes */
+#define READ_HS     0x0B    /* tx:1 byte cmd + 3 byte addr + 1 byte dummy; */
+#define RDSR        0x05    /* read stat reg 1 byte tx cmd + 1 byte rx status */
+#define RDSR_BUSY       (1 << 0)    /* 1=write-in-progress (default 0) */
+#define RDSR_WEL        (1 << 1)    /* 1=write enable (default 0) */
+#define RDSR_BP0        (1 << 2)    /* block write prot level (default 1) */
+#define RDSR_BP1        (1 << 3)    /* block write prot level (default 1) */
+#define RDSR_BP2        (1 << 4)    /* block write prot level (default 1) */
+#define RDSR_BP3        (1 << 5)    /* block write prot level (default 1) */
+#define RDSR_AAI        (1 << 6)    /* 1=AAI prog mode; 0=byte prog (def 0) */
+#define RDSR_BPL        (1 << 7)    /* 1=BP3,BP2,BP1,BP0 RO; 0=R/W (def 0)  */
+#define WREN        0x06    /* write enable. 1 byte tx cmd */
+#define WRDI        0x04    /* write disable. 1 byte tx cmd */
+#define EWSR        0x50    /* Enable write status. 1 byte tx cmd */
+#define WRSR        0x01    /* Write stat reg. 1 byte tx cmd + 1 byte tx val */
+#define ERASE_4K    0x20    /* sector erase. 1 byte cmd + 3 byte addr */
+#define ERASE_32K   0x52    /* 32K block erase. 1 byte cmd + 3 byte addr */
+#define ERASE_64K   0xD8    /* 64K block erase. 1 byte cmd + 3 byte addr */
+#define ERASE_CHIP  0x60    /* whole chip erase */
+#define BYTE_PROG   0x02    /* all tx: 1 cmd + 3 addr + 1 data */
+#define AAI_PROG    0xAD    /* all tx: [1 cmd + 3 addr + 2 data] + RDSR */
+				/* + [1cmd + 2 data] + .. + [WRDI] + [RDSR] */
+#define JEDEC_ID    0x9F    /* read JEDEC ID. tx: 1 byte cmd; rx: 3 byte ID */
+
+/* Atmel SPI-NOR commands */
+#define WR_2_MEM_DIR	0x82
+#define BUF1_WR		0x84
+#define BUF2_WR		0x87
+#define BUF1_TO_MEM	0x83
+#define BUF2_TO_MEM	0x86
+#define STAT_READ	0xD7
+#define STAT_PG_SZ	(1 << 0)  /* 1=Page size is 512, 0=Page size is 528 */
+#define STAT_PROT	(1 << 1)  /* 1=sector protection enabled (default 0) */
+#define STAT_COMP	(1 << 6)
+#define STAT_BUSY	(1 << 7) /* 1=Device not busy */
+#define CONFIG_REG1	0x3D
+#define CONFIG_REG2	0x2A
+#define CONFIG_REG3	0x80
+#define CONFIG_REG4	0xA6
+
+/* Flash opcodes. M25P32 */
+#define	OPCODE_WREN		0x06	/* Write enable */
+#define	OPCODE_RDSR		0x05	/* Read status register */
+#define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
+#define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+/* Status Register bits. */
+#define	SR_WIP			1	/* Write in progress */
+
+#define SZ_64K      0x10000
+#define SZ_32K      0x8000
+#define SZ_4K       0x1000
+
+#endif /* _IMX_SPI_NOR_H_ */
Index: board/freescale/mx6qadvantech/plugin.S
===================================================================
diff --git a/board/freescale/mx6qadvantech/plugin.S b/board/freescale/mx6qadvantech/plugin.S
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/mx6qadvantech/plugin.S	(revision 1734)
@@ -0,0 +1,491 @@
+/*
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6dqsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43270338
+	str r2, [r0, #0x83c]
+	ldr r2, =0x03200314
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x431A032F
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03200263
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4B434748
+	str r2, [r0, #0x848]
+	ldr r2, =0x4445404C
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x38444542
+	str r2, [r0, #0x850]
+	ldr r2, =0x4935493A
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x555A7975
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF538F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x005A1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001f001f
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x4220021F
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0207017E
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4201020C
+	str r2, [r1, #0x83c]
+	ldr r2, =0x01660172
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4A4D4E4D
+	str r2, [r0, #0x848]
+	ldr r2, =0x4A4F5049
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3F3C3D31
+	str r2, [r0, #0x850]
+	ldr r2, =0x3238372B
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6solosabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x42190219
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017B0177
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4B4D4E4D
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3F3E2D36
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000017
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x83190000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0x00FFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000C3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x000003FF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_MX6SOLO)
+	imx6solosabresd_ddr_setting
+#elif defined (CONFIG_MX6DL)
+	imx6dlsabresd_ddr_setting
+#elif defined (CONFIG_MX6Q)
+	imx6dqsabresd_ddr_setting
+#else
+	#error "SOC not configured"
+#endif
+
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
Index: board/freescale/mx6qadvantech/mx6qadvantech.c
===================================================================
diff --git a/board/freescale/mx6qadvantech/mx6qadvantech.c b/board/freescale/mx6qadvantech/mx6qadvantech.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/mx6qadvantech/mx6qadvantech.c	(revision 1734)
@@ -0,0 +1,1536 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ * Author: Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#if CONFIG_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_IMX_ECSPI
+#include <imx_spi.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |               \
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/* Improve RGMII_TXCLK Duty cycle from HW cindy */
+#ifdef CONFIG_ADVANTECH
+#define ENET_PAD_CTRL	(PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED   |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+#else
+#define ENET_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED   |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+#endif
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#if CONFIG_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C2 Camera, MIPI, pfuze */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_KEY_COL3__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_KEY_COL3__GPIO_4_12 | PC,
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_KEY_ROW3__GPIO_4_13 | PC,
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+#endif
+
+int dram_init(void)
+{
+#ifdef CONFIG_ADVANTECH
+	/* Read memory size sent from Adv-Boot */
+	gd->ram_size = (*(unsigned int *)0x22400000);
+	if (gd->ram_size != (2u * 1024 * 1024 * 1024) &&
+		gd->ram_size != (1u * 1024 * 1024 * 1024) &&
+		gd->ram_size != (512 * 1024 * 1024))
+	{
+		gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+	}
+#else
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+#endif
+	return 0;
+}
+
+iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_CSI0_DAT10__UART1_TXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT11__UART1_RXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const enet_pads[] = {
+	MX6_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__ENET_RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__ENET_RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__ENET_RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__ENET_RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__ENET_RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RXC__ENET_RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__ENET_RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__ENET_RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__ENET_RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__ENET_RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* AR8031 PHY Reset */
+	MX6_PAD_ENET_CRS_DV__GPIO_1_25		| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 25) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 25), 1);
+}
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+#if defined CONFIG_ADVANTECH
+	MX6_PAD_EIM_D16__ECSPI1_SCLK  | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D17__ECSPI1_MISO  | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D18__ECSPI1_MOSI  | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_EB2__ECSPI1_SS0   | MUX_PAD_CTRL(NO_PAD_CTRL),
+#else
+	MX6_PAD_KEY_COL0__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_COL1__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_ROW0__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_ROW1__GPIO_4_9    | MUX_PAD_CTRL(NO_PAD_CTRL),
+#endif
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+#if defined(CONFIG_UBC220) || defined(CONFIG_UBCDS31) || defined(CONFIG_ROM5420) || defined(CONFIG_RSB4410) || defined(CONFIG_WISE3310)
+	gpio_direction_output(IMX_GPIO_NR(2, 30), 0);
+#elif defined(CONFIG_ROM7420)
+	gpio_direction_output(IMX_GPIO_NR(3, 19), 0);
+#elif defined(CONFIG_ROM3420)
+	gpio_direction_output(IMX_GPIO_NR(4, 9), 0);
+	gpio_direction_output(IMX_GPIO_NR(4, 10), 0);
+#else
+	gpio_direction_output(IMX_GPIO_NR(4, 9), 0);
+#endif
+}
+#endif
+
+iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__USDHC2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__USDHC2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT0__USDHC2_DAT0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT1__USDHC2_DAT1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT2__USDHC2_DAT2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DAT3__USDHC2_DAT3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D4__USDHC2_DAT4	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D5__USDHC2_DAT5	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D6__USDHC2_DAT6	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D7__USDHC2_DAT7	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D2__GPIO_2_2	| MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+};
+
+iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__USDHC3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__USDHC3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT0__USDHC3_DAT0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT1__USDHC3_DAT1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT2__USDHC3_DAT2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT3__USDHC3_DAT3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT4__USDHC3_DAT4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT5__USDHC3_DAT5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT6__USDHC3_DAT6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT7__USDHC3_DAT7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D0__GPIO_2_0    | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+};
+
+iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__USDHC4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT0__USDHC4_DAT0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT1__USDHC4_DAT1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT2__USDHC4_DAT2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT3__USDHC4_DAT3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT4__USDHC4_DAT4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT5__USDHC4_DAT5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT6__USDHC4_DAT6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT7__USDHC4_DAT7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EIM_A16__EPDC_SDDO_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA10__EPDC_SDDO_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA12__EPDC_SDDO_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA11__EPDC_SDDO_3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_LBA__EPDC_SDDO_4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB2__EPDC_SDDO_5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_CS0__EPDC_SDDO_6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_RW__EPDC_SDDO_7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A21__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A22__EPDC_GDSP	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A23__EPDC_GDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A24__EPDC_GDRL	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D31__EPDC_SDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D27__EPDC_SDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA1__EPDC_SDLE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB1__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA2__EPDC_BDR_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA4__EPDC_SDCE_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA5__EPDC_SDCE_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA6__EPDC_SDCE_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EIM_A16__GPIO_2_22,
+	MX6_PAD_EIM_DA10__GPIO_3_10,
+	MX6_PAD_EIM_DA12__GPIO_3_12,
+	MX6_PAD_EIM_DA11__GPIO_3_11,
+	MX6_PAD_EIM_LBA__GPIO_2_27,
+	MX6_PAD_EIM_EB2__GPIO_2_30,
+	MX6_PAD_EIM_CS0__GPIO_2_23,
+	MX6_PAD_EIM_RW__GPIO_2_26,
+	MX6_PAD_EIM_A21__GPIO_2_17,
+	MX6_PAD_EIM_A22__GPIO_2_16,
+	MX6_PAD_EIM_A23__GPIO_6_6,
+	MX6_PAD_EIM_A24__GPIO_5_4,
+	MX6_PAD_EIM_D31__GPIO_3_31,
+	MX6_PAD_EIM_D27__GPIO_3_27,
+	MX6_PAD_EIM_DA1__GPIO_3_1,
+	MX6_PAD_EIM_EB1__GPIO_2_29,
+	MX6_PAD_EIM_DA2__GPIO_3_2,
+	MX6_PAD_EIM_DA4__GPIO_3_4,
+	MX6_PAD_EIM_DA5__GPIO_3_5,
+	MX6_PAD_EIM_DA6__GPIO_3_6,
+};
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_I2C_MXC
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0 ;
+
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE100! deviceid=%x,revid=%x\n", value, rev_id);
+		/*For camera streaks issue,swap VGEN5 and VGEN3 to power camera.
+		*sperate VDDHIGH_IN and camera 2.8V power supply, after switch:
+		*VGEN5 for VDDHIGH_IN and increase to 3V to align with datasheet
+		*VGEN3 for camera 2.8V power supply
+		*/
+		/*increase VGEN3 from 2.5 to 2.8V*/
+		if (i2c_read(0x8, 0x6e, 1, &value, 1)) {
+			printf("Read VGEN3 error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0xa;
+		if (i2c_write(0x8, 0x6e, 1, &value, 1)) {
+			printf("Set VGEN3 error!\n");
+			return -1;
+		}
+		/*increase VGEN5 from 2.8 to 3V*/
+		if (i2c_read(0x8, 0x70, 1, &value, 1)) {
+			printf("Read VGEN5 error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0xc;
+		if (i2c_write(0x8, 0x70, 1, &value, 1)) {
+			printf("Set VGEN5 error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x21, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x21, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x24, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x24, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x2f, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x2f, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x32, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x32, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.425V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		/* decrease VDDARM to 1.175V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x23;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.175V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x23;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		set_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+#ifdef CONFIG_UBC220
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(1, 4)
+#else
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(2, 2)
+#endif
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 0)
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC4 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD2
+	 * mmc1                    SD3
+	 * mmc2                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+#ifndef CONFIG_ADVANTECH
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+#endif
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+	       }
+
+#ifdef CONFIG_ADVANTECH
+		/* We use index 1 for SD card and index 3 for eMMC */
+		if (i != 1)
+{
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+}
+#else
+	       if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+#endif
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	setenv_ulong("mmcdev", dev_no);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#ifdef CONFIG_SPLASH_SCREEN
+extern int mmc_get_env_devno(void);
+int setup_splash_img(void)
+{
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_SPLASH_IMG_OFFSET;
+	ulong size = CONFIG_SPLASH_IMG_SIZE;
+	ulong addr = 0;
+	char *s = NULL;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	s = getenv("splashimage");
+
+	if (NULL == s) {
+		puts("env splashimage not found!\n");
+		return -1;
+	}
+	addr = simple_strtoul(s, NULL, 16);
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+					blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#endif
+
+	return 0;
+}
+#endif
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 800,
+	.vl_row = 600,
+	.vl_pixclock = 26666667,
+	.vl_left_margin = 8,
+	.vl_right_margin = 100,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 8,
+	.vl_hsync = 4,
+	.vl_vsync = 1,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 419,
+	.gdsp_offs = 20,
+	.gdoe_offs = 0,
+	.gdclk_offs = 5,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EIM_A17 - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO_2_21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as input */
+	gpio_direction_input(IMX_GPIO_NR(2, 21));
+
+	/* EIM_D17 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO_3_17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 17), 1);
+
+	/* EIM_D20 - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO_3_20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 20), 1);
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO_2_20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 20), 1);
+}
+
+int setup_waveform_file(void)
+{
+#ifdef CONFIG_WAVEFORM_FILE_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_WAVEFORM_FILE_OFFSET;
+	ulong size = CONFIG_WAVEFORM_FILE_SIZE;
+	ulong addr = CONFIG_WAVEFORM_BUF_ADDR;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+				      blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#else
+	return -1;
+#endif
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	unsigned int reg;
+
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC PWRSTAT - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO_2_21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC VCOM0 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO_3_17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* UART4 TXD - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO_3_20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO_2_20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/*** Set pixel clock rates for EPDC ***/
+
+	/* EPDC AXI clk (IPU2_CLK) from PFD_400M, set to 396/2 = 198MHz */
+	reg = readl(CCM_BASE_ADDR + CLKCTL_CSCDR3);
+	reg &= ~0x7C000;
+	reg |= (1 << 16) | (1 << 14);
+	writel(reg, CCM_BASE_ADDR + CLKCTL_CSCDR3);
+
+	/* EPDC AXI clk enable */
+	reg = readl(CCM_BASE_ADDR + CLKCTL_CCGR3);
+	reg |= 0x00C0;
+	writel(reg, CCM_BASE_ADDR + CLKCTL_CCGR3);
+
+	/* EPDC PIX clk (IPU2_DI1_CLK) from PLL5, set to 650/4/6 = ~27MHz */
+	reg = readl(CCM_BASE_ADDR + CLKCTL_CSCDR2);
+	reg &= ~0x3FE00;
+	reg |= (2 << 15) | (5 << 12);
+	writel(reg, CCM_BASE_ADDR + CLKCTL_CSCDR2);
+
+	/* PLL5 enable (defaults to 650) */
+	reg = readl(ANATOP_BASE_ADDR + ANATOP_PLL_VIDEO);
+	reg &= ~((1 << 16) | (1 << 12));
+	reg |= (1 << 13);
+	writel(reg, ANATOP_BASE_ADDR + ANATOP_PLL_VIDEO);
+
+	/* EPDC PIX clk enable */
+	reg = readl(CCM_BASE_ADDR + CLKCTL_CCGR3);
+	reg |= 0x0C00;
+	writel(reg, CCM_BASE_ADDR + CLKCTL_CCGR3);
+
+	panel_info.epdc_data.working_buf_addr = CONFIG_WORKING_BUF_ADDR;
+	panel_info.epdc_data.waveform_buf_addr = CONFIG_WAVEFORM_BUF_ADDR;
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+
+	/* Assign fb_base */
+	gd->fb_base = CONFIG_FB_BASE;
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(GPIO2_BASE_ADDR + GPIO_PSR);
+		if (!(reg & (1 << 21)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 0);
+}
+#endif
+
+#ifdef CONFIG_CMD_SATA
+int setup_sata(void)
+{
+	struct iomuxc_base_regs *const iomuxc_regs
+		= (struct iomuxc_base_regs *) IOMUXC_BASE_ADDR;
+	int ret = enable_sata_clock();
+	if (ret)
+		return ret;
+#ifdef CONFIG_ADVANTECH
+#if defined(CONFIG_ROM3420)
+		clrsetbits_le32(&iomuxc_regs->gpr[13],
+				IOMUXC_GPR13_SATA_MASK,
+				0x059195fe);
+#elif defined(CONFIG_ROM5420)
+		clrsetbits_le32(&iomuxc_regs->gpr[13],
+				IOMUXC_GPR13_SATA_MASK,
+				0x05919552);	
+#elif defined(CONFIG_ROM7420)					
+		clrsetbits_le32(&iomuxc_regs->gpr[13],
+				IOMUXC_GPR13_SATA_MASK,
+				0x0593e4c4);		
+#else
+		clrsetbits_le32(&iomuxc_regs->gpr[13],
+				IOMUXC_GPR13_SATA_MASK,
+				IOMUXC_GPR13_SATA_PHY_8_RXEQ_3P0DB
+				|IOMUXC_GPR13_SATA_PHY_7_SATA2M
+				|IOMUXC_GPR13_SATA_SPEED_3G
+				|(3<<IOMUXC_GPR13_SATA_PHY_6_SHIFT)
+				|IOMUXC_GPR13_SATA_SATA_PHY_5_SS_DISABLED
+				|IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_9_16
+				|IOMUXC_GPR13_SATA_PHY_3_TXBOOST_0P00_DB
+				|IOMUXC_GPR13_SATA_PHY_2_TX_1P104V
+				|IOMUXC_GPR13_SATA_PHY_1_SLOW);
+#endif
+#endif
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_ADVANTECH
+int enable_AXI_cache(void)
+{
+	struct iomuxc_base_regs *const iomuxc_regs
+		= (struct iomuxc_base_regs *) IOMUXC_BASE_ADDR;
+
+	writel(0xF00000CF, &iomuxc_regs->gpr[4]);
+	writel(0x007F007F, &iomuxc_regs->gpr[6]);
+	writel(0x007F007F, &iomuxc_regs->gpr[7]);
+	return 0;
+}
+#endif
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+struct display_info_t {
+	int	bus;
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev);
+	struct	fb_videomode mode;
+};
+
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= NULL,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect && dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			panel = displays[0].mode.name;
+			printf("No panel detected: default to %s\n", panel);
+			i = 0;
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = __raw_readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
+			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_enet();
+
+	ret = cpu_eth_init(bis);
+	if (ret)
+		printf("FEC MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+#ifndef CONFIG_SPL_BUILD
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+#endif
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+#ifdef CONFIG_ADVANTECH
+	enable_AXI_cache();
+#endif
+	return 0;
+}
+
+#if defined (CONFIG_ADVANTECH) && defined(CONFIG_SUPPORT_LVDS)
+void setup_lvds_init(void)
+{
+	u32 reg = 0;
+
+	imx_iomux_v3_setup_pad(IOMUX_LCD_BKLT_PWM); /* LCD_BKLT_PWM */
+	imx_iomux_v3_setup_pad(IOMUX_LCD_BKLT_EN); /* LCD_BKLT_EN */
+	imx_iomux_v3_setup_pad(IOMUX_LCD_VDD_EN); /* LCD_VDD_EN */
+
+	/* LCD_BKLT_PWM - disable pwm */
+	gpio_direction_output(LCD_BKLT_PWM, 0);
+
+	/* LCD_BKLT_EN - disable backlight */
+	gpio_direction_output(LCD_BKLT_EN, 0);
+
+	/* LCD_VDD_EN - disable VDD */
+	gpio_direction_output(LCD_VDD_EN, 0);
+}
+
+void setup_lvds_poweron(void)
+{
+	//LCD_BKLT_EN
+	gpio_direction_output(LCD_BKLT_EN, 1);
+
+	//LCD_VDD_EN
+	gpio_direction_output(LCD_VDD_EN, 1);
+}
+#endif
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#if defined (CONFIG_ADVANTECH) && defined(CONFIG_SUPPORT_LVDS)
+	setup_lvds_init();
+	setup_lvds_poweron();
+#endif
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+	setup_epdc();
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd2",	 MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+	int ret = 0;
+
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_I2C_MXC
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED,
+			CONFIG_SYS_I2C_SLAVE, &i2c_pad_info1);
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+	    break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+	    break;
+	case MMC4_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc2");
+	    break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 5)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_GPIO_5__GPIO_1_5 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+    int button_pressed = 0;
+    int recovery_mode = 0;
+
+    recovery_mode = recovery_check_and_clean_flag();
+
+    /* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+			ARRAY_SIZE(recovery_key_pads));
+
+    gpio_direction_input(GPIO_VOL_DN_KEY);
+
+    if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+    }
+
+    return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc1 recovery");
+		break;
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+int checkboard(void)
+{
+	puts("Board: MX6Q/SDL-SabreSD\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6_PAD_ENET_RX_ER__ANATOP_USBOTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+			ARRAY_SIZE(otg_udc_pads));
+
+	/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+    mxc_iomux_set_gpr_register(1, 13, 1, 0);
+}
+
+#endif /*CONFIG_IMX_UDC*/
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_EIM_D22__USBOH3_USBOTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__ANATOP_USBOTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_hc1_pads[] = {
+	MX6_PAD_ENET_TXD1__GPIO_1_29 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+			ARRAY_SIZE(usb_otg_pads));
+
+		/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+		mxc_iomux_set_gpr_register(1, 13, 1, 0);
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_hc1_pads,
+			ARRAY_SIZE(usb_hc1_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on)
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 1);
+		else
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_IMX_ECSPI
+s32 spi_get_cfg(struct imx_spi_dev_t *dev)
+{
+	switch (dev->slave.cs) {
+	case 0:
+		/* SPI-NOR */
+#ifdef CONFIG_SPI_BOOT
+		if(dev->slave.bus ==0) dev->base = ECSPI1_BASE_ADDR;
+		else if(dev->slave.bus ==4) dev->base = ECSPI5_BASE_ADDR;
+#else
+		dev->base = ECSPI1_BASE_ADDR;
+#endif
+		dev->freq = 25000000;
+		dev->ss_pol = IMX_SPI_ACTIVE_LOW;
+		dev->ss = 0;
+		dev->fifo_sz = 64 * 4;
+		dev->us_delay = 0;
+		break;
+	case 1:
+		/* SPI-NOR */
+#ifdef CONFIG_SPI_BOOT
+		if(dev->slave.bus ==0) dev->base = ECSPI1_BASE_ADDR;
+		else if(dev->slave.bus ==4) dev->base = ECSPI5_BASE_ADDR;
+#else
+		dev->base = ECSPI1_BASE_ADDR;
+#endif
+		dev->freq = 25000000;
+		dev->ss_pol = IMX_SPI_ACTIVE_LOW;
+		dev->ss = 1;
+		dev->fifo_sz = 64 * 4;
+		dev->us_delay = 0;
+		break;
+	default:
+		printf("Invalid Bus ID!\n");
+	}
+
+	return 0;
+}
+
+void spi_io_init(struct imx_spi_dev_t *dev)
+{
+	u32 reg;
+
+	switch (dev->base) {
+	case ECSPI1_BASE_ADDR:
+		/* Enable clock */
+		reg = readl(CCM_BASE_ADDR + CLKCTL_CCGR1);
+		reg |= 0x3;
+		writel(reg, CCM_BASE_ADDR + CLKCTL_CCGR1);
+
+#if defined (CONFIG_ADVANTECH)
+	#if defined (CONFIG_ROM3420)
+			/* SCLK */
+			imx_iomux_v3_setup_pad(MX6_PAD_KEY_COL0__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* MISO */
+			imx_iomux_v3_setup_pad(MX6_PAD_KEY_COL1__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* MOSI */
+			imx_iomux_v3_setup_pad(MX6_PAD_KEY_ROW0__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* CS0 */
+			imx_iomux_v3_setup_pad(MX6_PAD_KEY_ROW1__ECSPI1_SS0 | MUX_PAD_CTRL(NO_PAD_CTRL));
+
+			/* CS1 */
+			imx_iomux_v3_setup_pad(MX6_PAD_KEY_COL2__ENET_RDATA_2 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	#elif defined (CONFIG_ROM7420)
+			/* SCLK */
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* MISO */
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* MOSI */
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* CS0 */
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_D19__ECSPI1_SS1 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	#else
+			/* SCLK */
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_D16__ECSPI1_SCLK	| MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* MISO */
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__ECSPI1_MISO	| MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			/* MOSI */
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_D18__ECSPI1_MOSI	| MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+			imx_iomux_v3_setup_pad(MX6_PAD_EIM_EB2__ECSPI1_SS0	| MUX_PAD_CTRL(NO_PAD_CTRL));
+	#endif
+#else
+		/* SCLK */
+		imx_iomux_v3_setup_pad(MX6_PAD_KEY_COL0__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+		/* MISO */
+		imx_iomux_v3_setup_pad(MX6_PAD_KEY_COL1__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+		/* MOSI */
+		imx_iomux_v3_setup_pad(MX6_PAD_KEY_ROW0__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL));
+
+		imx_iomux_v3_setup_pad(MX6_PAD_KEY_ROW1__GPIO_4_9    | MUX_PAD_CTRL(NO_PAD_CTRL));
+#endif
+		break;
+	case ECSPI2_BASE_ADDR:
+	case ECSPI3_BASE_ADDR:
+		/* ecspi2-3 fall through */
+		break;
+#ifdef CONFIG_ADVANTECH
+#ifdef CONFIG_SPI_BOOT
+	case ECSPI5_BASE_ADDR:
+		reg = readl(CCM_BASE_ADDR + CLKCTL_CCGR1);
+		reg |= 0x300;
+		writel(reg, CCM_BASE_ADDR + CLKCTL_CCGR1);
+#ifdef CONFIG_ROM5420
+		/* SCLK */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_CLK__ECSPI5_SCLK  | MUX_PAD_CTRL(SPI_PAD_CTRL));
+		/* MISO */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_DAT0__ECSPI5_MISO  | MUX_PAD_CTRL(SPI_PAD_CTRL));
+		/* MOSI */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_CMD__ECSPI5_MOSI  | MUX_PAD_CTRL(SPI_PAD_CTRL));
+		/* ss0 */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_DAT1__ECSPI5_SS0   | MUX_PAD_CTRL(NO_PAD_CTRL));
+#elif defined(CONFIG_ROM3420)
+  		imx_iomux_v3_setup_pad(MX6_PAD_SD1_CLK__ECSPI5_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL));  /* SCLK */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_DAT0__ECSPI5_MISO| MUX_PAD_CTRL(SPI_PAD_CTRL)); /* MISO */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_CMD__ECSPI5_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL));  /* MOSI */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_DAT1__ECSPI5_SS0 | MUX_PAD_CTRL(NO_PAD_CTRL));  /* CS0  */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_DAT2__ECSPI5_SS1 | MUX_PAD_CTRL(NO_PAD_CTRL));  /* CS1  */
+		imx_iomux_v3_setup_pad(MX6_PAD_SD1_DAT3__ECSPI5_SS2 | MUX_PAD_CTRL(NO_PAD_CTRL));  /* CS2  */
+#endif
+		break;
+#endif
+#endif
+	default:
+		break;
+	}
+}
+
+#endif
+
+#endif
Index: board/freescale/mx6qadvantech/Makefile
===================================================================
diff --git a/board/freescale/mx6qadvantech/Makefile b/board/freescale/mx6qadvantech/Makefile
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/mx6qadvantech/Makefile	(revision 1734)
@@ -0,0 +1,50 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011-2013 Freescale Semiconductor, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB    = $(obj)lib$(BOARD).o
+
+COBJS  := mx6qadvantech.o
+
+SRCS   := $(COBJS:.o=.c)
+OBJS   := $(addprefix $(obj),$(COBJS))
+
+ifndef CONFIG_SPL_BUILD
+all:	$(LIB) plugin.bin
+else
+all:	$(LIB)
+endif
+
+$(LIB):        $(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+plugin.bin: plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
Index: board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01_20140630.inc
===================================================================
diff --git a/board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01_20140630.inc b/board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01_20140630.inc
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01_20140630.inc	(revision 1734)
@@ -0,0 +1,192 @@
+//=============================================================================			
+//init script for i.MX6DL DDR3			
+//=============================================================================			
+// Revision History			
+// v01			
+//=============================================================================			
+			
+wait = on			
+//=============================================================================			
+// Disable	WDOG		
+//=============================================================================			
+//setmem /16	0x020bc000 =	0x30	
+			
+//=============================================================================			
+// Enable all clocks (they are disabled by ROM code)			
+//=============================================================================			
+setmem /32	0x020c4068 =	0xffffffff	
+setmem /32	0x020c406c =	0xffffffff	
+setmem /32	0x020c4070 =	0xffffffff	
+setmem /32	0x020c4074 =	0xffffffff	
+setmem /32	0x020c4078 =	0xffffffff	
+setmem /32	0x020c407c =	0xffffffff	
+setmem /32	0x020c4080 =	0xffffffff	
+setmem /32	0x020c4084 =	0xffffffff	
+			
+//=============================================================================			
+// IOMUX			
+//=============================================================================			
+//DDR IO TYPE:			
+setmem /32	0x020e0774 =	0x000C0000	// IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 
+setmem /32	0x020e0754 =	0x00000000	// IOMUXC_SW_PAD_CTL_GRP_DDRPKE 
+			
+//CLOCK:			
+setmem /32	0x020e04ac =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0
+setmem /32	0x020e04b0 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1
+			
+//ADDRESS:			
+setmem /32	0x020e0464 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS
+setmem /32	0x020e0490 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS
+setmem /32	0x020e074c =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_ADDDS 
+			
+//CONTROL:			
+setmem /32	0x020e0494 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET
+			
+setmem /32	0x020e04a0 =	0x00000000	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 - DSE can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS
+setmem /32	0x020e04b4 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+setmem /32	0x020e04b8 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+setmem /32	0x020e076c =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_CTLDS 
+			
+//DATA STROBE:			
+setmem /32	0x020e0750 =	0x00020000	// IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 
+			
+setmem /32	0x020e04bc =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 
+setmem /32	0x020e04c0 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 
+setmem /32	0x020e04c4 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 
+setmem /32	0x020e04c8 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 
+setmem /32	0x020e04cc =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 
+setmem /32	0x020e04d0 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 
+setmem /32	0x020e04d4 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 
+setmem /32	0x020e04d8 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 
+			
+//DATA:			
+setmem /32	0x020e0760 =	0x00020000	// IOMUXC_SW_PAD_CTL_GRP_DDRMODE
+			
+setmem /32	0x020e0764 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B0DS 
+setmem /32	0x020e0770 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B1DS 
+setmem /32	0x020e0778 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B2DS 
+setmem /32	0x020e077c =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B3DS 
+setmem /32	0x020e0780 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B4DS 
+setmem /32	0x020e0784 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B5DS 
+setmem /32	0x020e078c =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B6DS 
+setmem /32	0x020e0748 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B7DS 
+			
+setmem /32	0x020e0470 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0
+setmem /32	0x020e0474 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1
+setmem /32	0x020e0478 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2
+setmem /32	0x020e047c =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3
+setmem /32	0x020e0480 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4
+setmem /32	0x020e0484 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5
+setmem /32	0x020e0488 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6
+setmem /32	0x020e048c =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7
+			
+//=============================================================================			
+// DDR Controller Registers			
+//=============================================================================			
+// Manufacturer:	Micron		
+// Device Part Number:	MT41J128M16HA-15E		
+// Clock Freq.: 	400MHz		
+// Density per CS in Gb: 	8		
+// Chip Selects used:	1		
+// Number of Banks:	8		
+// Row address:    	14		
+// Column address: 	10		
+// Data bus width	64		
+//=============================================================================			
+setmem /32	0x021b0800 =	0xa1390003 	// DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+			
+// write leveling, based on Freescale board layout and T topology			
+// For target board, may need to run write leveling calibration 			
+// to fine tune these settings			
+// If target board does not use T topology, then these registers			
+// should either be cleared or write leveling calibration can be run			
+setmem /32	0x021b080c = 	0x001F001F	
+setmem /32	0x021b0810 = 	0x001F001F	
+setmem /32	0x021b480c = 	0x001F001F	
+setmem /32	0x021b4810 = 	0x001F001F	
+			
+//######################################################			
+//calibration values based on calibration compare of 0x00ffff00:			
+//Note, these calibration values are based on Freescale's board			
+//May need to run calibration on target board to fine tune these 			
+//######################################################			
+			
+//Read DQS Gating calibration			
+setmem /32	0x021b083c =	0x425C025C	// MPDGCTRL0 PHY0
+setmem /32	0x021b0840 =	0x0240024C	// MPDGCTRL1 PHY0
+setmem /32	0x021b483c =	0x42380238	// MPDGCTRL0 PHY1
+setmem /32	0x021b4840 =	0x02240230	// MPDGCTRL1 PHY1
+			
+//Read calibration			
+setmem /32	0x021b0848 =	0x42484644	// MPRDDLCTL PHY0
+setmem /32	0x021b4848 =	0x48464640	// MPRDDLCTL PHY1
+			
+//Write calibration			
+setmem /32	0x021b0850 =	0x32363032	// MPWRDLCTL PHY0
+setmem /32	0x021b4850 =	0x36383832	// MPWRDLCTL PHY1
+			
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):			
+setmem /32	0x021b081c =	0x33333333	// DDR_PHY_P0_MPREDQBY0DL3
+setmem /32	0x021b0820 =	0x33333333	// DDR_PHY_P0_MPREDQBY1DL3
+setmem /32	0x021b0824 =	0x33333333	// DDR_PHY_P0_MPREDQBY2DL3
+setmem /32	0x021b0828 =	0x33333333	// DDR_PHY_P0_MPREDQBY3DL3
+setmem /32	0x021b481c =	0x33333333	// DDR_PHY_P1_MPREDQBY0DL3
+setmem /32	0x021b4820 =	0x33333333	// DDR_PHY_P1_MPREDQBY1DL3
+setmem /32	0x021b4824 =	0x33333333	// DDR_PHY_P1_MPREDQBY2DL3
+setmem /32	0x021b4828 =	0x33333333	// DDR_PHY_P1_MPREDQBY3DL3
+			
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented			
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+			
+// Complete calibration by forced measurement:			
+setmem /32	0x021b08b8 =	0x00000800 	// DDR_PHY_P0_MPMUR0, frc_msr
+setmem /32	0x021b48b8 =	0x00000800 	// DDR_PHY_P0_MPMUR0, frc_msr
+			
+//MMDC init:			
+setmem /32	0x021b0004 =	0x0002002D	// MMDC0_MDPDC 
+setmem /32	0x021b0008 =	0x00333030	// MMDC0_MDOTC
+setmem /32	0x021b000c =	0x3F435313	// MMDC0_MDCFG0
+setmem /32	0x021b0010 =	0xB66E8B63	// MMDC0_MDCFG1
+setmem /32	0x021b0014 =	0x01FF00DB	// MMDC0_MDCFG2
+setmem /32	0x021b0018 =	0x00001740	// MMDC0_MDMISC
+//NOTE about MDMISC RALAT:			
+//MDMISC: RALAT kept to the high level of 5 to ensure stable operation at 528MHz. 			
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 			
+//a. better operation at low frequency			
+//b. Small performence improvment			
+			
+setmem /32	0x021b001c =	0x00008000	// MMDC0_MDSCR, set the Configuration request bit during MMDC set up
+setmem /32	0x021b002c =	0x000026d2	// MMDC0_MDRWD; recommend to maintain the default values
+setmem /32	0x021b0030 =	0x00431023	// MMDC0_MDOR
+setmem /32	0x021b0040 =	0x00000027	// CS0_END 
+			
+setmem /32	0x021b0000 =	0x831A0000	// MMDC0_MDCTL
+			
+// Mode register writes			
+setmem /32	0x021b001c =	0x04008032	// MMDC0_MDSCR, MR2 write, CS0
+setmem /32	0x021b001c =	0x00008033	// MMDC0_MDSCR, MR3 write, CS0
+setmem /32	0x021b001c =	0x00048031	// MMDC0_MDSCR, MR1 write, CS0
+setmem /32	0x021b001c =	0x05208030	// MMDC0_MDSCR, MR0 write, CS0
+setmem /32	0x021b001c =	0x04008040	// MMDC0_MDSCR, ZQ calibration command sent to device on CS0
+			
+//setmem /32	0x021b001c =	0x0400803A	// MMDC0_MDSCR, MR2 write, CS1
+//setmem /32	0x021b001c =	0x0000803B	// MMDC0_MDSCR, MR3 write, CS1
+//setmem /32	0x021b001c =	0x00048039	// MMDC0_MDSCR, MR1 write, CS1
+//setmem /32	0x021b001c =	0x05208038	// MMDC0_MDSCR, MR0 write, CS1
+//setmem /32	0x021b001c =	0x04008048	// MMDC0_MDSCR, ZQ calibration command sent to device on CS1
+			
+			
+setmem /32	0x021b0020 =	0x00005800	// MMDC0_MDREF
+			
+// It is recommended for new board designs and for customer boards			
+// to program these registers to a value of "0x00011117" 			
+// The DRAM ODT remains enabled and it is required to leave the DRAM ODT enabled			
+setmem /32	0x021b0818 =	0x00033337	// DDR_PHY_P0_MPODTCTRL
+setmem /32	0x021b4818 =	0x00033337	// DDR_PHY_P1_MPODTCTRL
+			
+			
+setmem /32	0x021b0004 =	0x0002556D	// MMDC0_MDPDC with PWDT bits set
+setmem /32	0x021b0404 = 	0x00011006	// MMDC0_MAPSR ADOPT power down enabled, MMDC will enter automatically to self-refresh while the number of idle cycle reached.
+			
+setmem /32	0x021b001c =	0x00000000	// MMDC0_MDSCR, clear this register (especially the configuration bit as initialization is complete)
Index: board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01.cfg b/board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01.cfg	(revision 1734)
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+//DDR IO TYPE:
+DATA 4, 0x020e0774, 0x000C0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE
+DATA 4, 0x020e0754, 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE
+
+//CLOCK:
+DATA 4, 0x020e04ac, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0
+DATA 4, 0x020e04b0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1
+
+//ADDRESS:
+DATA 4, 0x020e0464, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS
+DATA 4, 0x020e0490, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS
+DATA 4, 0x020e074c, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_ADDDS
+
+//CONTROL:
+DATA 4, 0x020e0494, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET
+
+DATA 4, 0x020e04a0, 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 - DSE can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS
+
+DATA 4, 0x020e04b4, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4, 0x020e04b8, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4, 0x020e076c, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_CTLDS
+
+//DATA STROBE:
+DATA 4, 0x020e0750, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL
+
+DATA 4, 0x020e04bc, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0
+DATA 4, 0x020e04c0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1
+DATA 4, 0x020e04c4, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2
+DATA 4, 0x020e04c8, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3
+DATA 4, 0x020e04cc, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4
+DATA 4, 0x020e04d0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5
+DATA 4, 0x020e04d4, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6
+DATA 4, 0x020e04d8, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7
+
+//DATA:
+DATA 4, 0x020e0760, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE
+
+DATA 4, 0x020e0764, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B0DS
+DATA 4, 0x020e0770, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B1DS
+DATA 4, 0x020e0778, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B2DS
+DATA 4, 0x020e077c, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B3DS
+DATA 4, 0x020e0780, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B4DS
+DATA 4, 0x020e0784, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B5DS
+DATA 4, 0x020e078c, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B6DS
+DATA 4, 0x020e0748, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B7DS
+
+DATA 4, 0x020e0470, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0
+DATA 4, 0x020e0474, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1
+DATA 4, 0x020e0478, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2
+DATA 4, 0x020e047c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3
+DATA 4, 0x020e0480, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4
+DATA 4, 0x020e0484, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5
+DATA 4, 0x020e0488, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6
+DATA 4, 0x020e048c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7
+
+//=============================================================================			
+// DDR Controller Registers			
+//=============================================================================			
+// Manufacturer:	Micron		
+// Device Part Number:	MT41J128M16HA-15E		
+// Clock Freq.: 	400MHz		
+// Density per CS in Gb: 	8		
+// Chip Selects used:	1		
+// Number of Banks:	8		
+// Row address:    	14		
+// Column address: 	10		
+// Data bus width	64		
+//=============================================================================
+DATA 4, 0x021b0800, 0xa1390003 // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling, based on Freescale board layout and T topology			
+// For target board, may need to run write leveling calibration 			
+// to fine tune these settings			
+// If target board does not use T topology, then these registers			
+// should either be cleared or write leveling calibration can be run
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+
+//######################################################			
+//calibration values based on calibration compare of 0x00ffff00:			
+//Note, these calibration values are based on Freescale's board			
+//May need to run calibration on target board to fine tune these 			
+//######################################################
+
+//Read DQS Gating calibration
+DATA 4, 0x021b083c, 0x425C025C // MPDGCTRL0 PHY0
+DATA 4, 0x021b0840, 0x0240024C // MPDGCTRL1 PHY0
+DATA 4, 0x021b483c, 0x42380238 // MPDGCTRL0 PHY1
+DATA 4, 0x021b4840, 0x02240230 // MPDGCTRL1 PHY1
+
+//Read calibration
+DATA 4, 0x021b0848, 0x42484644 // MPRDDLCTL PHY0
+DATA 4, 0x021b4848, 0x48464640 // MPRDDLCTL PHY1
+
+//Write calibration	
+DATA 4, 0x021b0850, 0x32363032 // MPWRDLCTL PHY0
+DATA 4, 0x021b4850, 0x36383832 // MPWRDLCTL PHY1
+
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):
+DATA 4, 0x021b081c, 0x33333333 // DDR_PHY_P0_MPREDQBY0DL3
+DATA 4, 0x021b0820, 0x33333333 // DDR_PHY_P0_MPREDQBY1DL3
+DATA 4, 0x021b0824, 0x33333333 // DDR_PHY_P0_MPREDQBY2DL3
+DATA 4, 0x021b0828, 0x33333333 // DDR_PHY_P0_MPREDQBY3DL3
+DATA 4, 0x021b481c, 0x33333333 // DDR_PHY_P1_MPREDQBY0DL3
+DATA 4, 0x021b4820, 0x33333333 // DDR_PHY_P1_MPREDQBY1DL3
+DATA 4, 0x021b4824, 0x33333333 // DDR_PHY_P1_MPREDQBY2DL3
+DATA 4, 0x021b4828, 0x33333333 // DDR_PHY_P1_MPREDQBY3DL3
+
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented			
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492
+
+// Complete calibration by forced measurement:
+DATA 4, 0x021b08b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4, 0x021b48b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+
+//MMDC init:
+DATA 4, 0x021b0004, 0x0002002D // MMDC0_MDPDC
+DATA 4, 0x021b0008, 0x00333030 // MMDC0_MDOTC
+DATA 4, 0x021b000c, 0x3F435313 // MMDC0_MDCFG0
+DATA 4, 0x021b0010, 0xB66E8B63 // MMDC0_MDCFG1
+DATA 4, 0x021b0014, 0x01FF00DB // MMDC0_MDCFG2
+DATA 4, 0x021b0018, 0x00001740 // MMDC0_MDMISC
+//NOTE about MDMISC RALAT:			
+//MDMISC: RALAT kept to the high level of 5 to ensure stable operation at 528MHz. 			
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 			
+//a. better operation at low frequency			
+//b. Small performence improvment		
+
+DATA 4, 0x021b001c, 0x00008000 // MMDC0_MDSCR, set the Configuration request bit during MMDC set up
+DATA 4, 0x021b002c, 0x000026d2 // MMDC0_MDRWD; recommend to maintain the default values
+DATA 4, 0x021b0030, 0x00431023 // MMDC0_MDOR
+DATA 4, 0x021b0040, 0x00000027 // CS0_END
+
+DATA 4, 0x021b0000, 0x831A0000 // MMDC0_MDCTL
+
+// Mode register writes
+DATA 4, 0x021b001c, 0x04008032 // MMDC0_MDSCR, MR2 write, CS0
+DATA 4, 0x021b001c, 0x00008033 // MMDC0_MDSCR, MR3 write, CS0
+DATA 4, 0x021b001c, 0x00048031 // MMDC0_MDSCR, MR1 write, CS0
+DATA 4, 0x021b001c, 0x05208030 // MMDC0_MDSCR, MR0 write, CS0
+DATA 4, 0x021b001c, 0x04008040 // MMDC0_MDSCR, ZQ calibration command sent to device on CS0
+
+//setmem /32	0x021b001c =	0x0400803A	// MMDC0_MDSCR, MR2 write, CS1
+//setmem /32	0x021b001c =	0x0000803B	// MMDC0_MDSCR, MR3 write, CS1
+//setmem /32	0x021b001c =	0x00048039	// MMDC0_MDSCR, MR1 write, CS1
+//setmem /32	0x021b001c =	0x05208038	// MMDC0_MDSCR, MR0 write, CS1
+//setmem /32	0x021b001c =	0x04008048	// MMDC0_MDSCR, ZQ calibration command sent to device on CS1
+
+DATA 4, 0x021b0020, 0x00005800 // MMDC0_MDREF
+
+// It is recommended for new board designs and for customer boards			
+// to program these registers to a value of "0x00011117" 			
+// The DRAM ODT remains enabled and it is required to leave the DRAM ODT enabled
+DATA 4, 0x021b0818, 0x00033337 // DDR_PHY_P0_MPODTCTRL
+DATA 4, 0x021b4818, 0x00033337 // DDR_PHY_P1_MPODTCTRL
+
+DATA 4, 0x021b0004, 0x0002556D // MMDC0_MDPDC with PWDT bits set
+DATA 4, 0x021b0404, 0x00011006 // MMDC0_MAPSR ADOPT power down enabled, MMDC will enter automatically to self-refresh while the number of idle cycle reached.
+
+DATA 4, 0x021b001c, 0x00000000 // MMDC0_MDSCR, clear this register (especially the configuration bit as initialization is complete)
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6q.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6q.cfg b/board/freescale/imx/ddr/mx6q.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6q.cfg	(revision 1734)
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
+ */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000028
+DATA 4, 0x020e05b0, 0x00000028
+DATA 4, 0x020e0524, 0x00000028
+DATA 4, 0x020e051c, 0x00000028
+DATA 4, 0x020e0518, 0x00000028
+DATA 4, 0x020e050c, 0x00000028
+DATA 4, 0x020e05b8, 0x00000028
+DATA 4, 0x020e05c0, 0x00000028
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000028
+DATA 4, 0x020e0788, 0x00000028
+DATA 4, 0x020e0794, 0x00000028
+DATA 4, 0x020e079c, 0x00000028
+DATA 4, 0x020e07a0, 0x00000028
+DATA 4, 0x020e07a4, 0x00000028
+DATA 4, 0x020e07a8, 0x00000028
+DATA 4, 0x020e0748, 0x00000028
+DATA 4, 0x020e05ac, 0x00000028
+DATA 4, 0x020e05b4, 0x00000028
+DATA 4, 0x020e0528, 0x00000028
+DATA 4, 0x020e0520, 0x00000028
+DATA 4, 0x020e0514, 0x00000028
+DATA 4, 0x020e0510, 0x00000028
+DATA 4, 0x020e05bc, 0x00000028
+DATA 4, 0x020e05c4, 0x00000028
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43260335
+DATA 4, 0x021b0840, 0x031A030B
+DATA 4, 0x021b483c, 0x4323033B
+DATA 4, 0x021b4840, 0x0323026F
+DATA 4, 0x021b0848, 0x483D4545
+DATA 4, 0x021b4848, 0x44433E48
+DATA 4, 0x021b0850, 0x41444840
+DATA 4, 0x021b4850, 0x4835483E
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x8A8F7955
+DATA 4, 0x021b0010, 0xFF328F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x008F1023
+DATA 4, 0x021b0040, 0x00000047
+DATA 4, 0x021b0000, 0x841A0000
+// Mode register writes			
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+			
+// It is recommended for new board designs and for customer boards			
+// to program these registers to a value of "0x00011117" 			
+// The DRAM ODT remains enabled and it is required to leave the DRAM ODT enabled			
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0xFFFFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif

Property changes on: board/freescale/imx/ddr/mx6q.cfg
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01_20151203.inc
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01_20151203.inc b/board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01_20151203.inc
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01_20151203.inc	(revision 1734)
@@ -0,0 +1,274 @@
+//*================================================================================================
+//* Copyright (C) 2011, Freescale Semiconductor, Inc. All Rights Reserved
+//* THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
+//* BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
+//* Freescale Semiconductor, Inc.
+//*================================================================================================
+
+
+// DDR init script, written in ARM RVDS syntax
+// Target the CPUDDR3 board
+// Timing optimized to 528MHz. 64-bit data bus 
+
+
+// Initialization script for i.MX6q CPU Board (DDR3)
+// Version 1.0 (07-06-11)
+// v 1.01 (June 16, 2011)
+// - based on Boaz's orignal script
+// - changed write leveling to 0x44
+// - updated DDR calibration (DQS gating, read/write) per latest gathered from stress test code
+//
+// v 1.02 (July 20, 2011)
+// - DDR_INPUT bit cleared for: DQM, RAS, CAS, SDCLK, RESET (All output only...)
+
+
+// v 1.03 (July 20, 2011)
+//   - ADOPT, DDRCTL power down timer activated by configuring MMDC0_MAPSR & MMDC0_MDPDC 
+
+//  v 1.04 (Oct 20, 2011)
+//  - More order in file
+//  - One-time HW ZQ calibration added.
+//  - power down timers enable moved to end of config
+// 
+//  v 1.05 (Mar 25, 2012)
+//  - IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET setup corrected to set DDR_SEL='11' (DDR3). This corrects ZQ calibration operation. 
+//    Improvment of DDR signals levels is expected.  
+//  - DQS drive strength reduced 6->7,device Rtt_nom 120->60, show better overclocking with new DDR_SEL 
+//  - tMRD value increased by 1 to match JEDEC
+
+//  v 1.06 (june 12, 2012)
+// - SDCLK duty cycle fine tunning changed from default to low.
+// - Previous step of setting DRAM_RESET/DDR_SEL='11' is reversed back to '00'
+//   , after finding the later to have a better DDR signals integrity. IO design are still investigating this.
+// -  i.mx ODT configs changed : 60 -> 120Ohm, to save power. See more in comment bellow.
+// - IOMUX configs: Remove redundant (input only...) pull setup from output signals: SDCKE, ODT
+
+//  v 1.07 
+// - Silicon version v1.2 (MX6Q/DxxxxxxxC) compatible. SDCLK duty cycle fine tute is back to default (2).
+// - MAARCR registers modified to reflect the best simulated ADOPT performence
+
+//================================================================================================
+
+
+
+wait = on
+
+//*================================================================================================
+// Disable WDOG
+//*================================================================================================
+//setmem /16 0x020bc000 = 0x30
+
+
+//*================================================================================================
+// Enable all clocks (they are disabled by ROM code)
+//*================================================================================================
+setmem /32 0x020c4068 = 0xffffffff
+setmem /32 0x020c406c = 0xffffffff
+setmem /32 0x020c4070 = 0xffffffff
+setmem /32 0x020c4074 = 0xffffffff
+setmem /32 0x020c4078 = 0xffffffff
+setmem /32 0x020c407c = 0xffffffff
+setmem /32 0x020c4080 = 0xffffffff
+setmem /32 0x020c4084 = 0xffffffff
+
+
+//*================================================================================================
+// Initialize 64-bit DDR3 
+//*================================================================================================
+
+//######################################################
+// IOMUX 
+//######################################################
+
+//DDR IO TYPE:
+setmem /32 0x020e0798 = 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+setmem /32 0x020e0758 = 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.
+
+//CLOCK:
+setmem /32 0x020e0588 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0
+setmem /32 0x020e0594 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0
+
+//ADDRESS:
+setmem /32 0x020e056c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0578 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e074c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+setmem /32 0x020e057c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+setmem /32 0x020e058c = 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+setmem /32 0x020e059c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+setmem /32 0x020e05a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+setmem /32 0x020e078c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+setmem /32 0x020e0750 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+setmem /32 0x020e05a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+setmem /32 0x020e05b0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+setmem /32 0x020e0524 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+setmem /32 0x020e051c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+setmem /32 0x020e0518 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+setmem /32 0x020e050c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+setmem /32 0x020e05b8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+setmem /32 0x020e05c0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+setmem /32 0x020e0774 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+setmem /32 0x020e0784 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+setmem /32 0x020e0788 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+setmem /32 0x020e0794 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+setmem /32 0x020e079c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+setmem /32 0x020e07a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+setmem /32 0x020e07a4 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+setmem /32 0x020e07a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+setmem /32 0x020e0748 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+setmem /32 0x020e05ac = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05b4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0528 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0520 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0514 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0510 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05bc = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05c4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+setmem /32 0x021b0800 = 0xa1390003      // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+setmem /32 0x021b080c = 0x001F001F
+setmem /32 0x021b0810 = 0x001F001F
+
+setmem /32 0x021b480c = 0x001F001F
+setmem /32 0x021b4810 = 0x001F001F
+
+//DQS gating, read delay, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+setmem /32 0x021b083c = 0x433C0344
+setmem /32 0x021b0840 = 0x03300338
+setmem /32 0x021b483c = 0x4348034C
+setmem /32 0x021b4840 = 0x03400310
+
+//Read calibration
+setmem /32 0x021b0848 = 0x40363A3C
+setmem /32 0x021b4848 = 0x3836323E
+
+//Write calibration
+setmem /32 0x021b0850 = 0x3E384044
+setmem /32 0x021b4850 = 0x443C4646
+
+
+
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):
+setmem /32 0x021b081c = 0x33333333      // DDR_PHY_P0_MPREDQBY0DL3
+setmem /32 0x021b0820 = 0x33333333      // DDR_PHY_P0_MPREDQBY1DL3
+setmem /32 0x021b0824 = 0x33333333      // DDR_PHY_P0_MPREDQBY2DL3
+setmem /32 0x021b0828 = 0x33333333      // DDR_PHY_P0_MPREDQBY3DL3
+setmem /32 0x021b481c = 0x33333333      // DDR_PHY_P1_MPREDQBY0DL3
+setmem /32 0x021b4820 = 0x33333333      // DDR_PHY_P1_MPREDQBY1DL3
+setmem /32 0x021b4824 = 0x33333333      // DDR_PHY_P1_MPREDQBY2DL3
+setmem /32 0x021b4828 = 0x33333333      // DDR_PHY_P1_MPREDQBY3DL3
+
+
+//setmem /32	0x021b082c =	0xf3333333 	// wr bit delay, byte 0
+//setmem /32	0x021b0830 =	0xf3333333 	// wr bit delay, byte 1
+//setmem /32	0x021b0834 =	0xf3333333 	// wr bit delay, byte 2
+//setmem /32	0x021b0838 =	0xf3333333 	// wr bit delay, byte 3
+//setmem /32	0x021b482c =	0xf3333333 	// wr bit delay, byte 4
+//setmem /32	0x021b4830 =	0xf3333333 	// wr bit delay, byte 5
+//setmem /32	0x021b4834 =	0xf3333333 	// wr bit delay, byte 6
+//setmem /32	0x021b4838 =	0xf3333333 	// wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+setmem /32 0x021b08b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+setmem /32 0x021b48b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, 64-bit mode, only MMDC0 is initiated:
+setmem /32 0x021b0004 = 0x00020036		// MMDC0_MDPDC see spread sheet for timings
+setmem /32 0x021b0008 = 0x09444040		// MMDC0_MDOTC see spread sheet for timings
+setmem /32 0x021b000c = 0x8A8F79A4		// MMDC0_MDCFG0 see spread sheet for timings. CL=8
+setmem /32 0x021b0010 = 0xDB538E64		// MMDC0_MDCFG1 see spread sheet for timings
+setmem /32 0x021b0014 = 0x01ff00db      // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+setmem /32 0x021b0018 = 0x00081740      // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+setmem /32 0x021b001c = 0x00008000      // MMDC0_MDSCR
+
+setmem /32 0x021b002c = 0x000026d2      // MMDC0_MDRWD
+setmem /32 0x021b0030 = 0x008F1023      // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck                                //jimmy
+setmem /32 0x021b0040 = 0x00000047      // CS0_END - 0x4fffffff 
+
+
+
+setmem /32 0x021b0000 = 0x841a0000      // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M , but fit wide range of other DDR3 devices
+//MR2:
+setmem /32 0x021b001c = 0x04088032      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0408803a      // MMDC0_MDSCR
+
+
+//MR3:
+setmem /32 0x021b001c = 0x00008033      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0000803b      // MMDC0_MDSCR
+//MR1:
+setmem /32 0x021b001c = 0x00048031      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x00048039      // MMDC0_MDSCR
+//MR0:
+
+setmem /32 0x021b001c = 0x09308030      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x09308038      // MMDC0_MDSCR, 
+
+//DDR device ZQ calibration:
+setmem /32 0x021b001c = 0x04008040      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x04008048      // MMDC0_MDSCR
+//######################################################
+//final DDR setup, before operation start:
+
+setmem /32 0x021b0020 = 0x00005800      // MMDC0_MDREF, enable auto refresh, set refresh rate.
+
+//Following ODT setup (0x11117) represents(along with obove DDR device configs) : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007,which represents: i.mx_ODT disabled, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, and seen to run very well with Freescale RDKs. Still, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+setmem /32 0x021b0818 = 0x00011117      // DDR_PHY_P0_MPODTCTRL, ODT enable
+setmem /32 0x021b4818 = 0x00011117      // DDR_PHY_P1_MPODTCTRL
+
+setmem /32 0x021b0004 = 0x00025576		// MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+setmem /32 0x021b0404 = 0x00011006      //MMDC0_MAPSR ADOPT power down enabled
+
+setmem /32 0x021b001c = 0x00000000      // MMDC0_MDSCR
+

Property changes on: board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01_20151203.inc
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx6qrom5420_4x_K4B2G1646Q-BCK0_1410024420-01_20140511.inc
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom5420_4x_K4B2G1646Q-BCK0_1410024420-01_20140511.inc b/board/freescale/imx/ddr/mx6qrom5420_4x_K4B2G1646Q-BCK0_1410024420-01_20140511.inc
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom5420_4x_K4B2G1646Q-BCK0_1410024420-01_20140511.inc	(revision 1734)
@@ -0,0 +1,192 @@
+//=============================================================================			
+//init script for i.MX6Q DDR3			
+//=============================================================================			
+// Revision History			
+// v01			
+//=============================================================================			
+			
+wait = on			
+//=============================================================================			
+// Disable	WDOG		
+//=============================================================================			
+//setmem /16	0x020bc000 =	0x30	
+			
+//=============================================================================			
+// Enable all clocks (they are disabled by ROM code)			
+//=============================================================================			
+setmem /32	0x020c4068 =	0xffffffff	
+setmem /32	0x020c406c =	0xffffffff	
+setmem /32	0x020c4070 =	0xffffffff	
+setmem /32	0x020c4074 =	0xffffffff	
+setmem /32	0x020c4078 =	0xffffffff	
+setmem /32	0x020c407c =	0xffffffff	
+setmem /32	0x020c4080 =	0xffffffff	
+setmem /32	0x020c4084 =	0xffffffff	
+			
+//=============================================================================			
+// IOMUX			
+//=============================================================================			
+//DDR IO TYPE:			
+setmem /32	0x020e0798 =	0x000C0000	// IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 
+setmem /32	0x020e0758 =	0x00000000	// IOMUXC_SW_PAD_CTL_GRP_DDRPKE 
+			
+//CLOCK:			
+setmem /32	0x020e0588 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0
+setmem /32	0x020e0594 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1
+			
+//ADDRESS:			
+setmem /32	0x020e056c =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS
+setmem /32	0x020e0578 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS
+setmem /32	0x020e074c =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_ADDDS 
+			
+//CONTROL:			
+setmem /32	0x020e057c =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET
+			
+setmem /32	0x020e058c =	0x00000000	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 - DSE can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS
+setmem /32	0x020e059c =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+setmem /32	0x020e05a0 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+setmem /32	0x020e078c =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_CTLDS 
+			
+//DATA STROBE:			
+setmem /32	0x020e0750 =	0x00020000	// IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 
+			
+setmem /32	0x020e05a8 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 
+setmem /32	0x020e05b0 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 
+setmem /32	0x020e0524 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 
+setmem /32	0x020e051c =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 
+setmem /32	0x020e0518 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 
+setmem /32	0x020e050c =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 
+setmem /32	0x020e05b8 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 
+setmem /32	0x020e05c0 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 
+			
+//DATA:			
+setmem /32	0x020e0774 =	0x00020000	// IOMUXC_SW_PAD_CTL_GRP_DDRMODE
+			
+setmem /32	0x020e0784 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B0DS 
+setmem /32	0x020e0788 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B1DS 
+setmem /32	0x020e0794 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B2DS 
+setmem /32	0x020e079c =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B3DS 
+setmem /32	0x020e07a0 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B4DS 
+setmem /32	0x020e07a4 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B5DS 
+setmem /32	0x020e07a8 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B6DS 
+setmem /32	0x020e0748 =	0x00000030	// IOMUXC_SW_PAD_CTL_GRP_B7DS 
+			
+setmem /32	0x020e05ac =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0
+setmem /32	0x020e05b4 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1
+setmem /32	0x020e0528 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2
+setmem /32	0x020e0520 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3
+setmem /32	0x020e0514 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4
+setmem /32	0x020e0510 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5
+setmem /32	0x020e05bc =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6
+setmem /32	0x020e05c4 =	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7
+			
+//=============================================================================			
+// DDR Controller Registers			
+//=============================================================================			
+// Manufacturer:	Micron		
+// Device Part Number:	MT41J128M16HA-15E		
+// Clock Freq.: 	533MHz		
+// Density per CS in Gb: 	8		
+// Chip Selects used:	1		
+// Number of Banks:	8		
+// Row address:    	14		
+// Column address: 	10		
+// Data bus width	64		
+//=============================================================================			
+setmem /32	0x021b0800 =	0xa1390003 	// DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+			
+// write leveling, based on Freescale board layout and T topology			
+// For target board, may need to run write leveling calibration 			
+// to fine tune these settings			
+// If target board does not use T topology, then these registers			
+// should either be cleared or write leveling calibration can be run			
+setmem /32	0x021b080c = 	0x001F001F	
+setmem /32	0x021b0810 = 	0x001F001F	
+setmem /32	0x021b480c = 	0x001F001F	
+setmem /32	0x021b4810 = 	0x001F001F	
+			
+//######################################################			
+//calibration values based on calibration compare of 0x00ffff00:			
+//Note, these calibration values are based on Freescale's board			
+//May need to run calibration on target board to fine tune these 			
+//######################################################			
+			
+//Read DQS Gating calibration			
+setmem /32	0x021b083c =	0x4358036C	// MPDGCTRL0 PHY0
+setmem /32	0x021b0840 =	0x03540358	// MPDGCTRL1 PHY0
+setmem /32	0x021b483c =	0x435C0364	// MPDGCTRL0 PHY1
+setmem /32	0x021b4840 =	0x03480320	// MPDGCTRL1 PHY1
+			
+//Read calibration			
+setmem /32	0x021b0848 =	0x3C343638	// MPRDDLCTL PHY0
+setmem /32	0x021b4848 =	0x3430303E	// MPRDDLCTL PHY1
+			
+//Write calibration			
+setmem /32	0x021b0850 =	0x3A3A4644	// MPWRDLCTL PHY0
+setmem /32	0x021b4850 =	0x46344A40	// MPWRDLCTL PHY1
+			
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):			
+setmem /32	0x021b081c =	0x33333333	// DDR_PHY_P0_MPREDQBY0DL3
+setmem /32	0x021b0820 =	0x33333333	// DDR_PHY_P0_MPREDQBY1DL3
+setmem /32	0x021b0824 =	0x33333333	// DDR_PHY_P0_MPREDQBY2DL3
+setmem /32	0x021b0828 =	0x33333333	// DDR_PHY_P0_MPREDQBY3DL3
+setmem /32	0x021b481c =	0x33333333	// DDR_PHY_P1_MPREDQBY0DL3
+setmem /32	0x021b4820 =	0x33333333	// DDR_PHY_P1_MPREDQBY1DL3
+setmem /32	0x021b4824 =	0x33333333	// DDR_PHY_P1_MPREDQBY2DL3
+setmem /32	0x021b4828 =	0x33333333	// DDR_PHY_P1_MPREDQBY3DL3
+			
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented			
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+			
+// Complete calibration by forced measurement:			
+setmem /32	0x021b08b8 =	0x00000800 	// DDR_PHY_P0_MPMUR0, frc_msr
+setmem /32	0x021b48b8 =	0x00000800 	// DDR_PHY_P0_MPMUR0, frc_msr
+			
+//MMDC init:			
+setmem /32	0x021b0004 =	0x00020036	// MMDC0_MDPDC 
+setmem /32	0x021b0008 =	0x09444040	// MMDC0_MDOTC
+setmem /32	0x021b000c =	0x555A79A4	// MMDC0_MDCFG0
+setmem /32	0x021b0010 =	0xDB538E64	// MMDC0_MDCFG1
+setmem /32	0x021b0014 =	0x01FF00DB	// MMDC0_MDCFG2
+setmem /32	0x021b0018 =	0x00001740	// MMDC0_MDMISC
+//NOTE about MDMISC RALAT:			
+//MDMISC: RALAT kept to the high level of 5 to ensure stable operation at 528MHz. 			
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 			
+//a. better operation at low frequency			
+//b. Small performence improvment			
+			
+setmem /32	0x021b001c =	0x00008000	// MMDC0_MDSCR, set the Configuration request bit during MMDC set up
+setmem /32	0x021b002c =	0x000026d2	// MMDC0_MDRWD; recommend to maintain the default values
+setmem /32	0x021b0030 =	0x005A1023	// MMDC0_MDOR
+setmem /32	0x021b0040 =	0x00000027	// CS0_END 
+			
+setmem /32	0x021b0000 =	0x831A0000	// MMDC0_MDCTL
+			
+// Mode register writes			
+setmem /32	0x021b001c =	0x04088032	// MMDC0_MDSCR, MR2 write, CS0
+setmem /32	0x021b001c =	0x00008033	// MMDC0_MDSCR, MR3 write, CS0
+setmem /32	0x021b001c =	0x00048031	// MMDC0_MDSCR, MR1 write, CS0
+setmem /32	0x021b001c =	0x09308030	// MMDC0_MDSCR, MR0 write, CS0
+setmem /32	0x021b001c =	0x04008040	// MMDC0_MDSCR, ZQ calibration command sent to device on CS0
+			
+//setmem /32	0x021b001c =	0x0408803A	// MMDC0_MDSCR, MR2 write, CS1
+//setmem /32	0x021b001c =	0x0000803B	// MMDC0_MDSCR, MR3 write, CS1
+//setmem /32	0x021b001c =	0x00048039	// MMDC0_MDSCR, MR1 write, CS1
+//setmem /32	0x021b001c =	0x09408038	// MMDC0_MDSCR, MR0 write, CS1
+//setmem /32	0x021b001c =	0x04008048	// MMDC0_MDSCR, ZQ calibration command sent to device on CS1
+			
+			
+setmem /32	0x021b0020 =	0x00005800	// MMDC0_MDREF
+			
+// It is recommended for new board designs and for customer boards			
+// to program these registers to a value of "0x00011117" 			
+// The DRAM ODT remains enabled and it is required to leave the DRAM ODT enabled			
+setmem /32	0x021b0818 =	0x00011117	// DDR_PHY_P0_MPODTCTRL
+setmem /32	0x021b4818 =	0x00011117	// DDR_PHY_P1_MPODTCTRL
+			
+			
+setmem /32	0x021b0004 =	0x00025576	// MMDC0_MDPDC with PWDT bits set
+setmem /32	0x021b0404 = 	0x00011006	// MMDC0_MAPSR ADOPT power down enabled, MMDC will enter automatically to self-refresh while the number of idle cycle reached.
+			
+setmem /32	0x021b001c =	0x00000000	// MMDC0_MDSCR, clear this register (especially the configuration bit as initialization is complete)

Property changes on: board/freescale/imx/ddr/mx6qrom5420_4x_K4B2G1646Q-BCK0_1410024420-01_20140511.inc
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx6qubc220_4x_mt41j128.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qubc220_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6qubc220_4x_mt41j128.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qubc220_4x_mt41j128.cfg	(revision 1734)
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43270338
+DATA 4, 0x021b0840, 0x03200314
+DATA 4, 0x021b483c, 0x431A032F
+DATA 4, 0x021b4840, 0x03200263
+DATA 4, 0x021b0848, 0x4B434748
+DATA 4, 0x021b4848, 0x4445404C
+DATA 4, 0x021b0850, 0x38444542
+DATA 4, 0x021b4850, 0x4935493A
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x555A7975
+DATA 4, 0x021b0010, 0xFF538F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x005A1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x831A0000
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6qrsb4410_4x_mt41j128.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrsb4410_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6qrsb4410_4x_mt41j128.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrsb4410_4x_mt41j128.cfg	(revision 1734)
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+//DDR IO TYPE:
+DATA 4, 0x020e0798, 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+DATA 4, 0x020e0758, 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.,
+
+//CLOCK:
+DATA 4, 0x020e0588, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0,
+DATA 4, 0x020e0594, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0,
+
+//ADDRESS:
+DATA 4, 0x020e056c, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0578, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e074c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+DATA 4, 0x020e057c, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+DATA 4, 0x020e058c, 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+DATA 4, 0x020e059c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4, 0x020e05a0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4, 0x020e078c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+DATA 4, 0x020e0750, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+DATA 4, 0x020e05a8, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+DATA 4, 0x020e05b0, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+DATA 4, 0x020e0524, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+DATA 4, 0x020e051c, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+DATA 4, 0x020e0518, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+DATA 4, 0x020e050c, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+DATA 4, 0x020e05b8, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+DATA 4, 0x020e05c0, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+DATA 4, 0x020e0774, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+DATA 4, 0x020e0784, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+DATA 4, 0x020e0788, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+DATA 4, 0x020e0794, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+DATA 4, 0x020e079c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+DATA 4, 0x020e07a0, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+DATA 4, 0x020e07a4, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+DATA 4, 0x020e07a8, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+DATA 4, 0x020e0748, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+DATA 4, 0x020e05ac, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05b4, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0528, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0520, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0514, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0510, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05bc, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05c4, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0,
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+DATA 4, 0x021b0800, 0xa1390003 // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+
+//DQS gating, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+DATA 4, 0x021b083c, 0x435C0368
+DATA 4, 0x021b0840, 0x03400354
+DATA 4, 0x021b483c, 0x4368036C
+DATA 4, 0x021b4840, 0x0360033C
+
+//Read calibration
+DATA 4, 0x021b0848, 0x3C383E40
+DATA 4, 0x021b4848, 0x3A3A323E
+
+//Write calibration
+DATA 4, 0x021b0850, 0x40404A44
+DATA 4, 0x021b4850, 0x4A364C44
+
+
+
+//read data bit delay: (3 is the reccommended default value
+DATA 4, 0x021b081c, 0x33333333 // DDR_PHY_P0_MPREDQBY0DL3
+DATA 4, 0x021b0820, 0x33333333 // DDR_PHY_P0_MPREDQBY1DL3
+DATA 4, 0x021b0824, 0x33333333 // DDR_PHY_P0_MPREDQBY2DL3
+DATA 4, 0x021b0828, 0x33333333 // DDR_PHY_P0_MPREDQBY3DL3
+DATA 4, 0x021b481c, 0x33333333 // DDR_PHY_P1_MPREDQBY0DL3
+DATA 4, 0x021b4820, 0x33333333 // DDR_PHY_P1_MPREDQBY1DL3
+DATA 4, 0x021b4824, 0x33333333 // DDR_PHY_P1_MPREDQBY2DL3
+DATA 4, 0x021b4828, 0x33333333 // DDR_PHY_P1_MPREDQBY3DL3
+
+
+DATA 4, 0x021b082c, 0xf3333333 // wr bit delay, byte 0
+DATA 4, 0x021b0830, 0xf3333333 // wr bit delay, byte 1
+DATA 4, 0x021b0834, 0xf3333333 // wr bit delay, byte 2
+DATA 4, 0x021b0838, 0xf3333333 // wr bit delay, byte 3
+DATA 4, 0x021b482c, 0xf3333333 // wr bit delay, byte 4
+DATA 4, 0x021b4830, 0xf3333333 // wr bit delay, byte 5
+DATA 4, 0x021b4834, 0xf3333333 // wr bit delay, byte 6
+DATA 4, 0x021b4838, 0xf3333333 // wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, uncomment the following lines. For version C (v1.2, keep commented,
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6"
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+DATA 4, 0x021b08b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4, 0x021b48b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, only MMDC0 is initiated:
+DATA 4, 0x021b0004, 0x00020036 // MMDC0_MDPDC see spread sheet for timings
+DATA 4, 0x021b0008, 0x09444040 // MMDC0_MDOTC see spread sheet for timings
+DATA 4, 0x021b000c, 0x555A79A5 // MMDC0_MDCFG0 see spread sheet for timings. CL=8
+DATA 4, 0x021b0010, 0xDB538E64 // MMDC0_MDCFG1 see spread sheet for timings
+DATA 4, 0x021b0014, 0x01ff00db // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+DATA 4, 0x021b0018, 0x00001740 // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+DATA 4, 0x021b001c, 0x00008000 // MMDC0_MDSCR
+
+DATA 4, 0x021b002c, 0x000026d2 // MMDC0_MDRWD
+DATA 4, 0x021b0030, 0x005a1023 // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck
+DATA 4, 0x021b0040, 0x00000027 // CS0_END - 0x4fffffff 
+
+//IPU error and should remove
+//DATA 4, 0x021b0400, 0x11420000 //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+//DATA 4, 0x021b4400, 0x11420000 ,
+
+
+DATA 4, 0x021b0000, 0x831a0000 // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M 
+//MR2:
+DATA 4, 0x021b001c, 0x04088032 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0408803a // MMDC0_MDSCR
+
+
+//MR3:
+DATA 4, 0x021b001c, 0x00008033 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0000803b // MMDC0_MDSCR
+//MR1:
+DATA 4, 0x021b001c, 0x00468031 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x00468039 // MMDC0_MDSCR
+//MR0:
+
+DATA 4, 0x021b001c, 0x09408030 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x09408038 // MMDC0_MDSCR
+
+//DDR device ZQ calibration:
+DATA 4, 0x021b001c, 0x04008040 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x04008048 // MMDC0_MDSCR
+//######################################################
+//final DDR setup
+
+DATA 4, 0x021b0020, 0x00005800 // MMDC0_MDREF, enable auto refresh, set refresh rate.,
+
+//Following ODT setup (0x11117 represents(along with obove DDR device configs : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+DATA 4, 0x021b0818, 0x00011117 // DDR_PHY_P0_MPODTCTRL, ODT enable
+DATA 4, 0x021b4818, 0x00011117 // DDR_PHY_P1_MPODTCTRL
+
+DATA 4, 0x021b0004, 0x00025576 // MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+DATA 4, 0x021b0404, 0x00011006 //MMDC0_MAPSR ADOPT power down enabled
+
+DATA 4, 0x021b001c, 0x00000000 // MMDC0_MDSCR
+
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01_20151126.inc
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01_20151126.inc b/board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01_20151126.inc
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01_20151126.inc	(revision 1734)
@@ -0,0 +1,274 @@
+//*================================================================================================
+//* Copyright (C) 2011, Freescale Semiconductor, Inc. All Rights Reserved
+//* THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
+//* BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
+//* Freescale Semiconductor, Inc.
+//*================================================================================================
+
+
+// DDR init script, written in ARM RVDS syntax
+// Target the CPUDDR3 board
+// Timing optimized to 528MHz. 64-bit data bus 
+
+
+// Initialization script for i.MX6q CPU Board (DDR3)
+// Version 1.0 (07-06-11)
+// v 1.01 (June 16, 2011)
+// - based on Boaz's orignal script
+// - changed write leveling to 0x44
+// - updated DDR calibration (DQS gating, read/write) per latest gathered from stress test code
+//
+// v 1.02 (July 20, 2011)
+// - DDR_INPUT bit cleared for: DQM, RAS, CAS, SDCLK, RESET (All output only...)
+
+
+// v 1.03 (July 20, 2011)
+//   - ADOPT, DDRCTL power down timer activated by configuring MMDC0_MAPSR & MMDC0_MDPDC 
+
+//  v 1.04 (Oct 20, 2011)
+//  - More order in file
+//  - One-time HW ZQ calibration added.
+//  - power down timers enable moved to end of config
+// 
+//  v 1.05 (Mar 25, 2012)
+//  - IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET setup corrected to set DDR_SEL='11' (DDR3). This corrects ZQ calibration operation. 
+//    Improvment of DDR signals levels is expected.  
+//  - DQS drive strength reduced 6->7,device Rtt_nom 120->60, show better overclocking with new DDR_SEL 
+//  - tMRD value increased by 1 to match JEDEC
+
+//  v 1.06 (june 12, 2012)
+// - SDCLK duty cycle fine tunning changed from default to low.
+// - Previous step of setting DRAM_RESET/DDR_SEL='11' is reversed back to '00'
+//   , after finding the later to have a better DDR signals integrity. IO design are still investigating this.
+// -  i.mx ODT configs changed : 60 -> 120Ohm, to save power. See more in comment bellow.
+// - IOMUX configs: Remove redundant (input only...) pull setup from output signals: SDCKE, ODT
+
+//  v 1.07 
+// - Silicon version v1.2 (MX6Q/DxxxxxxxC) compatible. SDCLK duty cycle fine tute is back to default (2).
+// - MAARCR registers modified to reflect the best simulated ADOPT performence
+
+//================================================================================================
+
+
+
+wait = on
+
+//*================================================================================================
+// Disable WDOG
+//*================================================================================================
+//setmem /16 0x020bc000 = 0x30
+
+
+//*================================================================================================
+// Enable all clocks (they are disabled by ROM code)
+//*================================================================================================
+setmem /32 0x020c4068 = 0xffffffff
+setmem /32 0x020c406c = 0xffffffff
+setmem /32 0x020c4070 = 0xffffffff
+setmem /32 0x020c4074 = 0xffffffff
+setmem /32 0x020c4078 = 0xffffffff
+setmem /32 0x020c407c = 0xffffffff
+setmem /32 0x020c4080 = 0xffffffff
+setmem /32 0x020c4084 = 0xffffffff
+
+
+//*================================================================================================
+// Initialize 64-bit DDR3 
+//*================================================================================================
+
+//######################################################
+// IOMUX 
+//######################################################
+
+//DDR IO TYPE:
+setmem /32 0x020e0798 = 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+setmem /32 0x020e0758 = 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.
+
+//CLOCK:
+setmem /32 0x020e0588 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0
+setmem /32 0x020e0594 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0
+
+//ADDRESS:
+setmem /32 0x020e056c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0578 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e074c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+setmem /32 0x020e057c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+setmem /32 0x020e058c = 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+setmem /32 0x020e059c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+setmem /32 0x020e05a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+setmem /32 0x020e078c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+setmem /32 0x020e0750 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+setmem /32 0x020e05a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+setmem /32 0x020e05b0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+setmem /32 0x020e0524 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+setmem /32 0x020e051c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+setmem /32 0x020e0518 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+setmem /32 0x020e050c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+setmem /32 0x020e05b8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+setmem /32 0x020e05c0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+setmem /32 0x020e0774 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+setmem /32 0x020e0784 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+setmem /32 0x020e0788 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+setmem /32 0x020e0794 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+setmem /32 0x020e079c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+setmem /32 0x020e07a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+setmem /32 0x020e07a4 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+setmem /32 0x020e07a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+setmem /32 0x020e0748 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+setmem /32 0x020e05ac = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05b4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0528 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0520 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0514 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0510 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05bc = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05c4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+setmem /32 0x021b0800 = 0xa1390003      // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+setmem /32 0x021b080c = 0x001F001F
+setmem /32 0x021b0810 = 0x001F001F
+
+setmem /32 0x021b480c = 0x001F001F
+setmem /32 0x021b4810 = 0x001F001F
+
+//DQS gating, read delay, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+setmem /32 0x021b083c = 0x4344034C
+setmem /32 0x021b0840 = 0x033C033C
+setmem /32 0x021b483c = 0x43500358
+setmem /32 0x021b4840 = 0x0348031C
+
+//Read calibration
+setmem /32 0x021b0848 = 0x42363838
+setmem /32 0x021b4848 = 0x38383644
+
+//Write calibration
+setmem /32 0x021b0850 = 0x3E3A423C
+setmem /32 0x021b4850 = 0x48324846
+
+
+
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):
+setmem /32 0x021b081c = 0x33333333      // DDR_PHY_P0_MPREDQBY0DL3
+setmem /32 0x021b0820 = 0x33333333      // DDR_PHY_P0_MPREDQBY1DL3
+setmem /32 0x021b0824 = 0x33333333      // DDR_PHY_P0_MPREDQBY2DL3
+setmem /32 0x021b0828 = 0x33333333      // DDR_PHY_P0_MPREDQBY3DL3
+setmem /32 0x021b481c = 0x33333333      // DDR_PHY_P1_MPREDQBY0DL3
+setmem /32 0x021b4820 = 0x33333333      // DDR_PHY_P1_MPREDQBY1DL3
+setmem /32 0x021b4824 = 0x33333333      // DDR_PHY_P1_MPREDQBY2DL3
+setmem /32 0x021b4828 = 0x33333333      // DDR_PHY_P1_MPREDQBY3DL3
+
+
+//setmem /32	0x021b082c =	0xf3333333 	// wr bit delay, byte 0
+//setmem /32	0x021b0830 =	0xf3333333 	// wr bit delay, byte 1
+//setmem /32	0x021b0834 =	0xf3333333 	// wr bit delay, byte 2
+//setmem /32	0x021b0838 =	0xf3333333 	// wr bit delay, byte 3
+//setmem /32	0x021b482c =	0xf3333333 	// wr bit delay, byte 4
+//setmem /32	0x021b4830 =	0xf3333333 	// wr bit delay, byte 5
+//setmem /32	0x021b4834 =	0xf3333333 	// wr bit delay, byte 6
+//setmem /32	0x021b4838 =	0xf3333333 	// wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+setmem /32 0x021b08b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+setmem /32 0x021b48b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, 64-bit mode, only MMDC0 is initiated:
+setmem /32 0x021b0004 = 0x00020036		// MMDC0_MDPDC see spread sheet for timings
+setmem /32 0x021b0008 = 0x09444040		// MMDC0_MDOTC see spread sheet for timings
+setmem /32 0x021b000c = 0x8A8F79A4		// MMDC0_MDCFG0 see spread sheet for timings. CL=8
+setmem /32 0x021b0010 = 0xDB538E64		// MMDC0_MDCFG1 see spread sheet for timings
+setmem /32 0x021b0014 = 0x01ff00db      // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+setmem /32 0x021b0018 = 0x00081740      // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+setmem /32 0x021b001c = 0x00008000      // MMDC0_MDSCR
+
+setmem /32 0x021b002c = 0x000026d2      // MMDC0_MDRWD
+setmem /32 0x021b0030 = 0x008F1023      // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck                                //jimmy
+setmem /32 0x021b0040 = 0x00000047      // CS0_END - 0x4fffffff 
+
+
+
+setmem /32 0x021b0000 = 0x841a0000      // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M , but fit wide range of other DDR3 devices
+//MR2:
+setmem /32 0x021b001c = 0x04088032      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0408803a      // MMDC0_MDSCR
+
+
+//MR3:
+setmem /32 0x021b001c = 0x00008033      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0000803b      // MMDC0_MDSCR
+//MR1:
+setmem /32 0x021b001c = 0x00048031      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x00048039      // MMDC0_MDSCR
+//MR0:
+
+setmem /32 0x021b001c = 0x09308030      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x09308038      // MMDC0_MDSCR, 
+
+//DDR device ZQ calibration:
+setmem /32 0x021b001c = 0x04008040      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x04008048      // MMDC0_MDSCR
+//######################################################
+//final DDR setup, before operation start:
+
+setmem /32 0x021b0020 = 0x00005800      // MMDC0_MDREF, enable auto refresh, set refresh rate.
+
+//Following ODT setup (0x11117) represents(along with obove DDR device configs) : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007,which represents: i.mx_ODT disabled, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, and seen to run very well with Freescale RDKs. Still, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+setmem /32 0x021b0818 = 0x00011117      // DDR_PHY_P0_MPODTCTRL, ODT enable
+setmem /32 0x021b4818 = 0x00011117      // DDR_PHY_P1_MPODTCTRL
+
+setmem /32 0x021b0004 = 0x00025576		// MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+setmem /32 0x021b0404 = 0x00011006      //MMDC0_MAPSR ADOPT power down enabled
+
+setmem /32 0x021b001c = 0x00000000      // MMDC0_MDSCR
+

Property changes on: board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01_20151126.inc
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01_20150921.inc
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01_20150921.inc b/board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01_20150921.inc
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01_20150921.inc	(revision 1734)
@@ -0,0 +1,276 @@
+//*================================================================================================
+//* Copyright (C) 2011, Freescale Semiconductor, Inc. All Rights Reserved
+//* THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
+//* BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
+//* Freescale Semiconductor, Inc.
+//*================================================================================================
+
+
+// DDR init script, written in ARM RVDS syntax
+// Target the CPUDDR3 board
+// Timing optimized to 528MHz. 64-bit data bus 
+
+
+// Initialization script for i.MX6q CPU Board (DDR3)
+// Version 1.0 (07-06-11)
+// v 1.01 (June 16, 2011)
+// - based on Boaz's orignal script
+// - changed write leveling to 0x44
+// - updated DDR calibration (DQS gating, read/write) per latest gathered from stress test code
+//
+// v 1.02 (July 20, 2011)
+// - DDR_INPUT bit cleared for: DQM, RAS, CAS, SDCLK, RESET (All output only...)
+
+
+// v 1.03 (July 20, 2011)
+//   - ADOPT, DDRCTL power down timer activated by configuring MMDC0_MAPSR & MMDC0_MDPDC 
+
+//  v 1.04 (Oct 20, 2011)
+//  - More order in file
+//  - One-time HW ZQ calibration added.
+//  - power down timers enable moved to end of config
+// 
+//  v 1.05 (Mar 25, 2012)
+//  - IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET setup corrected to set DDR_SEL='11' (DDR3). This corrects ZQ calibration operation. 
+//    Improvment of DDR signals levels is expected.  
+//  - DQS drive strength reduced 6->7,device Rtt_nom 120->60, show better overclocking with new DDR_SEL 
+//  - tMRD value increased by 1 to match JEDEC
+
+//  v 1.06 (june 12, 2012)
+// - SDCLK duty cycle fine tunning changed from default to low.
+// - Previous step of setting DRAM_RESET/DDR_SEL='11' is reversed back to '00'
+//   , after finding the later to have a better DDR signals integrity. IO design are still investigating this.
+// -  i.mx ODT configs changed : 60 -> 120Ohm, to save power. See more in comment bellow.
+// - IOMUX configs: Remove redundant (input only...) pull setup from output signals: SDCKE, ODT
+
+//  v 1.07 
+// - Silicon version v1.2 (MX6Q/DxxxxxxxC) compatible. SDCLK duty cycle fine tute is back to default (2).
+// - MAARCR registers modified to reflect the best simulated ADOPT performence
+
+//================================================================================================
+
+
+
+wait = on
+
+//*================================================================================================
+// Disable WDOG
+//*================================================================================================
+//setmem /16 0x020bc000 = 0x30
+
+
+//*================================================================================================
+// Enable all clocks (they are disabled by ROM code)
+//*================================================================================================
+setmem /32 0x020c4068 = 0xffffffff
+setmem /32 0x020c406c = 0xffffffff
+setmem /32 0x020c4070 = 0xffffffff
+setmem /32 0x020c4074 = 0xffffffff
+setmem /32 0x020c4078 = 0xffffffff
+setmem /32 0x020c407c = 0xffffffff
+setmem /32 0x020c4080 = 0xffffffff
+setmem /32 0x020c4084 = 0xffffffff
+
+
+//*================================================================================================
+// Initialize 64-bit DDR3 
+//*================================================================================================
+
+//######################################################
+// IOMUX 
+//######################################################
+
+//DDR IO TYPE:
+setmem /32 0x020e0798 = 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+setmem /32 0x020e0758 = 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.
+
+//CLOCK:
+setmem /32 0x020e0588 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0
+setmem /32 0x020e0594 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0
+
+//ADDRESS:
+setmem /32 0x020e056c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0578 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e074c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+setmem /32 0x020e057c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+setmem /32 0x020e058c = 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+setmem /32 0x020e059c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+setmem /32 0x020e05a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+setmem /32 0x020e078c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+setmem /32 0x020e0750 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+setmem /32 0x020e05a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+setmem /32 0x020e05b0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+setmem /32 0x020e0524 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+setmem /32 0x020e051c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+setmem /32 0x020e0518 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+setmem /32 0x020e050c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+setmem /32 0x020e05b8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+setmem /32 0x020e05c0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+setmem /32 0x020e0774 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+setmem /32 0x020e0784 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+setmem /32 0x020e0788 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+setmem /32 0x020e0794 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+setmem /32 0x020e079c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+setmem /32 0x020e07a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+setmem /32 0x020e07a4 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+setmem /32 0x020e07a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+setmem /32 0x020e0748 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+setmem /32 0x020e05ac = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05b4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0528 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0520 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0514 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0510 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05bc = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05c4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+setmem /32 0x021b0800 = 0xa1390003      // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+setmem /32 0x021b080c = 0x001F001F
+setmem /32 0x021b0810 = 0x001F001F
+
+setmem /32 0x021b480c = 0x001F001F
+setmem /32 0x021b4810 = 0x001F001F
+
+//DQS gating, read delay, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+setmem /32 0x021b083c = 0x43580368
+setmem /32 0x021b0840 = 0x03440354
+setmem /32 0x021b483c = 0x43580364
+setmem /32 0x021b4840 = 0x0348031C
+
+//Read calibration
+setmem /32 0x021b0848 = 0x40363838
+setmem /32 0x021b4848 = 0x3A383244
+
+//Write calibration
+setmem /32 0x021b0850 = 0x3C3C4240
+setmem /32 0x021b4850 = 0x44364842
+
+
+
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):
+setmem /32 0x021b081c = 0x33333333      // DDR_PHY_P0_MPREDQBY0DL3
+setmem /32 0x021b0820 = 0x33333333      // DDR_PHY_P0_MPREDQBY1DL3
+setmem /32 0x021b0824 = 0x33333333      // DDR_PHY_P0_MPREDQBY2DL3
+setmem /32 0x021b0828 = 0x33333333      // DDR_PHY_P0_MPREDQBY3DL3
+setmem /32 0x021b481c = 0x33333333      // DDR_PHY_P1_MPREDQBY0DL3
+setmem /32 0x021b4820 = 0x33333333      // DDR_PHY_P1_MPREDQBY1DL3
+setmem /32 0x021b4824 = 0x33333333      // DDR_PHY_P1_MPREDQBY2DL3
+setmem /32 0x021b4828 = 0x33333333      // DDR_PHY_P1_MPREDQBY3DL3
+
+
+//setmem /32	0x021b082c =	0xf3333333 	// wr bit delay, byte 0
+//setmem /32	0x021b0830 =	0xf3333333 	// wr bit delay, byte 1
+//setmem /32	0x021b0834 =	0xf3333333 	// wr bit delay, byte 2
+//setmem /32	0x021b0838 =	0xf3333333 	// wr bit delay, byte 3
+//setmem /32	0x021b482c =	0xf3333333 	// wr bit delay, byte 4
+//setmem /32	0x021b4830 =	0xf3333333 	// wr bit delay, byte 5
+//setmem /32	0x021b4834 =	0xf3333333 	// wr bit delay, byte 6
+//setmem /32	0x021b4838 =	0xf3333333 	// wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+setmem /32 0x021b08b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+setmem /32 0x021b48b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, 64-bit mode, only MMDC0 is initiated:
+setmem /32 0x021b0004 = 0x00020036		// MMDC0_MDPDC see spread sheet for timings
+setmem /32 0x021b0008 = 0x09444040		// MMDC0_MDOTC see spread sheet for timings
+setmem /32 0x021b000c = 0x555A79A5		// MMDC0_MDCFG0 see spread sheet for timings. CL=8
+setmem /32 0x021b0010 = 0xDB538E64		// MMDC0_MDCFG1 see spread sheet for timings
+setmem /32 0x021b0014 = 0x01ff00db      // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+setmem /32 0x021b0018 = 0x00001740      // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+setmem /32 0x021b001c = 0x00008000      // MMDC0_MDSCR
+
+setmem /32 0x021b002c = 0x000026d2      // MMDC0_MDRWD
+setmem /32 0x021b0030 = 0x005a1023      // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck                                //jimmy
+setmem /32 0x021b0040 = 0x00000027      // CS0_END - 0x4fffffff 
+
+setmem /32 0x021b0400 = 0x11420000      //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+setmem /32 0x021b4400 = 0x11420000      
+
+
+setmem /32 0x021b0000 = 0x831a0000      // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M , but fit wide range of other DDR3 devices
+//MR2:
+setmem /32 0x021b001c = 0x04088032      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0408803a      // MMDC0_MDSCR
+
+
+//MR3:
+setmem /32 0x021b001c = 0x00008033      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0000803b      // MMDC0_MDSCR
+//MR1:
+setmem /32 0x021b001c = 0x00468031      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x00468039      // MMDC0_MDSCR
+//MR0:
+
+setmem /32 0x021b001c = 0x09408030      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x09408038      // MMDC0_MDSCR, 
+
+//DDR device ZQ calibration:
+setmem /32 0x021b001c = 0x04008040      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x04008048      // MMDC0_MDSCR
+//######################################################
+//final DDR setup, before operation start:
+
+setmem /32 0x021b0020 = 0x00005800      // MMDC0_MDREF, enable auto refresh, set refresh rate.
+
+//Following ODT setup (0x11117) represents(along with obove DDR device configs) : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007,which represents: i.mx_ODT disabled, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, and seen to run very well with Freescale RDKs. Still, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+setmem /32 0x021b0818 = 0x00011117      // DDR_PHY_P0_MPODTCTRL, ODT enable
+setmem /32 0x021b4818 = 0x00011117      // DDR_PHY_P1_MPODTCTRL
+
+setmem /32 0x021b0004 = 0x00025576		// MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+setmem /32 0x021b0404 = 0x00011006      //MMDC0_MAPSR ADOPT power down enabled
+
+setmem /32 0x021b001c = 0x00000000      // MMDC0_MDSCR
+

Property changes on: board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01_20150921.inc
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx6qubcds31_4x_mt41j128.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qubcds31_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6qubcds31_4x_mt41j128.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qubcds31_4x_mt41j128.cfg	(revision 1734)
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+//DDR IO TYPE:
+DATA 4, 0x020e0798, 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+DATA 4, 0x020e0758, 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.,
+
+//CLOCK:
+DATA 4, 0x020e0588, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0,
+DATA 4, 0x020e0594, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0,
+
+//ADDRESS:
+DATA 4, 0x020e056c, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0578, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e074c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+DATA 4, 0x020e057c, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+DATA 4, 0x020e058c, 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+DATA 4, 0x020e059c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4, 0x020e05a0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4, 0x020e078c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+DATA 4, 0x020e0750, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+DATA 4, 0x020e05a8, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+DATA 4, 0x020e05b0, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+DATA 4, 0x020e0524, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+DATA 4, 0x020e051c, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+DATA 4, 0x020e0518, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+DATA 4, 0x020e050c, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+DATA 4, 0x020e05b8, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+DATA 4, 0x020e05c0, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+DATA 4, 0x020e0774, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+DATA 4, 0x020e0784, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+DATA 4, 0x020e0788, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+DATA 4, 0x020e0794, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+DATA 4, 0x020e079c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+DATA 4, 0x020e07a0, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+DATA 4, 0x020e07a4, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+DATA 4, 0x020e07a8, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+DATA 4, 0x020e0748, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+DATA 4, 0x020e05ac, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05b4, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0528, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0520, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0514, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0510, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05bc, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05c4, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0,
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+DATA 4, 0x021b0800, 0xa1390003 // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+
+//DQS gating, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+DATA 4, 0x021b083c, 0x435C0368
+DATA 4, 0x021b0840, 0x03400354
+DATA 4, 0x021b483c, 0x4368036C
+DATA 4, 0x021b4840, 0x0360033C
+
+//Read calibration
+DATA 4, 0x021b0848, 0x3C383E40
+DATA 4, 0x021b4848, 0x3A3A323E
+
+//Write calibration
+DATA 4, 0x021b0850, 0x40404A44
+DATA 4, 0x021b4850, 0x4A364C44
+
+
+
+//read data bit delay: (3 is the reccommended default value
+DATA 4, 0x021b081c, 0x33333333 // DDR_PHY_P0_MPREDQBY0DL3
+DATA 4, 0x021b0820, 0x33333333 // DDR_PHY_P0_MPREDQBY1DL3
+DATA 4, 0x021b0824, 0x33333333 // DDR_PHY_P0_MPREDQBY2DL3
+DATA 4, 0x021b0828, 0x33333333 // DDR_PHY_P0_MPREDQBY3DL3
+DATA 4, 0x021b481c, 0x33333333 // DDR_PHY_P1_MPREDQBY0DL3
+DATA 4, 0x021b4820, 0x33333333 // DDR_PHY_P1_MPREDQBY1DL3
+DATA 4, 0x021b4824, 0x33333333 // DDR_PHY_P1_MPREDQBY2DL3
+DATA 4, 0x021b4828, 0x33333333 // DDR_PHY_P1_MPREDQBY3DL3
+
+
+DATA 4, 0x021b082c, 0xf3333333 // wr bit delay, byte 0
+DATA 4, 0x021b0830, 0xf3333333 // wr bit delay, byte 1
+DATA 4, 0x021b0834, 0xf3333333 // wr bit delay, byte 2
+DATA 4, 0x021b0838, 0xf3333333 // wr bit delay, byte 3
+DATA 4, 0x021b482c, 0xf3333333 // wr bit delay, byte 4
+DATA 4, 0x021b4830, 0xf3333333 // wr bit delay, byte 5
+DATA 4, 0x021b4834, 0xf3333333 // wr bit delay, byte 6
+DATA 4, 0x021b4838, 0xf3333333 // wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, uncomment the following lines. For version C (v1.2, keep commented,
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6"
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+DATA 4, 0x021b08b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4, 0x021b48b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, only MMDC0 is initiated:
+DATA 4, 0x021b0004, 0x00020036 // MMDC0_MDPDC see spread sheet for timings
+DATA 4, 0x021b0008, 0x09444040 // MMDC0_MDOTC see spread sheet for timings
+DATA 4, 0x021b000c, 0x555A79A5 // MMDC0_MDCFG0 see spread sheet for timings. CL=8
+DATA 4, 0x021b0010, 0xDB538E64 // MMDC0_MDCFG1 see spread sheet for timings
+DATA 4, 0x021b0014, 0x01ff00db // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+DATA 4, 0x021b0018, 0x00001740 // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+DATA 4, 0x021b001c, 0x00008000 // MMDC0_MDSCR
+
+DATA 4, 0x021b002c, 0x000026d2 // MMDC0_MDRWD
+DATA 4, 0x021b0030, 0x005a1023 // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck
+DATA 4, 0x021b0040, 0x00000027 // CS0_END - 0x4fffffff 
+
+//IPU error and should remove
+//DATA 4, 0x021b0400, 0x11420000 //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+//DATA 4, 0x021b4400, 0x11420000 ,
+
+
+DATA 4, 0x021b0000, 0x831a0000 // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M 
+//MR2:
+DATA 4, 0x021b001c, 0x04088032 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0408803a // MMDC0_MDSCR
+
+
+//MR3:
+DATA 4, 0x021b001c, 0x00008033 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0000803b // MMDC0_MDSCR
+//MR1:
+DATA 4, 0x021b001c, 0x00468031 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x00468039 // MMDC0_MDSCR
+//MR0:
+
+DATA 4, 0x021b001c, 0x09408030 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x09408038 // MMDC0_MDSCR
+
+//DDR device ZQ calibration:
+DATA 4, 0x021b001c, 0x04008040 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x04008048 // MMDC0_MDSCR
+//######################################################
+//final DDR setup
+
+DATA 4, 0x021b0020, 0x00005800 // MMDC0_MDREF, enable auto refresh, set refresh rate.,
+
+//Following ODT setup (0x11117 represents(along with obove DDR device configs : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+DATA 4, 0x021b0818, 0x00011117 // DDR_PHY_P0_MPODTCTRL, ODT enable
+DATA 4, 0x021b4818, 0x00011117 // DDR_PHY_P1_MPODTCTRL
+
+DATA 4, 0x021b0004, 0x00025576 // MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+DATA 4, 0x021b0404, 0x00011006 //MMDC0_MAPSR ADOPT power down enabled
+
+DATA 4, 0x021b001c, 0x00000000 // MMDC0_MDSCR
+
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01.cfg b/board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01.cfg	(revision 1734)
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
+ */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030//tim s DATA STROBE
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030//tim e
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030//tim s DATA
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030//tim e
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x433C0344//Read DQS Gating calibration
+DATA 4, 0x021b0840, 0x03300338
+DATA 4, 0x021b483c, 0x4348034C
+DATA 4, 0x021b4840, 0x03400310
+DATA 4, 0x021b0848, 0x40363A3C
+DATA 4, 0x021b4848, 0x3836323E
+DATA 4, 0x021b0850, 0x3E384044
+DATA 4, 0x021b4850, 0x443C4646//
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036//528MHz
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x8A8F79A4
+DATA 4, 0x021b0010, 0xDB538E64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00081740//e
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x008F1023
+DATA 4, 0x021b0040, 0x00000047
+DATA 4, 0x021b0000, 0x841A0000
+// Mode register writes			
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x0408803a
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x0000803b
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x00048039
+DATA 4, 0x021b001c, 0x09308030
+DATA 4, 0x021b001c, 0x09308038
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b001c, 0x04008048
+DATA 4, 0x021b0020, 0x00005800
+			
+// It is recommended for new board designs and for customer boards			
+// to program these registers to a value of "0x00011117" 			
+// The DRAM ODT remains enabled and it is required to leave the DRAM ODT enabled			
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300  //
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF  //
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif

Property changes on: board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01.cfg
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.cfg b/board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.cfg	(revision 1734)
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+//DDR IO TYPE:
+DATA 4, 0x020e0798, 0x000c0000, // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+DATA 4, 0x020e0758, 0x00000000, // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.
+
+//CLOCK:
+DATA 4, 0x020e0588, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0
+DATA 4, 0x020e0594, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0
+
+//ADDRESS:
+DATA 4, 0x020e056c, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e0578, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e074c, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+DATA 4, 0x020e057c, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+DATA 4, 0x020e058c, 0x00000000, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+DATA 4, 0x020e059c, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4, 0x020e05a0, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4, 0x020e078c, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+DATA 4, 0x020e0750, 0x00020000, // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+DATA 4, 0x020e05a8, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+DATA 4, 0x020e05b0, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+DATA 4, 0x020e0524, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+DATA 4, 0x020e051c, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+DATA 4, 0x020e0518, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+DATA 4, 0x020e050c, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+DATA 4, 0x020e05b8, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+DATA 4, 0x020e05c0, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+DATA 4, 0x020e0774, 0x00020000, // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+DATA 4, 0x020e0784, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+DATA 4, 0x020e0788, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+DATA 4, 0x020e0794, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+DATA 4, 0x020e079c, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+DATA 4, 0x020e07a0, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+DATA 4, 0x020e07a4, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+DATA 4, 0x020e07a8, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+DATA 4, 0x020e0748, 0x00000030, // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+DATA 4, 0x020e05ac, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e05b4, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e0528, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e0520, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e0514, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e0510, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e05bc, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0
+DATA 4, 0x020e05c4, 0x00000030, // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+DATA 4, 0x021b0800, 0xa1390003, // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+DATA 4, 0x021b080c, 0x001F001F,
+DATA 4, 0x021b0810, 0x001F001F,
+
+DATA 4, 0x021b480c, 0x001F001F,
+DATA 4, 0x021b4810, 0x001F001F,
+
+//DQS gating, read delay, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+DATA 4, 0x021b083c, 0x43580368,
+DATA 4, 0x021b0840, 0x03480350,
+DATA 4, 0x021b483c, 0x43640364,
+DATA 4, 0x021b4840, 0x035C0330,
+
+//Read calibration
+DATA 4, 0x021b0848, 0x443E3C40,
+DATA 4, 0x021b4848, 0x403E3A48,
+
+//Write calibration
+DATA 4, 0x021b0850, 0x3A3C443C,
+DATA 4, 0x021b4850, 0x48384C46,
+
+
+
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):
+DATA 4, 0x021b081c, 0x33333333, // DDR_PHY_P0_MPREDQBY0DL3
+DATA 4, 0x021b0820, 0x33333333, // DDR_PHY_P0_MPREDQBY1DL3
+DATA 4, 0x021b0824, 0x33333333, // DDR_PHY_P0_MPREDQBY2DL3
+DATA 4, 0x021b0828, 0x33333333, // DDR_PHY_P0_MPREDQBY3DL3
+DATA 4, 0x021b481c, 0x33333333, // DDR_PHY_P1_MPREDQBY0DL3
+DATA 4, 0x021b4820, 0x33333333, // DDR_PHY_P1_MPREDQBY1DL3
+DATA 4, 0x021b4824, 0x33333333, // DDR_PHY_P1_MPREDQBY2DL3
+DATA 4, 0x021b4828, 0x33333333, // DDR_PHY_P1_MPREDQBY3DL3
+
+
+//setmem /32	0x021b082c =	0xf3333333 	// wr bit delay, byte 0
+//setmem /32	0x021b0830 =	0xf3333333 	// wr bit delay, byte 1
+//setmem /32	0x021b0834 =	0xf3333333 	// wr bit delay, byte 2
+//setmem /32	0x021b0838 =	0xf3333333 	// wr bit delay, byte 3
+//setmem /32	0x021b482c =	0xf3333333 	// wr bit delay, byte 4
+//setmem /32	0x021b4830 =	0xf3333333 	// wr bit delay, byte 5
+//setmem /32	0x021b4834 =	0xf3333333 	// wr bit delay, byte 6
+//setmem /32	0x021b4838 =	0xf3333333 	// wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+DATA 4, 0x021b08b8, 0x00000800, // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4, 0x021b48b8, 0x00000800, // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, 64-bit mode, only MMDC0 is initiated:
+DATA 4, 0x021b0004, 0x00020036,	// MMDC0_MDPDC see spread sheet for timings
+DATA 4, 0x021b0008, 0x09444040,	// MMDC0_MDOTC see spread sheet for timings
+DATA 4, 0x021b000c, 0x555A79A5,	// MMDC0_MDCFG0 see spread sheet for timings. CL=8
+DATA 4, 0x021b0010, 0xDB538E64,	// MMDC0_MDCFG1 see spread sheet for timings
+DATA 4, 0x021b0014, 0x01ff00dd, // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+DATA 4, 0x021b0018, 0x00001740, // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+DATA 4, 0x021b001c, 0x00008000, // MMDC0_MDSCR
+
+DATA 4, 0x021b002c, 0x000026d2, // MMDC0_MDRWD
+DATA 4, 0x021b0030, 0x005a1023, // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck                          , //jimmy
+DATA 4, 0x021b0040, 0x00000027, // CS0_END - 0x4fffffff 
+
+//IPU error and should remove
+//DATA 4, 0x021b0400, 0x11420000, //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+//DATA 4, 0x021b4400, 0x11420000,  
+
+
+DATA 4, 0x021b0000, 0x831a0000, // MMDC0_MDCTL - row - 14bits; col, 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M , but fit wide range of other DDR3 devices
+//MR2:
+DATA 4, 0x021b001c, 0x04088032, // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0408803a, // MMDC0_MDSCR
+
+
+//MR3:
+DATA 4, 0x021b001c, 0x00008033, // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0000803b, // MMDC0_MDSCR
+//MR1:
+DATA 4, 0x021b001c, 0x00468031, // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x00468039, // MMDC0_MDSCR
+//MR0:
+
+DATA 4, 0x021b001c, 0x09408030, // MMDC0_MDSCR, 
+DATA 4, 0x021b001c, 0x09408038, // MMDC0_MDSCR, 
+
+//DDR device ZQ calibration:
+DATA 4, 0x021b001c, 0x04008040, // MMDC0_MDSCR, 
+DATA 4, 0x021b001c, 0x04008048, // MMDC0_MDSCR
+//######################################################
+//final DDR setup, before operation start:
+
+DATA 4, 0x021b0020, 0x00005800, // MMDC0_MDREF, enable auto refresh, set refresh rate.
+
+//Following ODT setup (0x11117) represents(along with obove DDR device configs) : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007,which represents: i.mx_ODT disabled, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, and seen to run very well with Freescale RDKs. Still, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+DATA 4, 0x021b0818, 0x00033337, // DDR_PHY_P0_MPODTCTRL, ODT enable
+DATA 4, 0x021b4818, 0x00033337, // DDR_PHY_P1_MPODTCTRL
+
+DATA 4, 0x021b0004, 0x00025576, // MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+DATA 4, 0x021b0404, 0x00011006, //MMDC0_MAPSR ADOPT power down enabled
+
+DATA 4, 0x021b001c, 0x00000000, // MMDC0_MDSCR
+
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6qrom3420_4x_mt41j128.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom3420_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6qrom3420_4x_mt41j128.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom3420_4x_mt41j128.cfg	(revision 1734)
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+//######################################################
+// IOMUX 
+//######################################################
+
+//DDR IO TYPE:
+DATA 4, 0x020e0798, 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+DATA 4, 0x020e0758, 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.,
+
+//CLOCK:
+DATA 4, 0x020e0588, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0,
+DATA 4, 0x020e0594, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0,
+
+//ADDRESS:
+DATA 4, 0x020e056c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0578, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e074c, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+DATA 4, 0x020e057c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+DATA 4, 0x020e058c, 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+DATA 4, 0x020e059c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4, 0x020e05a0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4, 0x020e078c, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+DATA 4, 0x020e0750, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+DATA 4, 0x020e05a8, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+DATA 4, 0x020e05b0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+DATA 4, 0x020e0524, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+DATA 4, 0x020e051c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+DATA 4, 0x020e0518, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+DATA 4, 0x020e050c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+DATA 4, 0x020e05b8, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+DATA 4, 0x020e05c0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+DATA 4, 0x020e0774, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+DATA 4, 0x020e0784, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+DATA 4, 0x020e0788, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+DATA 4, 0x020e0794, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+DATA 4, 0x020e079c, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+DATA 4, 0x020e07a0, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+DATA 4, 0x020e07a4, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+DATA 4, 0x020e07a8, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+DATA 4, 0x020e0748, 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+DATA 4, 0x020e05ac, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05b4, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0528, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0520, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0514, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0510, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05bc, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05c4, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0,
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+DATA 4, 0x021b0800, 0xa1390003 // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+
+//DQS gating, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+DATA 4, 0x021b083c, 0x4358035C
+DATA 4, 0x021b0840, 0x0353034C
+DATA 4, 0x021b483c, 0x43600360
+DATA 4, 0x021b4840, 0x03540334
+
+//Read calibration
+DATA 4, 0x021b0848, 0x403A3A3E
+DATA 4, 0x021b4848, 0x3A3C3440
+
+//Write calibration
+DATA 4, 0x021b0850, 0x40364440
+DATA 4, 0x021b4850, 0x42364640
+
+
+
+//read data bit delay: (3 is the reccommended default value
+DATA 4, 0x021b081c, 0x33333333 // DDR_PHY_P0_MPREDQBY0DL3
+DATA 4, 0x021b0820, 0x33333333 // DDR_PHY_P0_MPREDQBY1DL3
+DATA 4, 0x021b0824, 0x33333333 // DDR_PHY_P0_MPREDQBY2DL3
+DATA 4, 0x021b0828, 0x33333333 // DDR_PHY_P0_MPREDQBY3DL3
+DATA 4, 0x021b481c, 0x33333333 // DDR_PHY_P1_MPREDQBY0DL3
+DATA 4, 0x021b4820, 0x33333333 // DDR_PHY_P1_MPREDQBY1DL3
+DATA 4, 0x021b4824, 0x33333333 // DDR_PHY_P1_MPREDQBY2DL3
+DATA 4, 0x021b4828, 0x33333333 // DDR_PHY_P1_MPREDQBY3DL3
+
+
+//DATA 4, 0x021b082c, 0xf3333333 // wr bit delay, byte 0
+//DATA 4, 0x021b0830, 0xf3333333 // wr bit delay, byte 1
+//DATA 4, 0x021b0834, 0xf3333333 // wr bit delay, byte 2
+//DATA 4, 0x021b0838, 0xf3333333 // wr bit delay, byte 3
+//DATA 4, 0x021b482c, 0xf3333333 // wr bit delay, byte 4
+//DATA 4, 0x021b4830, 0xf3333333 // wr bit delay, byte 5
+//DATA 4, 0x021b4834, 0xf3333333 // wr bit delay, byte 6
+//DATA 4, 0x021b4838, 0xf3333333 // wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, uncomment the following lines. For version C (v1.2 keep commented,
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6"
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+DATA 4, 0x021b08b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4, 0x021b48b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, only MMDC0 is initiated:
+DATA 4, 0x021b0004, 0x00020036 // MMDC0_MDPDC see spread sheet for timings
+DATA 4, 0x021b0008, 0x09444040 // MMDC0_MDOTC see spread sheet for timings
+DATA 4, 0x021b000c, 0x555A79A5 // MMDC0_MDCFG0 see spread sheet for timings. CL=8
+DATA 4, 0x021b0010, 0xDB538E64 // MMDC0_MDCFG1 see spread sheet for timings
+DATA 4, 0x021b0014, 0x01ff00db // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+DATA 4, 0x021b0018, 0x00001740 // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+DATA 4, 0x021b001c, 0x00008000 // MMDC0_MDSCR
+
+DATA 4, 0x021b002c, 0x000026d2 // MMDC0_MDRWD
+DATA 4, 0x021b0030, 0x005a1023 // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck
+DATA 4, 0x021b0040, 0x00000027 // CS0_END - 0x4fffffff 
+
+//IPU error and should remove
+//DATA 4, 0x021b0400, 0x11420000 //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+//DATA 4, 0x021b4400, 0x11420000
+
+
+DATA 4, 0x021b0000, 0x831a0000 // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M 
+//MR2:
+DATA 4, 0x021b001c, 0x04088032 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0408803a // MMDC0_MDSCR
+
+
+//MR3:
+DATA 4, 0x021b001c, 0x00008033 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0000803b // MMDC0_MDSCR
+//MR1:
+DATA 4, 0x021b001c, 0x00468031 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x00468039 // MMDC0_MDSCR
+//MR0:
+
+DATA 4, 0x021b001c, 0x09408030 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x09408038 // MMDC0_MDSCR, 
+
+//DDR device ZQ calibration:
+DATA 4, 0x021b001c, 0x04008040 // MMDC0_MDSCR, 
+DATA 4, 0x021b001c, 0x04008048 // MMDC0_MDSCR
+//######################################################
+//final DDR setup
+
+DATA 4, 0x021b0020, 0x00005800 // MMDC0_MDREF, enable auto refresh, set refresh rate.,
+
+//Following ODT setup (0x11117) represents(along with obove DDR device configs) : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+DATA 4, 0x021b0818, 0x00033337 // DDR_PHY_P0_MPODTCTRL, ODT enable
+DATA 4, 0x021b4818, 0x00033337 // DDR_PHY_P1_MPODTCTRL
+
+DATA 4, 0x021b0004, 0x00025576 // MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+DATA 4, 0x021b0404, 0x00011006 //MMDC0_MAPSR ADOPT power down enabled
+
+DATA 4, 0x021b001c, 0x00000000 // MMDC0_MDSCR
+
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01.cfg b/board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01.cfg	(revision 1734)
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
+ */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030//tim s DATA STROBE
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030//tim e
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030//tim s DATA
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030//tim e
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x4344034C//Read DQS Gating calibration
+DATA 4, 0x021b0840, 0x033C033C
+DATA 4, 0x021b483c, 0x43500358
+DATA 4, 0x021b4840, 0x0348031C
+DATA 4, 0x021b0848, 0x42363838
+DATA 4, 0x021b4848, 0x38383644
+DATA 4, 0x021b0850, 0x3E3A423C
+DATA 4, 0x021b4850, 0x48324846//
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036//528MHz
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x8A8F79A4
+DATA 4, 0x021b0010, 0xDB538E64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00081740//e
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x008F1023
+DATA 4, 0x021b0040, 0x00000047
+DATA 4, 0x021b0000, 0x841A0000
+// Mode register writes			
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x0408803a
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x0000803b
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x00048039
+DATA 4, 0x021b001c, 0x09308030
+DATA 4, 0x021b001c, 0x09308038
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b001c, 0x04008048
+DATA 4, 0x021b0020, 0x00005800
+			
+// It is recommended for new board designs and for customer boards			
+// to program these registers to a value of "0x00011117" 			
+// The DRAM ODT remains enabled and it is required to leave the DRAM ODT enabled			
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300  //
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF  //
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif

Property changes on: board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01.cfg
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01.cfg b/board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01.cfg	(revision 1734)
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+//CLOCK:			
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+//ADDRESS:			
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+//CONTROL:			
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+//DATA STROBE:			
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+//DATA:			
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+			
+//=============================================================================			
+// DDR Controller Registers			
+//=============================================================================			
+// Manufacturer:	Micron		
+// Device Part Number:	MT41J128M16HA-15E		
+// Clock Freq.: 	533MHz		
+// Density per CS in Gb: 	8		
+// Chip Selects used:	1		
+// Number of Banks:	8		
+// Row address:    	14		
+// Column address: 	10		
+// Data bus width	64		
+//=============================================================================			
+DATA 4, 0x021b0800, 0xa1390003 // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+// write leveling, based on Freescale board layout and T topology			
+// For target board, may need to run write leveling calibration 			
+// to fine tune these settings			
+// If target board does not use T topology, then these registers			
+// should either be cleared or write leveling calibration can be run			
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+			
+//######################################################			
+//calibration values based on calibration compare of 0x00ffff00:			
+//Note, these calibration values are based on Freescale's board			
+//May need to run calibration on target board to fine tune these 			
+//######################################################			
+			
+//Read DQS Gating calibration			
+DATA 4, 0x021b083c, 0x43580368
+DATA 4, 0x021b0840, 0x03440354
+DATA 4, 0x021b483c, 0x43580364
+DATA 4, 0x021b4840, 0x0348031C
+			
+//Read calibration			
+DATA 4, 0x021b0848, 0x40363838
+DATA 4, 0x021b4848, 0x3A383244
+			
+//Write calibration			
+DATA 4, 0x021b0850, 0x3C3C4240
+DATA 4, 0x021b4850, 0x44364842
+			
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):			
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+			
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented			
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+			
+// Complete calibration by forced measurement:			
+DATA 4, 0x021b08b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4, 0x021b48b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+			
+//MMDC init:			
+DATA 4, 0x021b0004, 0x00020036 // MMDC0_MDPDC
+DATA 4, 0x021b0008, 0x09444040 // MMDC0_MDOTC
+DATA 4, 0x021b000c, 0x555A79A5 // MMDC0_MDCFG0
+DATA 4, 0x021b0010, 0xDB538E64 // MMDC0_MDCFG1
+DATA 4, 0x021b0014, 0x01FF00DB // MMDC0_MDCFG2
+DATA 4, 0x021b0018, 0x00001740 // MMDC0_MDMISC
+//NOTE about MDMISC RALAT:			
+//MDMISC: RALAT kept to the high level of 5 to ensure stable operation at 528MHz. 			
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 			
+//a. better operation at low frequency			
+//b. Small performence improvment			
+DATA 4, 0x021b001c, 0x00008000 // MMDC0_MDSCR, set the Configuration request bit during MMDC set up
+DATA 4, 0x021b002c, 0x000026d2 // MMDC0_MDRWD; recommend to maintain the default values
+DATA 4, 0x021b0030, 0x005A1023 // MMDC0_MDOR
+DATA 4, 0x021b0040, 0x00000027 // CS0_END
+		
+DATA 4, 0x021b0400, 0x11420000      //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+DATA 4, 0x021b4400, 0x11420000   
+	
+DATA 4, 0x021b0000, 0x831A0000 // MMDC0_MDCTL
+			
+// Mode register writes			
+DATA 4, 0x021b001c, 0x04088032 // MMDC0_MDSCR, MR2 write, CS0
+DATA 4, 0x021b001c, 0x0408803A // MMDC0_MDSCR, MR2 write, CS0
+DATA 4, 0x021b001c, 0x00008033 // MMDC0_MDSCR, MR3 write, CS0
+DATA 4, 0x021b001c, 0x0000803B // MMDC0_MDSCR, MR3 write, CS0
+DATA 4, 0x021b001c, 0x00468031 // MMDC0_MDSCR, MR1 write, CS0
+DATA 4, 0x021b001c, 0x00468039 // MMDC0_MDSCR, MR1 write, CS0
+DATA 4, 0x021b001c, 0x09408030 // MMDC0_MDSCR, MR0 write, CS0
+DATA 4, 0x021b001c, 0x09408038 // MMDC0_MDSCR, MR0 write, CS0
+DATA 4, 0x021b001c, 0x04008040 // MMDC0_MDSCR, ZQ calibration command sent to device on CS0
+DATA 4, 0x021b001c, 0x04008048 // MMDC0_MDSCR, ZQ calibration command sent to device on CS0
+			
+//setmem /32	0x021b001c =	0x0408803A	// MMDC0_MDSCR, MR2 write, CS1
+//setmem /32	0x021b001c =	0x0000803B	// MMDC0_MDSCR, MR3 write, CS1
+//setmem /32	0x021b001c =	0x00048039	// MMDC0_MDSCR, MR1 write, CS1
+//setmem /32	0x021b001c =	0x09408038	// MMDC0_MDSCR, MR0 write, CS1
+//setmem /32	0x021b001c =	0x04008048	// MMDC0_MDSCR, ZQ calibration command sent to device on CS1
+			
+			
+DATA 4, 0x021b0020, 0x00005800 // MMDC0_MDREF
+			
+// It is recommended for new board designs and for customer boards			
+// to program these registers to a value of "0x00011117" 			
+// The DRAM ODT remains enabled and it is required to leave the DRAM ODT enabled			
+DATA 4, 0x021b0818, 0x00011117 // DDR_PHY_P0_MPODTCTRL
+DATA 4, 0x021b4818, 0x00011117 // DDR_PHY_P1_MPODTCTRL
+			
+			
+DATA 4, 0x021b0004, 0x00025576 // MMDC0_MDPDC with PWDT bits set
+DATA 4, 0x021b0404, 0x00011006 // MMDC0_MAPSR ADOPT power down enabled, MMDC will enter automatically to self-refresh while the number of idle cycle reached.
+			
+DATA 4, 0x021b001c, 0x00000000 // MMDC0_MDSCR, clear this register (especially the configuration bit as initialization is complete)
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif

Property changes on: board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01.cfg
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: board/freescale/imx/ddr/mx6qrom5420_4x_mt41j128.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom5420_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6qrom5420_4x_mt41j128.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom5420_4x_mt41j128.cfg	(revision 1734)
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43270338
+DATA 4, 0x021b0840, 0x03200314
+DATA 4, 0x021b483c, 0x431A032F
+DATA 4, 0x021b4840, 0x03200263
+DATA 4, 0x021b0848, 0x4B434748
+DATA 4, 0x021b4848, 0x4445404C
+DATA 4, 0x021b0850, 0x38444542
+DATA 4, 0x021b4850, 0x4935493A
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x555A7975
+DATA 4, 0x021b0010, 0xFF538F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x005A1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x831A0000
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6qrom7420_4x_mt41j128.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qrom7420_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6qrom7420_4x_mt41j128.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qrom7420_4x_mt41j128.cfg	(revision 1734)
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0798, 0x000c0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43680370
+DATA 4, 0x021b0840, 0x035C0358
+DATA 4, 0x021b483c, 0x43700370
+DATA 4, 0x021b4840, 0x035C0330
+DATA 4, 0x021b0848, 0x4238383C
+DATA 4, 0x021b4848, 0x3C3A3440
+DATA 4, 0x021b0850, 0x3C3E4444
+DATA 4, 0x021b4850, 0x463E4C42
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x555A79A5
+DATA 4, 0x021b0010, 0xDB538E64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x005a1023
+DATA 4, 0x021b0040, 0x00000027
+//DATA 4, 0x021b0400, 0x11420000
+//DATA 4, 0x021b4400, 0x11420000
+DATA 4, 0x021b0000, 0x831a0000
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x0408803a
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x0000803b
+DATA 4, 0x021b001c, 0x00468031
+DATA 4, 0x021b001c, 0x00468039
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x09408038
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b001c, 0x04008048
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx6qwise3310_4x_mt41j128.cfg
===================================================================
diff --git a/board/freescale/imx/ddr/mx6qwise3310_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6qwise3310_4x_mt41j128.cfg
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx6qwise3310_4x_mt41j128.cfg	(revision 1734)
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+SECURE_BOOT
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+//DDR IO TYPE:
+DATA 4, 0x020e0798, 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+DATA 4, 0x020e0758, 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.,
+
+//CLOCK:
+DATA 4, 0x020e0588, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0,
+DATA 4, 0x020e0594, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0,
+
+//ADDRESS:
+DATA 4, 0x020e056c, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0578, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e074c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+DATA 4, 0x020e057c, 0x00000038 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+DATA 4, 0x020e058c, 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+DATA 4, 0x020e059c, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+DATA 4, 0x020e05a0, 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+DATA 4, 0x020e078c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+DATA 4, 0x020e0750, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+DATA 4, 0x020e05a8, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+DATA 4, 0x020e05b0, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+DATA 4, 0x020e0524, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+DATA 4, 0x020e051c, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+DATA 4, 0x020e0518, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+DATA 4, 0x020e050c, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+DATA 4, 0x020e05b8, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+DATA 4, 0x020e05c0, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+DATA 4, 0x020e0774, 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+DATA 4, 0x020e0784, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+DATA 4, 0x020e0788, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+DATA 4, 0x020e0794, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+DATA 4, 0x020e079c, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+DATA 4, 0x020e07a0, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+DATA 4, 0x020e07a4, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+DATA 4, 0x020e07a8, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+DATA 4, 0x020e0748, 0x00000038 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+DATA 4, 0x020e05ac, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05b4, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0528, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0520, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0514, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e0510, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05bc, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0,
+DATA 4, 0x020e05c4, 0x00000138 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0,
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+DATA 4, 0x021b0800, 0xa1390003 // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+
+//DQS gating, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+DATA 4, 0x021b083c, 0x435C0368
+DATA 4, 0x021b0840, 0x03400354
+DATA 4, 0x021b483c, 0x4368036C
+DATA 4, 0x021b4840, 0x0360033C
+
+//Read calibration
+DATA 4, 0x021b0848, 0x3C383E40
+DATA 4, 0x021b4848, 0x3A3A323E
+
+//Write calibration
+DATA 4, 0x021b0850, 0x40404A44
+DATA 4, 0x021b4850, 0x4A364C44
+
+
+
+//read data bit delay: (3 is the reccommended default value
+DATA 4, 0x021b081c, 0x33333333 // DDR_PHY_P0_MPREDQBY0DL3
+DATA 4, 0x021b0820, 0x33333333 // DDR_PHY_P0_MPREDQBY1DL3
+DATA 4, 0x021b0824, 0x33333333 // DDR_PHY_P0_MPREDQBY2DL3
+DATA 4, 0x021b0828, 0x33333333 // DDR_PHY_P0_MPREDQBY3DL3
+DATA 4, 0x021b481c, 0x33333333 // DDR_PHY_P1_MPREDQBY0DL3
+DATA 4, 0x021b4820, 0x33333333 // DDR_PHY_P1_MPREDQBY1DL3
+DATA 4, 0x021b4824, 0x33333333 // DDR_PHY_P1_MPREDQBY2DL3
+DATA 4, 0x021b4828, 0x33333333 // DDR_PHY_P1_MPREDQBY3DL3
+
+
+DATA 4, 0x021b082c, 0xf3333333 // wr bit delay, byte 0
+DATA 4, 0x021b0830, 0xf3333333 // wr bit delay, byte 1
+DATA 4, 0x021b0834, 0xf3333333 // wr bit delay, byte 2
+DATA 4, 0x021b0838, 0xf3333333 // wr bit delay, byte 3
+DATA 4, 0x021b482c, 0xf3333333 // wr bit delay, byte 4
+DATA 4, 0x021b4830, 0xf3333333 // wr bit delay, byte 5
+DATA 4, 0x021b4834, 0xf3333333 // wr bit delay, byte 6
+DATA 4, 0x021b4838, 0xf3333333 // wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, uncomment the following lines. For version C (v1.2, keep commented,
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6"
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+DATA 4, 0x021b08b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+DATA 4, 0x021b48b8, 0x00000800 // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, only MMDC0 is initiated:
+DATA 4, 0x021b0004, 0x00020036 // MMDC0_MDPDC see spread sheet for timings
+DATA 4, 0x021b0008, 0x09444040 // MMDC0_MDOTC see spread sheet for timings
+DATA 4, 0x021b000c, 0x555A79A5 // MMDC0_MDCFG0 see spread sheet for timings. CL=8
+DATA 4, 0x021b0010, 0xDB538E64 // MMDC0_MDCFG1 see spread sheet for timings
+DATA 4, 0x021b0014, 0x01ff00db // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+DATA 4, 0x021b0018, 0x00001740 // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+DATA 4, 0x021b001c, 0x00008000 // MMDC0_MDSCR
+
+DATA 4, 0x021b002c, 0x000026d2 // MMDC0_MDRWD
+DATA 4, 0x021b0030, 0x005a1023 // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck
+DATA 4, 0x021b0040, 0x00000027 // CS0_END - 0x4fffffff 
+
+//IPU error and should remove
+//DATA 4, 0x021b0400, 0x11420000 //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+//DATA 4, 0x021b4400, 0x11420000 ,
+
+
+DATA 4, 0x021b0000, 0x831a0000 // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M 
+//MR2:
+DATA 4, 0x021b001c, 0x04088032 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0408803a // MMDC0_MDSCR
+
+
+//MR3:
+DATA 4, 0x021b001c, 0x00008033 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x0000803b // MMDC0_MDSCR
+//MR1:
+DATA 4, 0x021b001c, 0x00468031 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x00468039 // MMDC0_MDSCR
+//MR0:
+
+DATA 4, 0x021b001c, 0x09408030 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x09408038 // MMDC0_MDSCR
+
+//DDR device ZQ calibration:
+DATA 4, 0x021b001c, 0x04008040 // MMDC0_MDSCR
+DATA 4, 0x021b001c, 0x04008048 // MMDC0_MDSCR
+//######################################################
+//final DDR setup
+
+DATA 4, 0x021b0020, 0x00005800 // MMDC0_MDREF, enable auto refresh, set refresh rate.,
+
+//Following ODT setup (0x11117 represents(along with obove DDR device configs : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+DATA 4, 0x021b0818, 0x00011117 // DDR_PHY_P0_MPODTCTRL, ODT enable
+DATA 4, 0x021b4818, 0x00011117 // DDR_PHY_P1_MPODTCTRL
+
+DATA 4, 0x021b0004, 0x00025576 // MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+DATA 4, 0x021b0404, 0x00011006 //MMDC0_MAPSR ADOPT power down enabled
+
+DATA 4, 0x021b001c, 0x00000000 // MMDC0_MDSCR
+
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
Index: board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.inc
===================================================================
diff --git a/board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.inc b/board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.inc
new file mode 10644
--- /dev/null	(revision 0)
+++ b/board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.inc	(revision 1734)
@@ -0,0 +1,276 @@
+//*================================================================================================
+//* Copyright (C) 2011, Freescale Semiconductor, Inc. All Rights Reserved
+//* THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
+//* BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
+//* Freescale Semiconductor, Inc.
+//*================================================================================================
+
+
+// DDR init script, written in ARM RVDS syntax
+// Target the CPUDDR3 board
+// Timing optimized to 528MHz. 64-bit data bus 
+
+
+// Initialization script for i.MX6q CPU Board (DDR3)
+// Version 1.0 (07-06-11)
+// v 1.01 (June 16, 2011)
+// - based on Boaz's orignal script
+// - changed write leveling to 0x44
+// - updated DDR calibration (DQS gating, read/write) per latest gathered from stress test code
+//
+// v 1.02 (July 20, 2011)
+// - DDR_INPUT bit cleared for: DQM, RAS, CAS, SDCLK, RESET (All output only...)
+
+
+// v 1.03 (July 20, 2011)
+//   - ADOPT, DDRCTL power down timer activated by configuring MMDC0_MAPSR & MMDC0_MDPDC 
+
+//  v 1.04 (Oct 20, 2011)
+//  - More order in file
+//  - One-time HW ZQ calibration added.
+//  - power down timers enable moved to end of config
+// 
+//  v 1.05 (Mar 25, 2012)
+//  - IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET setup corrected to set DDR_SEL='11' (DDR3). This corrects ZQ calibration operation. 
+//    Improvment of DDR signals levels is expected.  
+//  - DQS drive strength reduced 6->7,device Rtt_nom 120->60, show better overclocking with new DDR_SEL 
+//  - tMRD value increased by 1 to match JEDEC
+
+//  v 1.06 (june 12, 2012)
+// - SDCLK duty cycle fine tunning changed from default to low.
+// - Previous step of setting DRAM_RESET/DDR_SEL='11' is reversed back to '00'
+//   , after finding the later to have a better DDR signals integrity. IO design are still investigating this.
+// -  i.mx ODT configs changed : 60 -> 120Ohm, to save power. See more in comment bellow.
+// - IOMUX configs: Remove redundant (input only...) pull setup from output signals: SDCKE, ODT
+
+//  v 1.07 
+// - Silicon version v1.2 (MX6Q/DxxxxxxxC) compatible. SDCLK duty cycle fine tute is back to default (2).
+// - MAARCR registers modified to reflect the best simulated ADOPT performence
+
+//================================================================================================
+
+
+
+wait = on
+
+//*================================================================================================
+// Disable WDOG
+//*================================================================================================
+setmem /16 0x020bc000 = 0x30
+
+
+//*================================================================================================
+// Enable all clocks (they are disabled by ROM code)
+//*================================================================================================
+setmem /32 0x020c4068 = 0xffffffff
+setmem /32 0x020c406c = 0xffffffff
+setmem /32 0x020c4070 = 0xffffffff
+setmem /32 0x020c4074 = 0xffffffff
+setmem /32 0x020c4078 = 0xffffffff
+setmem /32 0x020c407c = 0xffffffff
+setmem /32 0x020c4080 = 0xffffffff
+setmem /32 0x020c4084 = 0xffffffff
+
+
+//*================================================================================================
+// Initialize 64-bit DDR3 
+//*================================================================================================
+
+//######################################################
+// IOMUX 
+//######################################################
+
+//DDR IO TYPE:
+setmem /32 0x020e0798 = 0x000c0000 // IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - DDR_SEL=11 
+setmem /32 0x020e0758 = 0x00000000 // IOMUXC_SW_PAD_CTL_GRP_DDRPKE - PKE=0 , Pull disabled for all, except DQS.
+
+//CLOCK:
+setmem /32 0x020e0588 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - DSE=101, DDR_INPUT=0, HYS=0
+setmem /32 0x020e0594 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 - DSE=101, DDR_INPUT=0, HYS=0
+
+//ADDRESS:
+setmem /32 0x020e056c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0578 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e074c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_ADDDS - DSE=110
+
+//CONTROL:
+setmem /32 0x020e057c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - DSE=110, DDR_INPUT=1, HYS=0, DDR_SEL=00
+
+setmem /32 0x020e058c = 0x00000000 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+setmem /32 0x020e059c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0
+setmem /32 0x020e05a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1
+setmem /32 0x020e078c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_CTLDS - DSE=110
+
+
+//DATA STROBE:
+setmem /32 0x020e0750 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - DDR_INPUT=1
+
+setmem /32 0x020e05a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - DSE=110
+setmem /32 0x020e05b0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - DSE=110
+setmem /32 0x020e0524 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - DSE=110
+setmem /32 0x020e051c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - DSE=110
+setmem /32 0x020e0518 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 - DSE=110
+setmem /32 0x020e050c = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 - DSE=110
+setmem /32 0x020e05b8 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 - DSE=110
+setmem /32 0x020e05c0 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 - DSE=110
+
+//DATA:
+setmem /32 0x020e0774 = 0x00020000 // IOMUXC_SW_PAD_CTL_GRP_DDRMODE- DDR_INPUT 1,diff
+
+setmem /32 0x020e0784 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B0DS - DSE=110
+setmem /32 0x020e0788 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B1DS - DSE=110
+setmem /32 0x020e0794 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B2DS - DSE=110
+setmem /32 0x020e079c = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B3DS - DSE=110
+setmem /32 0x020e07a0 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B4DS - DSE=110
+setmem /32 0x020e07a4 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B5DS - DSE=110
+setmem /32 0x020e07a8 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B6DS - DSE=110
+setmem /32 0x020e0748 = 0x00000030 // IOMUXC_SW_PAD_CTL_GRP_B7DS - DSE=110
+
+setmem /32 0x020e05ac = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05b4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0528 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0520 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0514 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e0510 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05bc = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 - DSE=110, DDR_INPUT=1, HYS=0
+setmem /32 0x020e05c4 = 0x00000030 // IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 - DSE=110, DDR_INPUT=1, HYS=0
+
+
+
+//######################################################
+//Calibrations:
+//######################################################
+// ZQ:
+setmem /32 0x021b0800 = 0xa1390003      // DDR_PHY_P0_MPZQHWCTRL, enable both one-time & periodic HW ZQ calibration.
+
+// write leveling
+setmem /32 0x021b080c = 0x001F001F
+setmem /32 0x021b0810 = 0x001F001F
+
+setmem /32 0x021b480c = 0x001F001F
+setmem /32 0x021b4810 = 0x001F001F
+
+//DQS gating, read delay, write delay calibration values based on calibration compare of 0x00ffff00:
+// It is highly recommended for the user to run calibration code on her/his specific board 
+//and replace following delay values accordingly: 
+
+
+
+//Read DQS Gating calibration
+setmem /32 0x021b083c = 0x43580368
+setmem /32 0x021b0840 = 0x03480350
+setmem /32 0x021b483c = 0x43640364
+setmem /32 0x021b4840 = 0x035C0330
+
+//Read calibration
+setmem /32 0x021b0848 = 0x443E3C40
+setmem /32 0x021b4848 = 0x403E3A48
+
+//Write calibration
+setmem /32 0x021b0850 = 0x3A3C443C
+setmem /32 0x021b4850 = 0x48384C46
+
+
+
+//read data bit delay: (3 is the reccommended default value, although out of reset value is 0):
+setmem /32 0x021b081c = 0x33333333      // DDR_PHY_P0_MPREDQBY0DL3
+setmem /32 0x021b0820 = 0x33333333      // DDR_PHY_P0_MPREDQBY1DL3
+setmem /32 0x021b0824 = 0x33333333      // DDR_PHY_P0_MPREDQBY2DL3
+setmem /32 0x021b0828 = 0x33333333      // DDR_PHY_P0_MPREDQBY3DL3
+setmem /32 0x021b481c = 0x33333333      // DDR_PHY_P1_MPREDQBY0DL3
+setmem /32 0x021b4820 = 0x33333333      // DDR_PHY_P1_MPREDQBY1DL3
+setmem /32 0x021b4824 = 0x33333333      // DDR_PHY_P1_MPREDQBY2DL3
+setmem /32 0x021b4828 = 0x33333333      // DDR_PHY_P1_MPREDQBY3DL3
+
+
+//setmem /32	0x021b082c =	0xf3333333 	// wr bit delay, byte 0
+//setmem /32	0x021b0830 =	0xf3333333 	// wr bit delay, byte 1
+//setmem /32	0x021b0834 =	0xf3333333 	// wr bit delay, byte 2
+//setmem /32	0x021b0838 =	0xf3333333 	// wr bit delay, byte 3
+//setmem /32	0x021b482c =	0xf3333333 	// wr bit delay, byte 4
+//setmem /32	0x021b4830 =	0xf3333333 	// wr bit delay, byte 5
+//setmem /32	0x021b4834 =	0xf3333333 	// wr bit delay, byte 6
+//setmem /32	0x021b4838 =	0xf3333333 	// wr bit delay, byte 7
+
+
+//For i.mx6qd parts of versions A & B (v1.0, v1.1), uncomment the following lines. For version C (v1.2), keep commented
+//setmem /32	0x021b08c0 =	0x24911492	// fine tune SDCLK duty cyc to low - seen to improve measured duty cycle of i.mx6
+//setmem /32	0x021b48c0 =	0x24911492	
+
+//######################################################
+// Complete calibration by forced measurment:
+//######################################################
+setmem /32 0x021b08b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+setmem /32 0x021b48b8 = 0x00000800      // DDR_PHY_P0_MPMUR0, frc_msr
+
+//######################################################
+//MMDC init:
+
+
+//528MHz
+//in DDR3, 64-bit mode, only MMDC0 is initiated:
+setmem /32 0x021b0004 = 0x00020036		// MMDC0_MDPDC see spread sheet for timings
+setmem /32 0x021b0008 = 0x09444040		// MMDC0_MDOTC see spread sheet for timings
+setmem /32 0x021b000c = 0x555A79A5		// MMDC0_MDCFG0 see spread sheet for timings. CL=8
+setmem /32 0x021b0010 = 0xDB538E64		// MMDC0_MDCFG1 see spread sheet for timings
+setmem /32 0x021b0014 = 0x01ff00dd      // MMDC0_MDCFG2 - tRRD - 4ck; tWTR - 4ck; tRTP - 4ck; tDLLK - 512ck
+setmem /32 0x021b0018 = 0x00001740      // MMDC0_MDMISC, RALAT=0x5
+//MDMISC: RALAT kept to the high level of 5. 
+//MDMISC: consider reducing RALAT if your 528MHz board design allow that. Lower RALAT benefits: 
+//a. better operation at low frequency
+//b. Small performence improvment
+
+setmem /32 0x021b001c = 0x00008000      // MMDC0_MDSCR
+
+setmem /32 0x021b002c = 0x000026d2      // MMDC0_MDRWD
+setmem /32 0x021b0030 = 0x005a1023      // MMDC0_MDOR - tXPR - 91ck; SDE_to_RST - 13ck; RST_to_CKE - 32ck                                //jimmy
+setmem /32 0x021b0040 = 0x00000027      // CS0_END - 0x4fffffff 
+
+setmem /32 0x021b0400 = 0x11420000      //MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
+setmem /32 0x021b4400 = 0x11420000      
+
+
+setmem /32 0x021b0000 = 0x831a0000      // MMDC0_MDCTL - row - 14bits; col = 10bits; burst length 8; 64-bit data bus
+
+
+
+//######################################################
+// Initialize 2GB DDR3 - Micron MT41J128M , but fit wide range of other DDR3 devices
+//MR2:
+setmem /32 0x021b001c = 0x04088032      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0408803a      // MMDC0_MDSCR
+
+
+//MR3:
+setmem /32 0x021b001c = 0x00008033      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x0000803b      // MMDC0_MDSCR
+//MR1:
+setmem /32 0x021b001c = 0x00468031      // MMDC0_MDSCR
+setmem /32 0x021b001c = 0x00468039      // MMDC0_MDSCR
+//MR0:
+
+setmem /32 0x021b001c = 0x09408030      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x09408038      // MMDC0_MDSCR, 
+
+//DDR device ZQ calibration:
+setmem /32 0x021b001c = 0x04008040      // MMDC0_MDSCR, 
+setmem /32 0x021b001c = 0x04008048      // MMDC0_MDSCR
+//######################################################
+//final DDR setup, before operation start:
+
+setmem /32 0x021b0020 = 0x00005800      // MMDC0_MDREF, enable auto refresh, set refresh rate.
+
+//Following ODT setup (0x11117) represents(along with obove DDR device configs) : i.mx_ODT=DDR_device_ODT=120OHm.
+//User might to also interested in trying the value of 0x00000007,which represents: i.mx_ODT disabled, DDR_device_ODT=120Ohm.
+//0x00000007 saves more power, and seen to run very well with Freescale RDKs. Still, running with no ODT has it's implications 
+// of signal integrity and should be carefully simulated during board design.
+
+setmem /32 0x021b0818 = 0x00033337      // DDR_PHY_P0_MPODTCTRL, ODT enable
+setmem /32 0x021b4818 = 0x00033337      // DDR_PHY_P1_MPODTCTRL
+
+setmem /32 0x021b0004 = 0x00025576		// MMDC0_MDPDC see spread sheet for timings, SDCTL power down enabled
+
+setmem /32 0x021b0404 = 0x00011006      //MMDC0_MAPSR ADOPT power down enabled
+
+setmem /32 0x021b001c = 0x00000000      // MMDC0_MDSCR
+
Index: common/spl/spl.c
===================================================================
diff --git a/common/spl/spl.c b/common/spl/spl.c
--- a/common/spl/spl.c	(revision 512)
+++ b/common/spl/spl.c	(revision 1734)
@@ -45,6 +45,13 @@
 u32 *boot_params_ptr = NULL;
 struct spl_image_info spl_image;
 
+#if defined(CONFIG_ADVANTECH)
+#define SPL_VERSION_STRING "Adv-Boot SPL " PLAIN_VERSION " (" U_BOOT_DATE " - " \
+                        U_BOOT_TIME ")\n"
+
+const char __weak version_string[] = SPL_VERSION_STRING;
+#endif
+
 /* Define board data structure */
 static bd_t bdata __attribute__ ((section(".data")));
 
@@ -159,7 +166,24 @@
 {
 	u32 boot_device;
 	debug(">>spl:board_init_r()\n");
+#if defined(CONFIG_ADVANTECH)
+	int dcd_crc = (*(int *)0x277FB01C);
+	int *dcd_ptr = 0x277FB02C;
+	int dcd_len = (*(int *)dcd_ptr);
 
+	if (dcd_crc != 0) {
+		dcd_len = be16_to_cpu((dcd_len >> 8) & 0x0000FFFF);
+		printf("DCD table crc: %08x\n", dcd_crc);
+
+		//Check if CRCs are equaled. If not, stop booting!
+		int crc = crc32(0, (void *)dcd_ptr, dcd_len);
+		if (dcd_crc != crc) {
+			printf("SPL: CRC of DCD table does not match! crc=%08x\n", crc);
+			hang();
+		}
+	}
+#endif
+
 #ifdef CONFIG_SYS_SPL_MALLOC_START
 	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,
 			CONFIG_SYS_SPL_MALLOC_SIZE);
@@ -177,48 +201,139 @@
 	spl_board_init();
 #endif
 
+#if defined(CONFIG_SPL_CMD_MODE)
+{
+	board_init();
+	serial_initialize();
+	mmc_initialize(gd->bd);
+	env_init();
+	set_default_env("\0");
+
+	setenv("autoload", "no");
+	setenv("ethaddr", "00:04:9F:01:30:E0");
+	setenv("ipaddr", "192.168.203.44");
+	setenv("serverip", "192.168.203.145");
+#define STR_EXPAND(tok) #tok
+#define STR(tok) STR_EXPAND(tok)
+	setenv("loadaddr", STR(CONFIG_SYS_TEXT_BASE));
+	eth_initialize(gd->bd);
+
+	for (;;) {
+		if ( !tstc() || getc() !=27 ) break;
+		if ( !tstc() || getc() !=91 ) break;
+		if ( !tstc() || getc() !=51 ) break;
+		if ( !tstc() || getc() !=126) break;
+		printf("DEL pressed\n");
+		while (tstc()) {}
+		for (;;) {
+			main_loop();
+		}
+	}
+}
+#endif /* CONFIG_SPL_CMD_MODE */
+
 	boot_device = spl_boot_device();
 	debug("boot device - %d\n", boot_device);
 	switch (boot_device) {
+#if defined(CONFIG_ADVANTECH)
+	case BOOT_DEVICE_AUTO:
+		printf("BOOT_DEVICE_AUTO\n");
+#ifdef CONFIG_SPL_MMC_SUPPORT
+		/* 1. SD card */
+		if (!spl_mmc_load_image(0)) {
+			printf("booting from SD\n");
+			*(int *)0x22200000 = 0x01;
+		} else
+#endif
+#ifdef CONFIG_SPL_SATA_SUPPORT
+		/* 2. SATA disk */
+		if (!spl_sata_load_image(0)) {
+			printf("booting from SATA\n");
+			*(int *)0x22200000 = 0x02;
+		} else
+#endif
+#ifdef CONFIG_SPL_MMC_SUPPORT
+		/* 3. eMMC flash */
+		if(!spl_mmc_load_image(1)) {
+			printf("booting from iNAND\n");
+			*(int *)0x22200000 = 0x03;
+		} else
+#endif
+		{
+			printf("SPL: No bootable device is found!\n");
+			hang();
+		}
+		break;
+#ifdef CONFIG_SPL_SATA_SUPPORT
+	case BOOT_DEVICE_SATA:
+		printf("BOOT_DEVICE_SATA\n");
+		spl_sata_load_image(0);
+		break;
+#endif
+#endif /* CONFIG_ADVANTECH */
 #ifdef CONFIG_SPL_RAM_DEVICE
 	case BOOT_DEVICE_RAM:
+		printf("BOOT_DEVICE_RAM\n");
 		spl_ram_load_image();
 		break;
 #endif
 #ifdef CONFIG_SPL_MMC_SUPPORT
+#if defined(CONFIG_ADVANTECH)
 	case BOOT_DEVICE_MMC1:
+		printf("BOOT_DEVICE_MMC1\n");
+		spl_mmc_load_image(0);
+		break;
 	case BOOT_DEVICE_MMC2:
+		printf("BOOT_DEVICE_MMC2\n");
+		spl_mmc_load_image(1);
+		break;
 	case BOOT_DEVICE_MMC2_2:
+		printf("BOOT_DEVICE_MMC2_2\n");
+		/* Do nothing */
+		break;
+#else
+	case BOOT_DEVICE_MMC1:
+	case BOOT_DEVICE_MMC2:
+	case BOOT_DEVICE_MMC2_2:
+		printf("BOOT_DEVICE_MMC\n");
 		spl_mmc_load_image();
 		break;
 #endif
+#endif
 #ifdef CONFIG_SPL_NAND_SUPPORT
 	case BOOT_DEVICE_NAND:
+		printf("BOOT_DEVICE_NAND\n");
 		spl_nand_load_image();
 		break;
 #endif
 #ifdef CONFIG_SPL_ONENAND_SUPPORT
 	case BOOT_DEVICE_ONENAND:
+		printf("BOOT_DEVICE_ONENAND\n");
 		spl_onenand_load_image();
 		break;
 #endif
 #ifdef CONFIG_SPL_NOR_SUPPORT
 	case BOOT_DEVICE_NOR:
+		printf("BOOT_DEVICE_NOR\n");
 		spl_nor_load_image();
 		break;
 #endif
 #ifdef CONFIG_SPL_YMODEM_SUPPORT
 	case BOOT_DEVICE_UART:
+		printf("BOOT_DEVICE_UART\n");
 		spl_ymodem_load_image();
 		break;
 #endif
 #ifdef CONFIG_SPL_SPI_SUPPORT
 	case BOOT_DEVICE_SPI:
+		printf("BOOT_DEVICE_SPI\n");
 		spl_spi_load_image();
 		break;
 #endif
+/*
 #ifdef CONFIG_SPL_ETH_SUPPORT
 	case BOOT_DEVICE_CPGMAC:
+		printf("BOOT_DEVICE_CPGMAC\n");
 #ifdef CONFIG_SPL_ETH_DEVICE
 		spl_net_load_image(CONFIG_SPL_ETH_DEVICE);
 #else
@@ -226,28 +341,30 @@
 #endif
 		break;
 #endif
+*/
 #ifdef CONFIG_SPL_USBETH_SUPPORT
 	case BOOT_DEVICE_USBETH:
+		printf("BOOT_DEVICE_USBETH\n");
 		spl_net_load_image("usb_ether");
 		break;
 #endif
 	default:
-		debug("SPL: Un-supported Boot Device\n");
+		printf("SPL: Un-supported Boot Device\n");
 		hang();
 	}
 
 	switch (spl_image.os) {
 	case IH_OS_U_BOOT:
-		debug("Jumping to U-Boot\n");
+		printf("Jumping to U-Boot\n");
 		break;
 #ifdef CONFIG_SPL_OS_BOOT
 	case IH_OS_LINUX:
-		debug("Jumping to Linux\n");
+		printf("Jumping to Linux\n");
 		spl_board_prepare_for_linux();
 		jump_to_image_linux((void *)CONFIG_SYS_SPL_ARGS_ADDR);
 #endif
 	default:
-		debug("Unsupported OS image.. Jumping nevertheless..\n");
+		printf("Unsupported OS image.. Jumping nevertheless..\n");
 	}
 	jump_to_image_no_args(&spl_image);
 }
@@ -265,8 +382,12 @@
 
 	gd->have_console = 1;
 
+#if defined(CONFIG_ADVANTECH)
+	puts("\n\n" SPL_VERSION_STRING);
+#else
 	puts("\nU-Boot SPL " PLAIN_VERSION " (" U_BOOT_DATE " - " \
 			U_BOOT_TIME ")\n");
+#endif
 #ifdef CONFIG_SPL_DISPLAY_PRINT
 	spl_display_print();
 #endif
Index: common/env_common.c
===================================================================
diff --git a/common/env_common.c b/common/env_common.c
--- a/common/env_common.c	(revision 512)
+++ b/common/env_common.c	(revision 1734)
@@ -113,6 +113,7 @@
 	return ret_val;
 }
 
+#if !defined(CONFIG_SPL_BUILD)
 void set_default_env(const char *s)
 {
 	int flags = 0;
@@ -142,8 +143,23 @@
 
 	gd->flags |= GD_FLG_ENV_READY;
 }
+#elif defined(CONFIG_SPL_CMD_MODE)
+void set_default_env(const char *s)
+{
+	int flags = 0;
 
+	memset(gd->env_addr, 0, sizeof(default_environment));
 
+	if (himport_r(&env_htab, (char *)default_environment,
+			sizeof(default_environment), '\0', flags,
+			0, NULL) == 0)
+		error("Environment import failed: errno = %d\n", errno);
+
+	gd->flags |= GD_FLG_ENV_READY;
+}
+#endif
+
+
 /* [re]set individual variables to their value in the default environment */
 int set_default_vars(int nvars, char * const vars[])
 {
@@ -209,7 +225,7 @@
 	}
 }
 
-#if defined(CONFIG_AUTO_COMPLETE) && !defined(CONFIG_SPL_BUILD)
+#if defined(CONFIG_AUTO_COMPLETE) && ( !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE))
 int env_complete(char *var, int maxv, char *cmdv[], int bufsz, char *buf)
 {
 	ENTRY *match;
@@ -240,3 +256,4 @@
 	return found;
 }
 #endif
+
Index: common/main.c
===================================================================
diff --git a/common/main.c b/common/main.c
--- a/common/main.c	(revision 512)
+++ b/common/main.c	(revision 1734)
@@ -63,7 +63,9 @@
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
 void inline __show_boot_progress (int val) {}
+#ifndef CONFIG_SPL_BUILD
 void show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
+#endif
 
 #if defined(CONFIG_UPDATE_TFTP)
 int update_tftp (ulong addr);
@@ -437,6 +439,7 @@
 	update_tftp (0UL);
 #endif /* CONFIG_UPDATE_TFTP */
 
+#ifndef CONFIG_SPL_BUILD
 #if defined(CONFIG_BOOTDELAY)
 	s = getenv ("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
@@ -521,6 +524,7 @@
 	}
 #endif /* CONFIG_MENUKEY */
 #endif /* CONFIG_BOOTDELAY */
+#endif /* CONFIG_SPL_BUILD */
 
 	/*
 	 * Main Loop for Monitor Command Processing
Index: common/cmd_nvedit.c
===================================================================
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
--- a/common/cmd_nvedit.c	(revision 512)
+++ b/common/cmd_nvedit.c	(revision 1734)
@@ -88,7 +88,7 @@
 	return env_id;
 }
 
-#ifndef CONFIG_SPL_BUILD
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE)
 /*
  * Command interface: print one or all environment variables
  *
@@ -192,7 +192,7 @@
 	return rcode;
 }
 #endif
-#endif /* CONFIG_SPL_BUILD */
+#endif /* !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE) */
 
 /*
  * Set a new environment variable,
@@ -316,7 +316,7 @@
 	return setenv(varname, str);
 }
 
-#ifndef CONFIG_SPL_BUILD
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE)
 static int do_env_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	if (argc < 2)
@@ -574,8 +574,9 @@
 	return setenv(argv[1], buffer);
 }
 #endif /* CONFIG_CMD_EDITENV */
-#endif /* CONFIG_SPL_BUILD */
+#endif /* !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE) */
 
+
 /*
  * Look up variable from environment,
  * return address of storage for that variable,
@@ -1149,15 +1150,6 @@
 );
 #endif
 
-U_BOOT_CMD_COMPLETE(
-	printenv, CONFIG_SYS_MAXARGS, 1,	do_env_print,
-	"print environment variables",
-	"[-a]\n    - print [all] values of all environment variables\n"
-	"printenv name ...\n"
-	"    - print value of environment variable 'name'",
-	var_complete
-);
-
 #ifdef CONFIG_CMD_GREPENV
 U_BOOT_CMD_COMPLETE(
 	grepenv, CONFIG_SYS_MAXARGS, 0,  do_env_grep,
@@ -1168,16 +1160,6 @@
 );
 #endif
 
-U_BOOT_CMD_COMPLETE(
-	setenv, CONFIG_SYS_MAXARGS, 0,	do_env_set,
-	"set environment variables",
-	"[-f] name value ...\n"
-	"    - [forcibly] set environment variable 'name' to 'value ...'\n"
-	"setenv [-f] name\n"
-	"    - [forcibly] delete environment variable 'name'",
-	var_complete
-);
-
 #if defined(CONFIG_CMD_ASKENV)
 
 U_BOOT_CMD(
@@ -1198,3 +1180,25 @@
 );
 #endif
 #endif /* CONFIG_SPL_BUILD */
+
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE)
+U_BOOT_CMD_COMPLETE(
+	printenv, CONFIG_SYS_MAXARGS, 1,	do_env_print,
+	"print environment variables",
+	"[-a]\n    - print [all] values of all environment variables\n"
+	"printenv name ...\n"
+	"    - print value of environment variable 'name'",
+	var_complete
+);
+
+U_BOOT_CMD_COMPLETE(
+	setenv, CONFIG_SYS_MAXARGS, 0,	do_env_set,
+	"set environment variables",
+	"[-f] name value ...\n"
+	"    - [forcibly] set environment variable 'name' to 'value ...'\n"
+	"setenv [-f] name\n"
+	"    - [forcibly] delete environment variable 'name'",
+	var_complete
+);
+
+#endif /* !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE) */
Index: common/Makefile
===================================================================
diff --git a/common/Makefile b/common/Makefile
--- a/common/Makefile	(revision 512)
+++ b/common/Makefile	(revision 1734)
@@ -218,18 +218,33 @@
 endif
 
 ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_CMD_MODE
+COBJS-y += main.o
+COBJS-y += command.o
+COBJS-$(CONFIG_SYS_HUSH_PARSER) += hush.o
+
+COBJS-y += cmd_boot.o
+COBJS-y += cmd_help.o
+endif
 COBJS-y += cmd_nvedit.o
 COBJS-y += env_common.o
 COBJS-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
+COBJS-$(CONFIG_SPL_SATA_SUPPORT) += cmd_sata.o
 COBJS-$(CONFIG_SPL_YMODEM_SUPPORT) += xyzModem.o
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += cmd_nvedit.o
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += env_attr.o
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += env_callback.o
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += env_common.o
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += env_flags.o
+ifndef CONFIG_SPL_CMD_MODE
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += env_nowhere.o
+endif
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += miiphyutil.o
+ifdef CONFIG_SPL_CMD_MODE
+COBJS-$(CONFIG_SPL_NET_SUPPORT) += cmd_net.o
+COBJS-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
 endif
+endif
 COBJS-$(CONFIG_BOUNCE_BUFFER) += bouncebuf.o
 COBJS-y += console.o
 COBJS-y += dlmalloc.o
Index: common/hush.c
===================================================================
diff --git a/common/hush.c b/common/hush.c
--- a/common/hush.c	(revision 512)
+++ b/common/hush.c	(revision 1734)
@@ -1015,7 +1015,11 @@
 #endif
 	i->__promptme = 1;
 	if (i->promptmode == 1) {
+		#if !defined(CONFIG_SPL_BUILD)
 		n = readline(CONFIG_SYS_PROMPT);
+		#elif defined(CONFIG_SPL_CMD_MODE) 
+		n = readline(CONFIG_SPL_SYS_PROMPT);
+		#endif
 	} else {
 		n = readline(CONFIG_SYS_PROMPT_HUSH_PS2);
 	}
Index: common/cmd_net.c
===================================================================
diff --git a/common/cmd_net.c b/common/cmd_net.c
--- a/common/cmd_net.c	(revision 512)
+++ b/common/cmd_net.c	(revision 1734)
@@ -30,6 +30,7 @@
 
 static int netboot_common(enum proto_t, cmd_tbl_t *, int, char * const []);
 
+#if !defined(CONFIG_SPL_BUILD)
 static int do_bootp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	return netboot_common(BOOTP, cmdtp, argc, argv);
@@ -56,6 +57,7 @@
 	"boot image via network using TFTP protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]"
 );
+#endif
 
 #ifdef CONFIG_CMD_TFTPPUT
 int do_tftpput(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
@@ -264,7 +266,11 @@
 
 	bootstage_mark(BOOTSTAGE_ID_NET_LOADED);
 
+#if !defined(CONFIG_SPL_BUILD)
 	rcode = bootm_maybe_autostart(cmdtp, argv[0]);
+#else
+	rcode = 0;
+#endif
 
 	if (rcode < 0)
 		bootstage_error(BOOTSTAGE_ID_NET_DONE_ERR);
Index: common/command.c
===================================================================
diff --git a/common/command.c b/common/command.c
--- a/common/command.c	(revision 512)
+++ b/common/command.c	(revision 1734)
@@ -529,7 +529,7 @@
 	if (argc > cmdtp->maxargs)
 		rc = CMD_RET_USAGE;
 
-#if defined(CONFIG_CMD_BOOTD)
+#if defined(CONFIG_CMD_BOOTD) && !defined(CONFIG_SPL_BUILD)
 	/* avoid "bootd" recursion */
 	else if (cmdtp->cmd == do_bootd) {
 		if (flag & CMD_FLAG_BOOTD) {
Index: spl/Makefile
===================================================================
diff --git a/spl/Makefile b/spl/Makefile
--- a/spl/Makefile	(revision 512)
+++ b/spl/Makefile	(revision 1734)
@@ -18,6 +18,13 @@
 CONFIG_SPL_BUILD := y
 export CONFIG_SPL_BUILD
 
+ifneq ($(filter $(SPL_CMD_MODE), y Y 1) ,)
+CONFIG_SPL_CMD_MODE := y
+CONFIG_SPL_NET_SUPPORT := y
+CONFIG_SPL_ETH_SUPPORT := y
+export CONFIG_SPL_CMD_MODE CONFIG_SPL_NET_SUPPORT CONFIG_SPL_ETH_SUPPORT
+endif
+
 include $(TOPDIR)/config.mk
 
 # We want the final binaries in this directory
@@ -83,6 +90,8 @@
 LIBS-$(CONFIG_SPL_ETH_SUPPORT) += drivers/net/phy/libphy.o
 LIBS-$(CONFIG_SPL_MUSB_NEW_SUPPORT) += drivers/usb/musb-new/libusb_musb-new.o
 LIBS-$(CONFIG_SPL_USBETH_SUPPORT) += drivers/usb/gadget/libusb_gadget.o
+LIBS-$(CONFIG_SPL_SATA_SUPPORT) += drivers/block/libblock.o
+LIBS-$(CONFIG_SPL_CMD_MODE) += drivers/watchdog/imx_watchdog.o
 
 ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP34XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX)$(CONFIG_TI814X),)
 LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
@@ -94,7 +103,7 @@
 LIBS-y += $(CPUDIR)/tegra-common/libtegra-common.o
 endif
 
-ifneq ($(CONFIG_MX23),)
+ifneq ($(CONFIG_MX23)$(CONFIG_MX6),)
 LIBS-y += arch/$(ARCH)/imx-common/libimx-common.o
 endif
 
Index: tools/imximage.c
===================================================================
diff --git a/tools/imximage.c b/tools/imximage.c
--- a/tools/imximage.c	(revision 512)
+++ b/tools/imximage.c	(revision 1734)
@@ -264,6 +264,11 @@
 			fhdr_v2->csf = 0;
 			header_size_ptr = &hdr_v2->boot_data.size;
 		}
+#ifdef CONFIG_ADVANTECH
+		/* Use reserved2 field for CRC of DCD table */
+		fhdr_v2->reserved2 = crc32(0, (void *)&hdr_v2->data.dcd_table,
+					   be16_to_cpu(hdr_v2->data.dcd_table.header.length));
+#endif
 	} else {
 		imx_header_v2_t *next_hdr_v2;
 		flash_header_v2_t *next_fhdr_v2;
@@ -417,6 +422,9 @@
 		printf("U-Boot Load Address:  %08x\n", hdr_v2->boot_data.start);
 		printf("U-Boot Entry Point:   %08x\n",
 				(uint32_t)fhdr_v2->entry);
+#ifdef CONFIG_ADVANTECH
+		printf("U-Boot DCD Table CRC: %08x\n", (uint32_t)fhdr_v2->reserved2);
+#endif
 	} else {
 		imx_header_v2_t *next_hdr_v2;
 		flash_header_v2_t *next_fhdr_v2;
Index: tools/imximage.h
===================================================================
diff --git a/tools/imximage.h b/tools/imximage.h
--- a/tools/imximage.h	(revision 512)
+++ b/tools/imximage.h	(revision 1734)
@@ -61,6 +61,8 @@
 #define DCD_VERSION 0x40
 #define DCD_COMMAND_PARAM 0x4
 
+#define CONFIG_ADVANTECH
+
 enum imximage_cmd {
 	CMD_INVALID,
 	CMD_IMAGE_VERSION,
Index: tools/mk_uboot_crc.c
===================================================================
diff --git a/tools/mk_uboot_crc.c b/tools/mk_uboot_crc.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/tools/mk_uboot_crc.c	(revision 1734)
@@ -0,0 +1,48 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+
+#define IMG_SZ 614400
+
+int  main(void)
+{
+	struct stat buf;
+	char tmp[1024];
+	unsigned char binary[IMG_SZ];
+	int fd;
+	memset(binary, 0, IMG_SZ);
+	
+	if(stat("./u-boot.bin", &buf) != 0)
+		return -1;
+	//printf("File size %d\n", buf.st_size);
+	
+	fd = open("./u-boot.bin", O_RDWR);
+	if(fd < 0)
+	{
+		printf("Open u-boot.bin file fail %d\n", fd);
+		return -1;
+	}
+	read(fd, binary, buf.st_size);
+	close(fd);
+	
+	fd = open("./u-boot_crc.bin", O_RDWR | O_CREAT, S_IRWXU);
+	if(fd < 0)
+	{
+		printf("Open file fail %d\n", fd);
+		return -1;
+	}
+	write(fd, binary, IMG_SZ);
+
+	//printf("padding done\n");
+	return 0;
+} 
Index: tools/Makefile
===================================================================
diff --git a/tools/Makefile b/tools/Makefile
--- a/tools/Makefile	(revision 512)
+++ b/tools/Makefile	(revision 1734)
@@ -68,6 +68,7 @@
 BIN_FILES-$(CONFIG_XWAY_SWAP_BYTES) += xway-swap-bytes$(SFX)
 BIN_FILES-y += mkenvimage$(SFX)
 BIN_FILES-y += mkimage$(SFX)
+BIN_FILES-y += mk_uboot_crc$(SFX)
 BIN_FILES-$(CONFIG_SMDK5250) += mksmdk5250spl$(SFX)
 BIN_FILES-$(CONFIG_MX23) += mxsboot$(SFX)
 BIN_FILES-$(CONFIG_MX28) += mxsboot$(SFX)
@@ -223,6 +224,9 @@
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
 
+$(obj)mk_uboot_crc$(SFX):	mk_uboot_crc.c
+	$(HOSTCC) -o $@ $^
+
 $(obj)mk$(BOARD)spl$(SFX):	$(obj)mkexynosspl.o
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
Index: lib/Makefile
===================================================================
diff --git a/lib/Makefile b/lib/Makefile
--- a/lib/Makefile	(revision 512)
+++ b/lib/Makefile	(revision 1734)
@@ -66,6 +66,7 @@
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += errno.o
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += hashtable.o
 COBJS-$(CONFIG_SPL_NET_SUPPORT) += net_utils.o
+COBJS-$(CONFIG_SPL_CMD_MODE) += qsort.o
 endif
 COBJS-$(CONFIG_BCH) += bch.o
 COBJS-y += crc32.o
Index: lib/hashtable.c
===================================================================
diff --git a/lib/hashtable.c b/lib/hashtable.c
--- a/lib/hashtable.c	(revision 512)
+++ b/lib/hashtable.c	(revision 1734)
@@ -516,7 +516,7 @@
  * hexport()
  */
 
-#ifndef CONFIG_SPL_BUILD
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE)
 /*
  * Export the data stored in the hash table in linearized form.
  *
@@ -686,7 +686,7 @@
 
 	return size;
 }
-#endif
+#endif /* !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_CMD_MODE) */
 
 
 /*
Index: boards.cfg
===================================================================
diff --git a/boards.cfg b/boards.cfg
--- a/boards.cfg	(revision 512)
+++ b/boards.cfg	(revision 1734)
@@ -288,6 +288,16 @@
 mx6slevk                     arm         armv7       mx6slevk            freescale      mx6		mx6slevk:IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SYS_USE_SPINOR
 mx6slevk_spinor           arm         armv7       mx6slevk            freescale      mx6		mx6slevk:IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SYS_BOOT_SPINOR
 mx6slevkandroid          arm         armv7       mx6slevk            freescale      mx6		mx6slevk:IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SYS_USE_SPINOR,ANDROID_SUPPORT
+mx6qubcds31_1G               arm         armv7       mx6qadvantech       freescale      mx6		mx6qubcds31:IMX_CONFIG=board/freescale/imx/ddr/mx6qubcds31_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-ubcds31.dtb",DDR_MB=1024,SYS_USE_SPINOR
+mx6qrsb4410_1G               arm         armv7       mx6qadvantech       freescale      mx6		mx6qrsb4410:IMX_CONFIG=board/freescale/imx/ddr/mx4qrsb4410_4x_Samsung_K4B2G1646Q-BCK0_EGD789SC.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-rsb4410.dtb",DDR_MB=1024,SYS_USE_SPINOR
+mx6qrom7420_1G               arm         armv7       mx6qadvantech       freescale      mx6		mx6qrom7420:IMX_CONFIG=board/freescale/imx/ddr/mx6qrom7420_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-rom7420.dtb",DDR_MB=1024,SYS_USE_SPINOR
+mx6qrom5420_1G               arm         armv7       mx6qadvantech       freescale      mx6		mx6qrom5420:IMX_CONFIG=board/freescale/imx/ddr/mx6qrom5420_4x_MT41K128M16JT-125_1410022609-01.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-rom5420.dtb",DDR_MB=1024,SYS_USE_SPINOR
+mx6qrom5420_2G               arm         armv7       mx6qadvantech       freescale      mx6		mx6qrom5420:IMX_CONFIG=board/freescale/imx/ddr/mx6qrom5420_4x_IM4G16D3FABG-125_1410025137-01.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-rom5420.dtb",DDR_MB=2048,SYS_USE_SPINOR
+mx6qrom3420_1G               arm         armv7       mx6qadvantech       freescale      mx6		mx6qrom3420:IMX_CONFIG=board/freescale/imx/ddr/mx6qrom3420_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-rom3420.dtb",DDR_MB=1024,SYS_USE_SPINOR
+mx6qrom3420_2G               arm         armv7       mx6qadvantech       freescale      mx6		mx6qrom3420:IMX_CONFIG=board/freescale/imx/ddr/mx6qrom3420_4x_IM4G16D3FABG-125_1410025137-01.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-rom3420.dtb",DDR_MB=2048,SYS_USE_SPINOR
+mx6dlubc220_1G               arm         armv7       mx6qadvantech       freescale     mx6		mx6dlubc220:IMX_CONFIG=board/freescale/imx/ddr/mx6dlubc220_4x_K4B2G1646Q-BCK0_1410024420-01.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-ubc220.dtb",DDR_MB=1024,SYS_USE_SPINOR
+mx6qubc220_1G                arm         armv7       mx6qadvantech       freescale      mx6		mx6qubc220:IMX_CONFIG=board/freescale/imx/ddr/mx6qubc220_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-ubc220.dtb",DDR_MB=1024,SYS_USE_SPINOR
+mx6qwise3310_1G              arm         armv7       mx6qadvantech       freescale      mx6		mx6qwise3310:IMX_CONFIG=board/freescale/imx/ddr/mx6qwise3310_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-wise3310.dtb",DDR_MB=1024,SYS_USE_SPINOR
 eco5pk                       arm         armv7       eco5pk              8dtech         omap3
 nitrogen6dl                  arm         armv7       nitrogen6x          boundary       mx6		nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL,DDR_MB=1024
 nitrogen6dl2g                arm         armv7       nitrogen6x          boundary       mx6		nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl2g.cfg,MX6DL,DDR_MB=2048
Index: config.mk
===================================================================
diff --git a/config.mk b/config.mk
--- a/config.mk	(revision 512)
+++ b/config.mk	(revision 1734)
@@ -226,6 +226,10 @@
 CPPFLAGS += -DCONFIG_SPL_BUILD
 endif
 
+ifeq ($(CONFIG_SPL_CMD_MODE),y)
+CPPFLAGS += -DCONFIG_SPL_CMD_MODE
+endif
+
 # Does this architecture support generic board init?
 ifeq ($(__HAVE_ARCH_GENERIC_BOARD),)
 ifneq ($(CONFIG_SYS_GENERIC_BOARD),)
Index: arch/arm/include/asm/spl.h
===================================================================
diff --git a/arch/arm/include/asm/spl.h b/arch/arm/include/asm/spl.h
--- a/arch/arm/include/asm/spl.h	(revision 512)
+++ b/arch/arm/include/asm/spl.h	(revision 1734)
@@ -23,8 +23,26 @@
 #ifndef	_ASM_SPL_H_
 #define	_ASM_SPL_H_
 
+#if defined(CONFIG_ADVANTECH)
+enum {
+	BOOT_DEVICE_RAM,
+	BOOT_DEVICE_MMC1,
+	BOOT_DEVICE_MMC2,
+	BOOT_DEVICE_MMC2_2,
+	BOOT_DEVICE_NAND,
+	BOOT_DEVICE_ONENAND,
+	BOOT_DEVICE_NOR,
+	BOOT_DEVICE_UART,
+	BOOT_DEVICE_SPI,
+	BOOT_DEVICE_SATA,
+	BOOT_DEVICE_I2C,
+	BOOT_DEVICE_AUTO,
+	BOOT_DEVICE_NONE
+};
+#else
 /* Platform-specific defines */
 #include <asm/arch/spl.h>
+#endif
 
 /* Linker symbols. */
 extern char __bss_start[], __bss_end[];
Index: arch/arm/include/asm/arch-mx6/imx-regs.h
===================================================================
diff --git a/arch/arm/include/asm/arch-mx6/imx-regs.h b/arch/arm/include/asm/arch-mx6/imx-regs.h
--- a/arch/arm/include/asm/arch-mx6/imx-regs.h	(revision 512)
+++ b/arch/arm/include/asm/arch-mx6/imx-regs.h	(revision 1734)
@@ -420,7 +420,7 @@
 #define MXC_CSPICTRL_TC		(1 << 7)
 #define MXC_CSPICTRL_RXOVF	(1 << 6)
 #define MXC_CSPIPERIOD_32KHZ	(1 << 15)
-#define MAX_SPI_BYTES	32
+#define MAX_SPI_BYTES	(64 * 4)
 
 /* Bit position inside CTRL register to be associated with SS */
 #define MXC_CSPICTRL_CHAN	18
Index: arch/arm/lib/spl.c
===================================================================
diff --git a/arch/arm/lib/spl.c b/arch/arm/lib/spl.c
--- a/arch/arm/lib/spl.c	(revision 512)
+++ b/arch/arm/lib/spl.c	(revision 1734)
@@ -50,6 +50,17 @@
 	/* Set global data pointer. */
 	gd = &gdata;
 
+#if defined(CONFIG_ADVANTECH)
+	/* Set up UART, SPI nor, SATA & AXI cache */
+	board_early_init_f();
+
+#ifdef CONFIG_FSL_ESDHC
+	get_clocks();
+#endif
+	preloader_console_init();
+
+	dram_init();
+#endif
 	board_init_r(NULL, 0);
 }
 
Index: arch/arm/lib/board.c
===================================================================
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
--- a/arch/arm/lib/board.c	(revision 512)
+++ b/arch/arm/lib/board.c	(revision 1734)
@@ -63,6 +63,22 @@
 #include <fastboot.h>
 #endif
 
+#ifdef CONFIG_ADVANTECH
+#include <spi_flash.h>
+
+#define CONFIG_SPI_ENV_OFFSET	(768 * 1024)
+#define CONFIG_SPI_ENV_SIZE	(8 * 1024)
+
+struct boardcfg_t {
+    unsigned char mac[6];
+    unsigned char sn[10];
+    unsigned char Manufacturing_Time[14];
+};
+
+static struct spi_flash *flash;
+#endif /* CONFIG_ADVANTECH */
+
+
 DECLARE_GLOBAL_DATA_PTR;
 
 ulong monitor_flash_len;
@@ -279,6 +295,167 @@
 	NULL,
 };
 
+#ifdef CONFIG_ADVANTECH
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+int boardcfg_get_mac(void)
+{
+	int rc = 0;
+	struct boardcfg_t boardcfg;
+	char print_buf[32];
+	uint64_t macaddr = 0;
+
+	flash = spi_flash_probe(CONFIG_SF_DEFAULT_BUS, CONFIG_SF_DEFAULT_CS,
+				CONFIG_SF_DEFAULT_SPEED, CONFIG_SF_DEFAULT_MODE);
+	if (!flash)
+		return -1;
+
+	if(spi_flash_read(flash, CONFIG_SPI_ENV_OFFSET + 8*CONFIG_SPI_ENV_SIZE, sizeof(boardcfg), &boardcfg)==0) {
+
+		/*printf("offset=%d\n", CONFIG_SPI_ENV_OFFSET+ 8*CONFIG_SPI_ENV_SIZE);*/
+
+		/*printf("0x%02X:0x%02X:0x%02X:0x%02X:0x%02X:0x%02X\n",
+						boardcfg.mac[0],
+						boardcfg.mac[1],
+						boardcfg.mac[2],
+						boardcfg.mac[3],
+						boardcfg.mac[4],
+						boardcfg.mac[5]);*/
+
+
+		macaddr = ((uint64_t)boardcfg.mac[0] << 40)
+			+ ((uint64_t)boardcfg.mac[1] << 32)
+			+ ((uint64_t)boardcfg.mac[2] << 24)
+			+ ((uint64_t)boardcfg.mac[3] << 16)
+			+ ((uint64_t)boardcfg.mac[4] << 8)
+			+ boardcfg.mac[5];
+		/* printf ("MAC addr =%012llX\n", macaddr); */
+
+		if( (macaddr==0) || (macaddr==0xFFFFFFFFFFFFull) ) {
+			printf("MAC address is invailed !!\n");
+			sprintf(print_buf,"0x00:0x04:0x9F:0x01:0x30:0xE0");
+			printf("Use default MAC adderss:%s\n",print_buf);
+			setenv("ethaddr",print_buf);
+			rc = -1;
+		}
+	} else {
+		printf("SPI Read fail!!\n");
+		rc = -1;
+	}
+	
+	if (rc==0) {
+		sprintf(print_buf, "0x%02X:0x%02X:0x%02X:0x%02X:0x%02X:0x%02X", 
+						boardcfg.mac[0],
+						boardcfg.mac[1],
+						boardcfg.mac[2],
+						boardcfg.mac[3],
+						boardcfg.mac[4],
+						boardcfg.mac[5]);
+		printf ("MAC addr = %s\n", print_buf);
+
+		if( (strcmp (getenv("ethaddr"),print_buf) != 0)||(getenv("ethaddr") == NULL) 
+			|| (strcmp (getenv("ethaddr"),MK_STR(CONFIG_ETHADDR)) == 0) ) {
+			setenv("ethaddr", print_buf);
+		}
+	}
+	
+	return rc;
+}
+
+int check_emmc_exist(void)
+{
+        struct mmc *mmc = find_mmc_device(1);
+        int result=0;
+        if (mmc) {
+                result = mmc_init(mmc);
+                if(result != 0) {
+                        printf("*** emmc cannot init, emmc device doesn't exist\n");
+                        return 0;
+                }
+                return 1;
+        } else{
+                return 0;
+        }
+}
+
+void board_set_boot_device(void)
+{
+	char buf[256];
+	char advboot_version[128];
+	char uboot_version[128];
+	char *pch,*s;
+	 
+	int dev = (*(int *)0x22200000);
+	int emmc_exist = 0;
+	/* log uboot version */
+	strncpy(advboot_version, (void *)0x22300000, 128);
+
+	if (strstr(advboot_version,"advantech") == NULL)
+		strcpy(advboot_version, "");
+
+	pch=strchr(version_string,'2');
+	if (pch!=NULL)
+	{
+		s=strchr(pch,' ');
+		strncpy(uboot_version, pch, s-pch);
+		uboot_version[s-pch]='\0';
+	}
+
+	sprintf(buf, "advboot_version=%s uboot_version=%s", advboot_version, uboot_version);
+	setenv("bootargs", buf);
+
+	// check emmc exists or not
+	/* Remove this for workaround*/
+	emmc_exist = check_emmc_exist();
+
+	switch(dev)
+	{
+		case 1:
+		default:
+			/* booting from SD*/
+			printf("booting from SD\n");
+			setenv("mmcdev", "0");
+			if(emmc_exist) {
+				sprintf(buf, "/dev/mmcblk1p2 rootwait rw");
+				setenv("mmcroot",buf);
+			}
+			break;
+		case 2:
+			/* booting from SATA*/
+			printf("booting from SATA\n");
+			sprintf(buf, "fatload sata 0:1 ${loadaddr} ${uimage}");
+			setenv("loaduimage", buf);
+			sprintf(buf, "fatload sata 0:1 ${fdt_addr} ${fdt_file}");
+			setenv("loadfdt", buf);
+			sprintf(buf, "fatload sata 0:1 ${loadaddr} ${script}");
+			setenv("loadbootscript", buf);
+			sprintf(buf, "/dev/sda2 rootwait rw");
+			setenv("sataroot", buf);
+			sprintf(buf, "setenv bootargs console=${console},${baudrate} ${smp} root=${sataroot} ${bootargs}");
+			setenv("sataargs", buf);
+			sprintf(buf, "dcache off; sata init; run loaduimage; run loadbootscript; run sataargs; run loadfdt; bootm ${loadaddr} - ${fdt_addr}");
+			setenv("bootcmd", buf);
+			break;
+		case 3:
+			/* booting from iNAND*/
+			printf("booting from iNAND\n");
+			setenv("mmcdev", "1");
+			break;
+#ifdef CONFIG_SPI_BOOT
+		case 4:
+			/* booting from SPI*/
+			printf("booting from SPI -> kernel boot form EMMC\n");
+			if(emmc_exist) 	setenv("mmcdev", "1");
+			break;
+#endif
+	}
+
+	/*record ddr bit, 32 or 64 bit*/
+	sprintf(buf, "%d", *(unsigned int *)0x22500000);
+	setenv("ddr_bit", buf);
+}
+#endif /* CONFIG_ADVANTECH */
+
 void board_init_f(ulong bootflag)
 {
 	bd_t *bd;
@@ -527,7 +704,9 @@
 #if !defined(CONFIG_SYS_NO_FLASH)
 	ulong flash_size;
 #endif
-
+#ifdef CONFIG_BOOT_SELECT
+	int board_cs0, board_cs1, board_cs2=1;
+#endif
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
 	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");
 
@@ -652,11 +831,17 @@
 	misc_init_r();
 #endif
 
-	 /* set up exceptions */
+	/* set up exceptions */
 	interrupt_init();
 	/* enable exceptions */
 	enable_interrupts();
 
+#ifdef CONFIG_ADVANTECH
+	/* Get MAC address from SPI */
+	printf("boardcfg_get_mac\n");
+	boardcfg_get_mac();
+#endif
+
 	/* Initialize from environment */
 	load_addr = getenv_ulong("loadaddr", 16, load_addr);
 
@@ -711,6 +896,9 @@
 	check_fastboot();
 #endif
 
+#ifdef CONFIG_ADVANTECH
+	board_set_boot_device();
+#endif
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop();
Index: arch/arm/cpu/u-boot-spl.lds
===================================================================
diff --git a/arch/arm/cpu/u-boot-spl.lds b/arch/arm/cpu/u-boot-spl.lds
--- a/arch/arm/cpu/u-boot-spl.lds	(revision 512)
+++ b/arch/arm/cpu/u-boot-spl.lds	(revision 1734)
@@ -50,6 +50,15 @@
 
 	. = .;
 
+#if defined(CONFIG_SPL_CMD_MODE)
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	}
+
+	. = ALIGN(4);
+#endif
+
 	__image_copy_end = .;
 
 	.rel.dyn : {
Index: arch/arm/cpu/armv7/mx6/spl.c
===================================================================
diff --git a/arch/arm/cpu/armv7/mx6/spl.c b/arch/arm/cpu/armv7/mx6/spl.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/arch/arm/cpu/armv7/mx6/spl.c	(revision 1734)
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2014 Advantech Co. <risc-sw@advantech.com.tw>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <spl.h>
+#include <asm/gpio.h>
+
+extern const char version_string[];
+
+#ifdef CONFIG_BOOT_SELECT
+#define SABRESD_NANDF_CS0	IMX_GPIO_NR(6, 11) //GPIO6_11   
+#define SABRESD_NANDF_CS1	IMX_GPIO_NR(6, 14) //GPIO6_14 
+#define SABRESD_NANDF_CS2	IMX_GPIO_NR(6, 15) //GPIO6_15 
+#endif
+
+u32 mx6_boot_device = BOOT_DEVICE_NONE;
+
+#define msleep(a)	udelay(a * 1000)
+
+u32 spl_boot_mode(void)
+{
+    switch (mx6_boot_device) {
+    case BOOT_DEVICE_MMC1:
+    case BOOT_DEVICE_MMC2:
+    case BOOT_DEVICE_MMC2_2:
+    case BOOT_DEVICE_AUTO:
+#ifdef CONFIG_SPL_FAT_SUPPORT
+        return MMCSD_MODE_FAT;
+#else
+        return MMCSD_MODE_RAW;
+#endif
+    default:
+        puts("spl: ERROR:  unknown device - can't select boot mode\n");
+        hang();
+    }
+}
+
+u32 spl_boot_device(void)
+{
+#ifdef CONFIG_BOOT_SELECT
+	int board_cs0, board_cs1, board_cs2;
+
+#ifdef CONFIG_ROM3420
+	msleep(500);
+#endif
+
+	gpio_request(SABRESD_NANDF_CS0, "Board_CS0");
+	gpio_direction_input(SABRESD_NANDF_CS0);
+
+	gpio_request(SABRESD_NANDF_CS1, "Board_CS1");
+	gpio_direction_input(SABRESD_NANDF_CS1);	  
+
+	gpio_request(SABRESD_NANDF_CS2, "Board_CS2");
+	gpio_direction_input(SABRESD_NANDF_CS2); 
+
+	board_cs0 = gpio_get_value(SABRESD_NANDF_CS0);
+	board_cs1 = gpio_get_value(SABRESD_NANDF_CS1);
+	board_cs2 = gpio_get_value(SABRESD_NANDF_CS2);
+
+	printf("Boot_Switch: cs0=%d,cs1=%d,cs2=%d\n",board_cs0,board_cs1,board_cs2);
+	//--------------------------------------------------------------------
+
+	if((!board_cs2)&&(!board_cs1)&&(!board_cs0))		//Carrier SATA//
+	{
+		printf("booting from Carrier SATA\n");
+		*(int *)0x22200000 = 0x02;
+
+		mx6_boot_device = BOOT_DEVICE_SATA;
+	}
+	else if((!board_cs2)&&(!board_cs1)&&(board_cs0))	//Carrier SD Card//
+	{	
+		printf("booting from Carrier SD Card\n");
+		*(int *)0x22200000 = 0x01;
+
+		mx6_boot_device = BOOT_DEVICE_MMC1;
+	}
+	else if((!board_cs2)&&(board_cs1)&&(!board_cs0))	//Carrier eMMC Flash//
+	{
+		printf("booting from Carrier eMMC Flash\n");
+	}
+	else if((!board_cs2)&&(board_cs1)&&(board_cs0))		//Carrier SPI//
+	{
+		printf("booting from Carrier SPI\n");
+		*(int *)0x22200000 = 0x04;
+
+		mx6_boot_device = BOOT_DEVICE_SPI;
+	}
+	else if((board_cs2)&&(!board_cs1)&&(!board_cs0))	//Module device//
+	{
+		printf("booting from Module device\n");
+	}
+	else if((board_cs2)&&(!board_cs1)&&(board_cs0))		//Remote boot//
+	{
+		printf("booting from Remote boot\n");
+	}
+	else if((board_cs2)&&(board_cs1)&&(!board_cs0))		//Module eMMC Flash//
+	{
+		printf("booting from Module eMMC Flash\n");
+		*(int *)0x22200000 = 0x03;
+
+		mx6_boot_device = BOOT_DEVICE_MMC2;
+	}
+	else if((board_cs2)&&(board_cs1)&&(board_cs0))		//Module SPI//
+	{
+		printf("booting from Module SPI\n");
+	}
+	else
+	{
+		printf("booting not support\n");
+	}
+	//--------------------------------------------------------------------
+#else
+	/* We use BOOT_DEVICE_AUTO for auto boot device selection */
+	mx6_boot_device = BOOT_DEVICE_AUTO;
+#endif
+	return mx6_boot_device;
+}
+
+#ifdef CONFIG_SPL_BOARD_INIT
+void spl_board_init(void)
+{
+	char *pch,*s;
+	char tmp[256];
+
+	/* log adv version */
+	pch=strchr(version_string,'2');
+	if (pch!=NULL)
+	{
+		s=strchr(pch,' ');
+		strncpy(tmp, pch, s-pch);
+		tmp[s-pch]='\0';
+		strcpy((void *)0x22300000, tmp);
+	}
+
+	/* forword memory size to uboot */
+	*(unsigned int *)0x22400000 = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+
+	/* record ddr bit, 32 or 64 bit */
+#ifdef CONFIG_DDR_32BIT
+	*(unsigned int *)0x22500000 = 32;
+#else
+	*(unsigned int *)0x22500000 = 64;
+#endif
+}
+#endif
Index: arch/arm/cpu/armv7/mx6/soc.c
===================================================================
diff --git a/arch/arm/cpu/armv7/mx6/soc.c b/arch/arm/cpu/armv7/mx6/soc.c
--- a/arch/arm/cpu/armv7/mx6/soc.c	(revision 512)
+++ b/arch/arm/cpu/armv7/mx6/soc.c	(revision 1734)
@@ -56,8 +56,16 @@
 };
 
 #define TEMPERATURE_MIN		-40
+
+/* Need to pass power on/off test */
+#ifdef CONFIG_ADVANTECH
+#define TEMPERATURE_HOT         195
+#define TEMPERATURE_MAX         200
+#else
 #define TEMPERATURE_HOT		80
 #define TEMPERATURE_MAX		125
+#endif
+
 #define FACTOR1			15976
 #define FACTOR2			4297157
 #define MEASURE_FREQ		327
@@ -372,6 +380,26 @@
 
 int arch_cpu_init(void)
 {
+
+#ifdef CONFIG_ADVANTECH
+	#ifndef CONFIG_MX6SX
+	/* this bit is not used by imx6sx anymore */
+	u32 val;
+
+	/*
+	 * There are about 0.02% percentage, random pcie link down
+	 * when warm-reset is used.
+	 * clear the ref_ssp_en bit16 of gpr1 to workaround it.
+	 * then warm-reset imx6q/dl/solo again.
+	 */
+	val = readl(IOMUXC_BASE_ADDR + 0x4);
+	if (val & (0x1 << 16)) {
+		val &= ~(0x1 << 16);
+		writel(val, IOMUXC_BASE_ADDR + 0x4);
+		reset_cpu(0);
+	}
+	#endif
+#endif
 	/* Clear MMDC channel mask */
 	writel(0, CCM_BASE_ADDR + CLKCTL_CCDR);
 
@@ -379,9 +407,12 @@
 	set_vddsoc(1200);	/* Set VDDSOC to 1.2V */
 
 	imx_set_wdog_powerdown(false); /* Disable PDE bit of WMCR register */
-
+#ifndef CONFIG_MX6SX
 	imx_reset_pfd();
+#ifdef CONFIG_ADVANTECH
 	imx_set_pcie_phy_power_down();
+#endif
+#endif
 	imx_set_vddpu_power_down();
 
 #ifdef CONFIG_APBH_DMA
@@ -397,8 +428,10 @@
 {
 	/* Avoid random hang when download by usb */
 	invalidate_dcache_all();
+
 	/* Enable D-cache. I-cache is already enabled in start.S */
 	dcache_enable();
+
 }
 #endif
 
@@ -808,6 +841,42 @@
 	hab_rvt_entry_t *hab_rvt_entry;
 	hab_rvt_exit_t *hab_rvt_exit;
 
+#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
+	enum dcache_option option = DCACHE_WRITETHROUGH;
+#else
+	enum dcache_option option = DCACHE_WRITEBACK;
+#endif
+
+	/*
+	 * If the MMU is enabled, we have to notify the ROM code, or
+	 * it won't flush the caches when needed. This is done by
+	 * setting the "pu_irom_mmu_enabled" word to 1. You can find
+	 * its address by looking in the ROM map.
+	 *
+	 * This is critical for authenticate_image(). If MMU is enabled
+	 * without setting this bit, authentication will fail and may
+	 * crash.
+	 *
+	 * This is no longer needed in CPUs starting with i.MX6SX.
+	 */
+	if (is_mx6dq()) {
+		/* Will not work for rev 1.0.0 of the CPU */
+		writel(1, 0x009024a8);
+	} else if (is_mx6solo() || is_mx6dlsolo()) {
+		writel(1, 0x00901dd0);
+	} else if (is_mx6sl()) {
+		writel(1, 0x00900a18);
+	}
+
+	/* Enable caching on OCRAM and ROM */
+	mmu_set_region_dcache_behaviour(ROMCP_ARB_BASE_ADDR,
+					ROMCP_ARB_END_ADDR,
+					option);
+	mmu_set_region_dcache_behaviour(IRAM_BASE_ADDR,
+					IRAM_SIZE,
+					option);
+
+
 	hab_rvt_authenticate_image = hab_rvt_authenticate_image_p;
 	hab_rvt_entry = hab_rvt_entry_p;
 	hab_rvt_exit = hab_rvt_exit_p;
Index: arch/arm/cpu/armv7/mx6/Makefile
===================================================================
diff --git a/arch/arm/cpu/armv7/mx6/Makefile b/arch/arm/cpu/armv7/mx6/Makefile
--- a/arch/arm/cpu/armv7/mx6/Makefile	(revision 512)
+++ b/arch/arm/cpu/armv7/mx6/Makefile	(revision 1734)
@@ -27,10 +27,11 @@
 
 LIB	= $(obj)lib$(SOC).o
 
-COBJS	= soc.o clock.o
+COBJS-y	= soc.o clock.o
+COBJS-$(CONFIG_SPL_BUILD) += spl.o
 
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS-y))
 
 all:	$(obj).depend $(LIB)
 
Index: Makefile
===================================================================
diff --git a/Makefile b/Makefile
--- a/Makefile	(revision 512)
+++ b/Makefile	(revision 1734)
@@ -398,7 +398,7 @@
 endif
 
 # Always append ALL so that arch config.mk's can add custom ones
-ALL-y += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map
+ALL-y += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)u-boot_crc.bin $(obj)System.map
 
 ALL-$(CONFIG_NAND_U_BOOT) += $(obj)u-boot-nand.bin
 ALL-$(CONFIG_ONENAND_U_BOOT) += $(obj)u-boot-onenand.bin
@@ -436,6 +436,12 @@
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 		$(BOARD_SIZE_CHECK)
 
+$(obj)u-boot_crc.bin:	$(obj)u-boot.bin
+		@cp tools/mk_uboot_crc .
+		@./mk_uboot_crc
+		@crc32 ./u-boot_crc.bin > ./u-boot_crc.bin.crc
+		@rm -f ./mk_uboot_crc
+
 $(obj)u-boot.ldr:	$(obj)u-boot
 		$(CREATE_LDR_ENV)
 		$(LDR) -T $(CONFIG_BFIN_CPU) -c $@ $< $(LDR_FLAGS)
@@ -463,7 +469,7 @@
 			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
 		-d $< $@
 
-$(obj)u-boot.imx:	$(obj)u-boot.bin
+$(obj)u-boot.imx:	$(obj)u-boot.bin $(obj)u-boot_crc.bin
 		$(CC) -E -x c $(CONFIG_IMX_CONFIG) -I./include -o $(obj)imxcfg.imx
 		$(obj)tools/mkimage -n  $(obj)imxcfg.imx -T imximage \
 		-e $(CONFIG_SYS_TEXT_BASE) -d $< $@
@@ -812,6 +818,7 @@
 	       $(obj)tools/mk{smdk5250,}spl				  \
 	       $(obj)tools/mxsboot					  \
 	       $(obj)tools/ncb		   $(obj)tools/ubsha1		  \
+	       $(obj)tools/mk_uboot_crc                                   \
 	       $(obj)tools/kernel-doc/docproc
 	@rm -f $(obj)board/cray/L1/{bootscript.c,bootscript.image}	  \
 	       $(obj)board/matrix_vision/*/bootscript.img		  \
@@ -838,7 +845,7 @@
 
 clobber:	tidy
 	@find $(OBJTREE) -type f \( -name '*.srec' \
-		-o -name '*.bin' -o -name u-boot.img \) \
+		-o -name '*.bin' -o -name u-boot.img -o -name u-boot_crc.bin.crc \) \
 		-print0 | xargs -0 rm -f
 	@rm -f $(OBJS) $(obj)*.bak $(obj)ctags $(obj)etags $(obj)TAGS \
 		$(obj)cscope.* $(obj)*.*~
Index: drivers/mtd/spi/spi_spl_load.c
===================================================================
diff --git a/drivers/mtd/spi/spi_spl_load.c b/drivers/mtd/spi/spi_spl_load.c
--- a/drivers/mtd/spi/spi_spl_load.c	(revision 512)
+++ b/drivers/mtd/spi/spi_spl_load.c	(revision 1734)
@@ -26,6 +26,54 @@
 #include <spi_flash.h>
 #include <spl.h>
 
+#if defined(CONFIG_ADVANTECH)
+static int spl_spi_check_crc(struct spi_flash *flash)
+{
+	/* read crc file */
+	char tag[512];
+	char crc[512];
+	
+	if(spi_flash_read(flash, 2*512, 512, (void *) 0x22100000) == 0)
+	{
+		//printf("SPI Read success!\n");
+	}
+	else
+	{
+		printf("SPI Read fail!!\n");
+		return 1;
+	}
+	
+	memcpy(tag, (void *) 0x22100000, 512);
+	//tag[9] = '\0';
+	//printf("crc file %s\n", tag);
+	
+	/* make uboot crc */
+	if(spi_flash_read(flash, 3*512, 0x96000, (void *) 0x22000000) == 0)
+	{
+		//printf("SPI Read success!\n");
+	}
+	else
+	{
+		printf("SPI Read fail!!\n");
+		return 1;
+	}
+	
+	*(int *)0x21f00000 = crc32 (0, (const uchar *) 0x22000000, 0x96000);
+	sprintf(crc, "%08x", *(int *)0x21f00000);
+	//crc[9] = '\0';
+	//printf("uboot crc %s\n", crc);
+	
+	/* verrify crc */
+	if(memcmp(tag, crc, 8))
+	{
+		printf("spl: spi dev - crc error\n");
+		return 1;
+	}
+
+	return 0;
+}
+#endif
+
 /*
  * The main entry for SPI booting. It's necessary that SDRAM is already
  * configured and available since this code loads the main U-Boot image
@@ -47,6 +95,13 @@
 		hang();
 	}
 
+#if defined(CONFIG_ADVANTECH)
+	int err = spl_spi_check_crc(flash);
+	if (err) {
+		return;
+	}
+#endif
+
 	/* use CONFIG_SYS_TEXT_BASE as temporary storage area */
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
 
@@ -56,4 +111,7 @@
 	spl_parse_image_header(header);
 	spi_flash_read(flash, CONFIG_SYS_SPI_U_BOOT_OFFS,
 		       spl_image.size, (void *)spl_image.load_addr);
+
+	printf("SPI read: dev %d:%d, size %d ... \n"
+		, CONFIG_SPL_SPI_BUS, CONFIG_SPL_SPI_CS, spl_image.size);
 }
Index: drivers/mtd/spi/imx_spi_nor_m25pxx.c
===================================================================
diff --git a/drivers/mtd/spi/imx_spi_nor_m25pxx.c b/drivers/mtd/spi/imx_spi_nor_m25pxx.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/mtd/spi/imx_spi_nor_m25pxx.c	(revision 1734)
@@ -0,0 +1,564 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This code is based on drivers/mtd/devices/mxc_m25p80.c in Linux kernel.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <asm/errno.h>
+#include <linux/types.h>
+#include <malloc.h>
+
+#include <imx_spi.h>
+#include <imx_spi_nor.h>
+
+static u8 g_tx_buf[256];
+static u8 g_rx_buf[256];
+
+#define WRITE_ENABLE(a)		spi_nor_cmd_1byte(a, OPCODE_WREN)
+#define	write_enable(a)		WRITE_ENABLE(a)
+
+#define	SPI_FIFOSIZE		24
+
+struct imx_spi_flash_params {
+	u32		idcode1;
+#ifdef CONFIG_ADVANTECH
+	u32		idcode2;
+#endif
+	u32		block_size;
+	u32		block_count;
+	u32		device_size;
+	u32		page_size;
+	const char	*name;
+};
+
+struct imx_spi_flash {
+	const struct imx_spi_flash_params *params;
+	struct spi_flash flash;
+};
+
+static inline struct imx_spi_flash *
+to_imx_spi_flash(struct spi_flash *flash)
+{
+	return container_of(flash, struct imx_spi_flash, flash);
+}
+
+static const struct imx_spi_flash_params imx_spi_flash_table[] = {
+	{
+		.idcode1		= 0x20,
+#ifdef CONFIG_ADVANTECH
+		.idcode2		= 0x16,
+#endif
+		.block_size		= SZ_64K,
+		.block_count		= 64,
+		.device_size		= SZ_64K * 64,
+		.page_size		= 256,
+		.name			= "M25P32 - 4MB",
+	},
+};
+
+static s32 spi_nor_cmd_1byte(struct spi_flash *flash, u8 cmd)
+{
+	g_tx_buf[0] = cmd;
+	g_tx_buf[1] = 0;
+	g_tx_buf[2] = 0;
+	g_tx_buf[3] = 0;
+
+	if (spi_xfer(flash->spi, (1 << 3), g_tx_buf, g_rx_buf,
+			SPI_XFER_BEGIN | SPI_XFER_END) != 0) {
+		printf("Error: %s(): %d\n", __func__, __LINE__);
+		return -1;
+	}
+	return 0;
+}
+
+static s32 spi_nor_flash_query(struct spi_flash *flash, void* data)
+{
+	u8 au8Tmp[4] = { 0 };
+	u8 *pData = (u8 *)data;
+
+	g_tx_buf[3] = JEDEC_ID;
+
+	if (spi_xfer(flash->spi, (4 << 3), g_tx_buf, au8Tmp,
+				SPI_XFER_BEGIN | SPI_XFER_END)) {
+		return -1;
+	}
+
+	
+
+	printf("JEDEC ID: 0x%02x:0x%02x:0x%02x\n",
+			au8Tmp[2], au8Tmp[1], au8Tmp[0]);
+
+	pData[0] = au8Tmp[2];
+	pData[1] = au8Tmp[1];
+	pData[2] = au8Tmp[0];
+
+	return 0;
+}
+
+static s32 spi_nor_status(struct spi_flash *flash)
+{
+	g_tx_buf[1] = OPCODE_RDSR;
+
+	if (spi_xfer(flash->spi, 2 << 3, g_tx_buf, g_rx_buf,
+			SPI_XFER_BEGIN | SPI_XFER_END) != 0) {
+		printf("Error: %s(): %d\n", __func__, __LINE__);
+		return 0;
+	}
+	return g_rx_buf[0];
+}
+
+static int wait_till_ready(struct spi_flash *flash)
+{
+	int sr;
+	int times = 10000;
+
+	do {
+		sr = spi_nor_status(flash);
+		if (sr < 0)
+			break;
+		else if (!(sr & SR_WIP))
+			return 0;
+
+		udelay(1000);
+
+	} while (times--);
+
+	return 1;
+}
+
+#ifdef DEBUG
+static int erase_chip(struct spi_flash *flash)
+{
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return 1;
+
+	/* Send write enable, then erase commands. */
+	WRITE_ENABLE(flash);
+
+	/* Set up command buffer. */
+	g_tx_buf[3] = OPCODE_CHIP_ERASE;
+
+	if (spi_xfer(flash->spi, (4 << 3), g_tx_buf, g_rx_buf,
+				SPI_XFER_BEGIN | SPI_XFER_END)) {
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
+static int erase_sector(struct spi_flash *flash, u32 offset)
+{
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return 1;
+
+	/* Send write enable, then erase commands. */
+	WRITE_ENABLE(flash);
+
+	/* Set up command buffer. */
+	g_tx_buf[3] = OPCODE_SE;
+	g_tx_buf[2] = offset >> 16;
+	g_tx_buf[1] = offset >> 8;
+	g_tx_buf[0] = offset;
+
+	if (spi_xfer(flash->spi, (4 << 3), g_tx_buf, g_rx_buf,
+				SPI_XFER_BEGIN | SPI_XFER_END)) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int spi_nor_flash_read(struct spi_flash *flash, u32 from,
+		size_t len, void *buf)
+{
+	struct imx_spi_flash *imx_sf = to_imx_spi_flash(flash);
+	int rx_len = 0, count = 0, i = 0;
+	int addr, cmd_len;
+	u8 txer[SPI_FIFOSIZE] = { 0 };
+	u8 *s = txer;
+	u8 *d = buf;
+
+	debug("%s: %s 0x%08x, len %zd\n", __func__, "from", (u32)from, len);
+
+	/* sanity checks */
+	if (!len)
+		return 0;
+
+	if (from + len > imx_sf->params->device_size)
+		return -EINVAL;
+
+	/* Wait till previous write/erase is done. */
+	if (wait_till_ready(flash)) {
+		/* REVISIT status return?? */
+		return 1;
+	}
+
+	cmd_len = 4;
+
+	addr = from;
+
+	while (len > 0) {
+
+		rx_len = len > (SPI_FIFOSIZE - cmd_len) ?
+		    SPI_FIFOSIZE - cmd_len : len;
+
+		/* Set up the write data buffer. */
+		txer[3] = OPCODE_NORM_READ;
+		txer[2] = addr >> 16;
+		txer[1] = addr >> 8;
+		txer[0] = addr;
+
+		if (spi_xfer(flash->spi, (roundup(rx_len, 4) + cmd_len) << 3,
+			txer, txer,
+			SPI_XFER_BEGIN | SPI_XFER_END) != 0) {
+			printf("Error: %s(%d): failed\n",
+				__FILE__, __LINE__);
+			return -1;
+		}
+
+		s = txer + cmd_len;
+
+		for (i = rx_len; i >= 0; i -= 4, s += 4) {
+			if (i < 4) {
+				if (i == 1) {
+					*d = s[3];
+				} else if (i == 2) {
+					*d++ = s[3];
+					*d++ = s[2];
+				} else if (i == 3) {
+					*d++ = s[3];
+					*d++ = s[2];
+					*d++ = s[1];
+				}
+
+				break;
+			}
+
+			*d++ = s[3];
+			*d++ = s[2];
+			*d++ = s[1];
+			*d++ = s[0];
+		}
+
+		/* updaate */
+		len -= rx_len;
+		addr += rx_len;
+		count += rx_len;
+
+		debug("%s: left:0x%x, from:0x%08x, to:0x%p, done: 0x%x\n",
+		      __func__, len, (u32) addr, d, count);
+	}
+
+	return 0;
+}
+
+static int _fsl_spi_write(struct spi_flash *flash, const void *buf, int len, int addr)
+{
+	u8 txer[SPI_FIFOSIZE] = { 0 };
+	u8 *d = txer;
+	u8 *s = (u8 *) buf;
+	int delta = 0, l = 0, i = 0, count = 0;
+
+	count = len;
+	delta = count % 4;
+	if (delta)
+		count -= delta;
+
+	while (count) {
+		d = txer;
+		l = count > (SPI_FIFOSIZE - 4) ?
+		    SPI_FIFOSIZE - 4 : count;
+
+		d[3] = OPCODE_PP;
+		d[2] = addr >> 16;
+		d[1] = addr >> 8;
+		d[0] = addr;
+
+		for (i = 0, d += 4; i < l / 4; i++, d += 4) {
+			d[3] = *s++;
+			d[2] = *s++;
+			d[1] = *s++;
+			d[0] = *s++;
+		}
+
+		debug("WRITEBUF: (%x) %x %x %x\n",
+		      txer[3], txer[2], txer[1], txer[0]);
+
+		wait_till_ready(flash);
+
+		write_enable(flash);
+
+		if (spi_xfer(flash->spi, (l + 4) << 3,
+				txer, txer,
+				SPI_XFER_BEGIN | SPI_XFER_END) != 0) {
+			printf("Error: %s(%d): failed\n",
+				__FILE__, __LINE__);
+			return -1;
+		}
+
+		/* update */
+		count -= l;
+		addr += l;
+	}
+
+	if (delta) {
+		d = txer;
+		/* to keep uninterested bytes untouched */
+		for (i = 4; i < 8; i++)
+			d[i] = 0xff;
+
+		d[3] = OPCODE_PP;
+		d[2] = (addr >> 16) & 0xff;
+		d[1] = (addr >> 8) & 0xff;
+		d[0] = (addr) & 0xff;
+
+		switch (delta) {
+		case 1:
+			d[7] = *s++;
+			break;
+		case 2:
+			d[7] = *s++;
+			d[6] = *s++;
+			break;
+		case 3:
+			d[7] = *s++;
+			d[6] = *s++;
+			d[5] = *s++;
+			break;
+		default:
+			break;
+		}
+
+		debug("WRITEBUF: (%x) %x %x %x\n",
+		      txer[3], txer[2], txer[1], txer[0]);
+
+		wait_till_ready(flash);
+
+		write_enable(flash);
+
+		if (spi_xfer(flash->spi, (4 + 4) << 3,
+				txer, txer,
+				SPI_XFER_BEGIN | SPI_XFER_END) != 0) {
+			printf("Error: %s(%d): failed\n",
+				__FILE__, __LINE__);
+			return -1;
+		}
+	}
+
+	return len;
+}
+
+static int spi_nor_flash_write(struct spi_flash *flash, u32 to,
+		size_t len, const void *buf)
+{
+	struct imx_spi_flash *imx_sf = to_imx_spi_flash(flash);
+	u32 page_offset, page_size;
+
+	/* sanity checks */
+	if (!len)
+		return 0;
+
+	if (to + len > imx_sf->params->device_size)
+		return -EINVAL;
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return 1;
+
+	write_enable(flash);
+
+	page_offset = to & (imx_sf->params->page_size - 1);
+
+	/* do all the bytes fit onto one page? */
+	if (page_offset + len <= imx_sf->params->page_size) {
+		_fsl_spi_write(flash, buf, len, to);
+
+	} else {
+		u32 i;
+
+		/* the size of data remaining on the first page */
+		page_size = imx_sf->params->page_size - page_offset;
+
+		_fsl_spi_write(flash, buf, page_size, to);
+
+		/* write everything in flash->page_size chunks */
+		for (i = page_size; i < len; i += page_size) {
+			page_size = len - i;
+			if (page_size > imx_sf->params->page_size)
+				page_size = imx_sf->params->page_size;
+
+			wait_till_ready(flash);
+
+			write_enable(flash);
+
+			_fsl_spi_write(flash, buf + i, page_size, to + i);
+			if (page_size % imx_sf->params->page_size == 0)
+				printf(".");
+		}
+	}
+
+	printf("SUCCESS\n\n");
+
+	return 0;
+}
+
+static int spi_nor_flash_erase(struct spi_flash *flash, u32 offset,
+		size_t len)
+{
+	struct imx_spi_flash *imx_sf = to_imx_spi_flash(flash);
+
+	/* whole-chip erase? */
+	/*
+	if (len == imx_sf->params->device_size) {
+		if (erase_chip(flash))
+			return -EIO;
+		else
+			return 0;
+	*/
+
+	/* REVISIT in some cases we could speed up erasing large regions
+	 * by using OPCODE_SE instead of OPCODE_BE_4K.  We may have set up
+	 * to use "small sector erase", but that's not always optimal.
+	 */
+
+	/* "sector"-at-a-time erase */
+	len = roundup(len, imx_sf->params->block_size);
+	while (len) {
+		if (erase_sector(flash, offset))
+			return -EIO;
+
+		offset += imx_sf->params->block_size;
+		len -= imx_sf->params->block_size;
+	}
+
+	return 0;
+}
+
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs, unsigned int max_hz, unsigned int spi_mode)
+{
+	struct spi_slave *spi = NULL;
+	const struct imx_spi_flash_params *params = NULL;
+	struct imx_spi_flash *imx_sf = NULL;
+	u8  idcode[4] = { 0 };
+	u32 i = 0;
+	s32 ret = 0;
+
+	if (CONFIG_SPI_FLASH_CS != cs) {
+		printf("Invalid cs for SPI NOR.\n");
+		return NULL;
+	}
+
+	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
+
+	if (!spi) {
+		debug("SF: Failed to set up slave\n");
+		return NULL;
+	}
+
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("SF: Failed to claim SPI bus: %d\n", ret);
+		goto err_claim_bus;
+	}
+
+	imx_sf = (struct imx_spi_flash *)malloc(sizeof(struct imx_spi_flash));
+
+	if (!imx_sf) {
+		debug("SF: Failed to allocate memory\n");
+		spi_free_slave(spi);
+		return NULL;
+	}
+
+	imx_sf->flash.spi = spi;
+
+	/* Read the ID codes */
+	ret = spi_nor_flash_query(&(imx_sf->flash), idcode);
+	if (ret)
+		goto err_read_id;
+
+	for (i = 0; i < ARRAY_SIZE(imx_spi_flash_table); ++i) {
+		params = &imx_spi_flash_table[i];
+#if defined CONFIG_ADVANTECH
+		if (params->idcode1 == idcode[0] && params->idcode2 == idcode[2])
+#else
+		if (params->idcode1 == idcode[1])
+#endif
+			break;
+	}
+
+	if (i == ARRAY_SIZE(imx_spi_flash_table)) {
+		//debug("SF: Unsupported DataFlash ID %02x\n",
+		printf("SF: Unsupported DataFlash ID %02x\n",
+				idcode[1]);
+
+		goto err_invalid_dev;
+	}
+
+	imx_sf->params = params;
+
+	imx_sf->flash.name = params->name;
+	imx_sf->flash.size = params->device_size;
+
+	imx_sf->flash.read  = spi_nor_flash_read;
+	imx_sf->flash.write = spi_nor_flash_write;
+	imx_sf->flash.erase = spi_nor_flash_erase;
+
+	debug("SF: Detected %s with block size %lu, "
+			"block count %lu, total %u bytes\n",
+			params->name,
+			params->block_size,
+			params->block_count,
+			params->device_size);
+
+	return &(imx_sf->flash);
+
+err_read_id:
+	spi_release_bus(spi);
+err_invalid_dev:
+	if (imx_sf)
+		free(imx_sf);
+err_claim_bus:
+	if (spi)
+		spi_free_slave(spi);
+
+	return NULL;
+}
+
+void spi_flash_free(struct spi_flash *flash)
+{
+	struct imx_spi_flash *imx_sf = NULL;
+
+	if (!flash)
+		return;
+
+	imx_sf = to_imx_spi_flash(flash);
+
+	if (flash->spi) {
+		spi_free_slave(flash->spi);
+		flash->spi = NULL;
+	}
+
+	free(imx_sf);
+}
Index: drivers/mtd/spi/Makefile
===================================================================
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
--- a/drivers/mtd/spi/Makefile	(revision 512)
+++ b/drivers/mtd/spi/Makefile	(revision 1734)
@@ -39,6 +39,7 @@
 COBJS-$(CONFIG_SPI_FLASH_WINBOND)	+= winbond.o
 COBJS-$(CONFIG_SPI_FRAM_RAMTRON)	+= ramtron.o
 COBJS-$(CONFIG_SPI_M95XXX) += eeprom_m95xxx.o
+COBJS-$(CONFIG_SPI_FLASH_IMX_M25PXX)	+= imx_spi_nor_m25pxx.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
Index: drivers/block/dwc_ahsata.c
===================================================================
diff --git a/drivers/block/dwc_ahsata.c b/drivers/block/dwc_ahsata.c
--- a/drivers/block/dwc_ahsata.c	(revision 512)
+++ b/drivers/block/dwc_ahsata.c	(revision 1734)
@@ -365,8 +365,9 @@
 	if (rc)
 		goto err_out;
 
+#ifndef CONFIG_SPL_BUILD
 	ahci_print_info(probe_ent);
-
+#endif
 	/* Save the private struct to block device struct */
 	sata_dev_desc[pdev].priv = (void *)probe_ent;
 
@@ -962,8 +963,9 @@
 
 	free((void *)id);
 
+#ifndef CONFIG_SPL_BUILD
 	dwc_ahsata_print_info(dev);
-
+#endif
 	is_ready = 1;
 
 	return 0;
Index: drivers/block/spl_sata.c
===================================================================
diff --git a/drivers/block/spl_sata.c b/drivers/block/spl_sata.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/block/spl_sata.c	(revision 1734)
@@ -0,0 +1,126 @@
+/*
+ * (C) Copyright 2014 Advantech Co. <risc-sw@advantech.com.tw>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <spl.h>
+#include <asm/u-boot.h>
+#include <asm/utils.h>
+#include <sata.h>
+#include <libata.h>
+#include <version.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int spl_sata_check_crc(unsigned int dev)
+{
+	u32 n;
+	/* read crc file */
+	char tag[512];
+	char crc[512];
+	
+	n = sata_read(dev, 0x02, 1, (void *) 0x22100000);
+	if(n != 1)
+		return 1;
+	
+	memcpy(tag, (void *) 0x22100000, 512);
+	//tag[9] = '\0';
+	//printf("crc file %s\n", tag);
+	
+	/* make uboot crc */
+	n = sata_read(dev, 0x03, 0x4b0, (void *) 0x22000000);
+	if(n != 0x4b0)
+		return 1;
+	
+	*(int *)0x21f00000 = crc32 (0, (const uchar *) 0x22000000, 0x96000);
+	sprintf(crc, "%08x", *(int *)0x21f00000);
+	//crc[9] = '\0';
+	//printf("uboot crc %s\n", crc);
+	
+	/* verrify crc */
+	if(memcmp(tag, crc, 8))
+	{
+		printf("spl: sata dev %d - crc error\n", dev);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int sata_load_image_raw(unsigned int dev)
+{
+	u32 image_size_sectors, err;
+	const struct image_header *header;
+
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+
+	/* read image header to find the image size & load address */
+	err = sata_read(dev,
+			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR, 1,
+			(void *)header);
+
+	if (err <= 0)
+		goto end;
+
+	spl_parse_image_header(header);
+
+	/* convert size to sectors - round up */
+	image_size_sectors = (spl_image.size + ATA_SECT_SIZE - 1) /
+				ATA_SECT_SIZE;
+
+	/* Read the header too to avoid extra memcpy */
+	err = sata_read(dev,
+			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR,
+			image_size_sectors, (void *)spl_image.load_addr);
+
+	printf("SATA read: dev # %d block # %d, count %d ... ",
+		dev, CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR, image_size_sectors);
+end:
+	if (err <= 0) {
+		printf("spl: sata blk read err - %d\n", err);
+		return 1;
+	} else
+		return 0;
+}
+
+int spl_sata_load_image(unsigned int dev)
+{
+	block_dev_desc_t *sata_dev_desc;
+	int err;
+
+	if (sata_initialize()) {
+		printf("spl: sata_initialize failed\n");
+		return 1;
+	}
+
+	sata_dev_desc = sata_get_dev(dev);
+	if (!sata_dev_desc) {
+		printf("spl: cannot find sata dev %d\n", dev);
+		return 1;
+	}
+
+	err = spl_sata_check_crc(dev);
+	if (err) {
+		return 1;
+	}
+
+	return sata_load_image_raw(dev);
+}
Index: drivers/block/Makefile
===================================================================
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
--- a/drivers/block/Makefile	(revision 512)
+++ b/drivers/block/Makefile	(revision 1734)
@@ -25,6 +25,10 @@
 
 LIB	:= $(obj)libblock.o
 
+ifdef CONFIG_SPL_BUILD
+COBJS-$(CONFIG_SPL_SATA_SUPPORT) += spl_sata.o
+endif
+
 COBJS-$(CONFIG_SCSI_AHCI) += ahci.o
 COBJS-$(CONFIG_ATA_PIIX) += ata_piix.o
 COBJS-$(CONFIG_DWC_AHSATA) += dwc_ahsata.o
Index: drivers/spi/Makefile
===================================================================
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
--- a/drivers/spi/Makefile	(revision 512)
+++ b/drivers/spi/Makefile	(revision 1734)
@@ -55,6 +55,7 @@
 COBJS-$(CONFIG_TEGRA20_SLINK) += tegra20_slink.o
 COBJS-$(CONFIG_TEGRA114_SPI) += tegra114_spi.o
 COBJS-$(CONFIG_XILINX_SPI) += xilinx_spi.o
+COBJS-$(CONFIG_IMX_ECSPI) += imx_ecspi.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
Index: drivers/spi/imx_ecspi.c
===================================================================
diff --git a/drivers/spi/imx_ecspi.c b/drivers/spi/imx_ecspi.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/spi/imx_ecspi.c	(revision 1734)
@@ -0,0 +1,305 @@
+/*
+ * (C) Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <spi.h>
+#include <asm/errno.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <malloc.h>
+
+#include <imx_spi.h>
+#include <asm/arch/clock.h>
+
+#ifdef	DEBUG
+
+/* -----------------------------------------------
+ * Helper functions to peek into tx and rx buffers
+ * ----------------------------------------------- */
+static const char * const hex_digit = "0123456789ABCDEF";
+
+static char quickhex(int i)
+{
+	return hex_digit[i];
+}
+
+static void memdump(const void *pv, int num)
+{
+
+}
+
+#else /* !DEBUG */
+
+#define	memdump(p, n)
+
+#endif /* DEBUG */
+
+extern s32 spi_get_cfg(struct imx_spi_dev_t *dev);
+
+static inline struct imx_spi_dev_t *to_imx_spi_slave(struct spi_slave *slave)
+{
+	return container_of(slave, struct imx_spi_dev_t, slave);
+}
+
+static s32 spi_reset(struct spi_slave *slave)
+{
+	u32 clk_src = mxc_get_clock(MXC_CSPI_CLK);
+	s32 pre_div = 0, post_div = 0, i, reg_ctrl, reg_config;
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+	struct spi_reg_t *reg = &(dev->reg);
+
+	if (dev->freq == 0) {
+		printf("Error: desired clock is 0\n");
+		return 1;
+	}
+
+	reg_ctrl = readl(dev->base + SPI_CON_REG);
+	/* Reset spi */
+	writel(0, dev->base + SPI_CON_REG);
+	writel((reg_ctrl | 0x1), dev->base + SPI_CON_REG);
+
+	/* Control register setup */
+	if (clk_src > dev->freq) {
+		pre_div = clk_src / dev->freq;
+		if (pre_div > 16) {
+			post_div = pre_div / 16;
+			pre_div = 15;
+		}
+		if (post_div != 0) {
+			for (i = 0; i < 16; i++) {
+				if ((1 << i) >= post_div)
+					break;
+			}
+			if (i == 16) {
+				printf("Error: no divider can meet the freq: %d\n",
+					dev->freq);
+				return -1;
+			}
+			post_div = i;
+		}
+	}
+
+	debug("pre_div = %d, post_div=%d\n", pre_div, post_div);
+	reg_ctrl = (reg_ctrl & ~(3 << 18)) | dev->ss << 18;
+	reg_ctrl = (reg_ctrl & ~(0xF << 12)) | pre_div << 12;
+	reg_ctrl = (reg_ctrl & ~(0xF << 8)) | post_div << 8;
+	reg_ctrl |= 1 << (dev->ss + 4);	/* always set to master mode !!!! */
+	reg_ctrl &= ~0x1;		/* disable spi */
+
+	reg_config = readl(dev->base + SPI_CFG_REG);
+	/* configuration register setup */
+	reg_config = (reg_config & ~(1 << ((dev->ss + 12)))) |
+		(dev->ss_pol << (dev->ss + 12));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 20)))) |
+		(dev->in_sctl << (dev->ss + 20));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 16)))) |
+		(dev->in_dctl << (dev->ss + 16));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 8)))) |
+		(dev->ssctl << (dev->ss + 8));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 4)))) |
+		(dev->sclkpol << (dev->ss + 4));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 0)))) |
+		(dev->sclkpha << (dev->ss + 0));
+
+	debug("reg_ctrl = 0x%x\n", reg_ctrl);
+	writel(reg_ctrl, dev->base + SPI_CON_REG);
+	debug("reg_config = 0x%x\n", reg_config);
+	writel(reg_config, dev->base + SPI_CFG_REG);
+
+	/* save config register and control register */
+	reg->cfg_reg  = reg_config;
+	reg->ctrl_reg = reg_ctrl;
+
+	/* clear interrupt reg */
+	writel(0, dev->base + SPI_INT_REG);
+	writel(3 << 6, dev->base + SPI_STAT_REG);
+
+	return 0;
+}
+
+void spi_init(void)
+{
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct imx_spi_dev_t *imx_spi_slave = NULL;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	imx_spi_slave = (struct imx_spi_dev_t *)malloc(sizeof(struct imx_spi_dev_t));
+	if (!imx_spi_slave)
+		return NULL;
+
+	memset(imx_spi_slave, 0, sizeof(struct imx_spi_dev_t));
+
+	imx_spi_slave->slave.bus = bus;
+	imx_spi_slave->slave.cs = cs;
+
+	spi_get_cfg(imx_spi_slave);
+
+	spi_io_init(imx_spi_slave);
+
+	spi_reset(&(imx_spi_slave->slave));
+
+	return &(imx_spi_slave->slave);
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *imx_spi_slave;
+
+	if (slave) {
+		imx_spi_slave = to_imx_spi_slave(slave);
+		free(imx_spi_slave);
+	}
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+
+}
+
+/*
+ * SPI transfer:
+ *
+ * See include/spi.h and http://www.altera.com/literature/ds/ds_nios_spi.pdf
+ * for more informations.
+ */
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	s32 val = SPI_RETRY_TIMES;
+	u32 *p_buf;
+	u32 reg;
+	s32 len = 0,
+		ret_val = 0;
+	s32 burst_bytes = bitlen >> 3;
+	s32 tmp = 0;
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+	struct spi_reg_t *spi_reg = &(dev->reg);
+
+	if (!slave)
+		return -1;
+
+	if (burst_bytes > (MAX_SPI_BYTES)) {
+		printf("Error: maximum burst size is 0x%x bytes, asking 0x%x\n",
+				MAX_SPI_BYTES, burst_bytes);
+		return -1;
+	}
+
+	if (flags & SPI_XFER_BEGIN) {
+		spi_cs_activate(slave);
+
+		if (spi_reg->ctrl_reg == 0) {
+			printf("Error: spi(base=0x%x) has not been initialized yet\n",
+					dev->base);
+			return -1;
+		}
+		spi_reg->ctrl_reg = (spi_reg->ctrl_reg & ~0xFFF00000) | \
+					((burst_bytes * 8 - 1) << 20);
+
+		writel(spi_reg->ctrl_reg | 0x1, dev->base + SPI_CON_REG);
+		writel(spi_reg->cfg_reg, dev->base + SPI_CFG_REG);
+		debug("ctrl_reg=0x%x, cfg_reg=0x%x\n",
+					 readl(dev->base + SPI_CON_REG),
+					 readl(dev->base + SPI_CFG_REG));
+
+		/* move data to the tx fifo */
+		if (dout) {
+			for (p_buf = (u32 *)dout, len = burst_bytes; len > 0;
+				p_buf++, len -= 4)
+				writel(*p_buf, dev->base + SPI_TX_DATA);
+		} else {
+			for (len = burst_bytes; len > 0; len -= 4)
+				writel(tmp, dev->base + SPI_TX_DATA);
+		}
+
+		reg = readl(dev->base + SPI_CON_REG);
+		reg |= (1 << 2); /* set xch bit */
+		debug("control reg = 0x%08x\n", reg);
+		writel(reg, dev->base + SPI_CON_REG);
+
+		/* poll on the TC bit (transfer complete) */
+		while ((val-- > 0) &&
+			(readl(dev->base + SPI_STAT_REG) & (1 << 7)) == 0) {
+			udelay(100);
+		}
+
+		/* clear the TC bit */
+		writel(3 << 6, dev->base + SPI_STAT_REG);
+		if (val <= 0) {
+			printf("Error: re-tried %d times without response. Give up\n",
+					SPI_RETRY_TIMES);
+			ret_val = -1;
+			goto error;
+		}
+	}
+
+	/* move data in the rx buf */
+	if (flags & SPI_XFER_END) {
+		if (din) {
+			for (p_buf = (u32 *)din, len = burst_bytes; len > 0;
+				++p_buf, len -= 4)
+				*p_buf = readl(dev->base + SPI_RX_DATA);
+		} else {
+			for (len = burst_bytes; len > 0; len -= 4)
+				tmp = readl(dev->base + SPI_RX_DATA);
+		}
+
+		spi_cs_deactivate(slave);
+	}
+
+	return ret_val;
+
+error:
+	spi_cs_deactivate(slave);
+	return ret_val;
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return 1;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+
+	spi_io_init(dev);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+
+	writel(0, dev->base + SPI_CON_REG);
+}
+
Index: drivers/mmc/spl_mmc_advantech.c
===================================================================
diff --git a/drivers/mmc/spl_mmc_advantech.c b/drivers/mmc/spl_mmc_advantech.c
new file mode 10644
--- /dev/null	(revision 0)
+++ b/drivers/mmc/spl_mmc_advantech.c	(revision 1734)
@@ -0,0 +1,182 @@
+/*
+ * (C) Copyright 2014 Advantech Co. <risc-sw@advantech.com.tw>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <spl.h>
+#include <asm/u-boot.h>
+#include <asm/utils.h>
+#include <mmc.h>
+#include <fat.h>
+#include <version.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int spl_mmc_check_crc(unsigned int dev, struct mmc *mmc)
+{
+#ifdef CONFIG_SPL_FAT_SUPPORT
+	/* Needs to implement later */
+#else
+	u32 n;
+	/* read crc file */
+	char tag[512];
+	char crc[512];
+	
+	n = mmc->block_dev.block_read(dev, 0x02, 1, (void *) 0x22100000);
+	if(n != 1)
+		return 1;
+	
+	memcpy(tag, (void *) 0x22100000, 512);
+	//tag[9] = '\0';
+	//printf("crc file %s\n", tag);
+	
+	/* make uboot crc */
+	n = mmc->block_dev.block_read(dev, 0x03, 0x4b0, (void *) 0x22000000);
+	if(n != 0x4b0)
+		return 1;
+	
+	*(int *)0x21f00000 = crc32 (0, (const uchar *) 0x22000000, 0x96000);
+	sprintf(crc, "%08x", *(int *)0x21f00000);
+	//crc[9] = '\0';
+	//printf("uboot crc %s\n", crc);
+	
+	/* verrify crc */
+	if(memcmp(tag, crc, 8))
+	{
+		printf("spl: mmc dev %d - crc error\n", dev);
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+static int mmc_load_image_raw(unsigned int dev, struct mmc *mmc)
+{
+	u32 image_size_sectors, err;
+	const struct image_header *header;
+
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+
+	/* read image header to find the image size & load address */
+	err = mmc->block_dev.block_read(dev,
+			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR, 1,
+			(void *)header);
+			
+	if (err <= 0)
+		goto end;
+
+	spl_parse_image_header(header);
+
+	/* convert size to sectors - round up */
+	image_size_sectors = (spl_image.size + mmc->read_bl_len - 1) /
+				mmc->read_bl_len;
+
+	/* Read the header too to avoid extra memcpy */
+	err = mmc->block_dev.block_read(dev,
+			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR,
+			image_size_sectors, (void *)spl_image.load_addr);
+
+	printf("MMC read: dev # %d, block # %d,""count %d ... \n",
+		dev, CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR, image_size_sectors);
+end:
+	if (err <= 0) {
+		printf("spl: mmc blk read err - %d\n", err);
+		return 1;
+	} else
+		return 0;
+}
+
+#ifdef CONFIG_SPL_FAT_SUPPORT
+static int mmc_load_image_fat(struct mmc *mmc)
+{
+	s32 err;
+	struct image_header *header;
+
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+
+	err = fat_register_device(&mmc->block_dev,
+				CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION);
+	if (err) {
+		printf("spl: fat register err - %d\n", err);
+		return 1;
+	}
+
+	err = file_fat_read(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME,
+				(u8 *)header, sizeof(struct image_header));
+	if (err <= 0)
+		goto end;
+
+	spl_parse_image_header(header);
+
+	err = file_fat_read(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME,
+				(u8 *)spl_image.load_addr, 0);
+
+end:
+	if (err <= 0) {
+		printf("spl: error reading image %s, err - %d\n",
+			CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME, err);
+		return 1;
+	} else
+		return 0;
+}
+#endif
+
+int spl_mmc_load_image(unsigned int dev)
+{
+	struct mmc *mmc;
+	int err;
+	u32 boot_mode;
+
+	mmc_initialize(gd->bd);
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc) {
+		puts("spl: mmc device not found!!\n");
+		return 1;
+	}
+
+	err = mmc_init(mmc);
+	if (err) {
+		printf("spl: mmc dev %d init failed\n", dev);
+		return 1;
+	}
+
+	err = spl_mmc_check_crc(dev, mmc);
+	if (err) {
+		return 1;
+	}
+
+	boot_mode = spl_boot_mode();
+	if (boot_mode == MMCSD_MODE_RAW) {
+		debug("boot mode - RAW\n");
+		return mmc_load_image_raw(dev, mmc);
+#ifdef CONFIG_SPL_FAT_SUPPORT
+	} else if (boot_mode == MMCSD_MODE_FAT) {
+		debug("boot mode - FAT\n");
+		return mmc_load_image_fat(mmc);
+#endif
+	} else {
+		puts("spl: wrong MMC boot mode\n");
+		return 1;
+	}
+}
Index: drivers/mmc/mmc.c
===================================================================
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
--- a/drivers/mmc/mmc.c	(revision 512)
+++ b/drivers/mmc/mmc.c	(revision 1734)
@@ -1282,6 +1282,9 @@
 		return NO_CARD_ERR;
 	}
 
+#ifdef CONFIG_SPL_BUILD
+mmc->has_init = 0;
+#endif
 	if (mmc->has_init)
 		return 0;
 
@@ -1368,7 +1371,8 @@
 	if (board_mmc_init(bis) < 0)
 		cpu_mmc_init(bis);
 
+#ifndef CONFIG_SPL_BUILD
 	print_mmc_devices(',');
-
+#endif
 	return 0;
 }
Index: drivers/mmc/fsl_esdhc.c
===================================================================
diff --git a/drivers/mmc/fsl_esdhc.c b/drivers/mmc/fsl_esdhc.c
--- a/drivers/mmc/fsl_esdhc.c	(revision 512)
+++ b/drivers/mmc/fsl_esdhc.c	(revision 1734)
@@ -607,7 +607,14 @@
 		mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
 
 	mmc->f_min = 400000;
+
+#ifdef CONFIG_ADVANTECH
+#ifdef CONFIG_MMC_CLOCK_DOWNGRADE
+	mmc->f_max = MIN(gd->arch.sdhc_clk, 25000000);
+#else
 	mmc->f_max = MIN(gd->arch.sdhc_clk, 52000000);
+#endif
+#endif
 
 	mmc->b_max = 0;
 	mmc_register(mmc);
Index: drivers/mmc/Makefile
===================================================================
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
--- a/drivers/mmc/Makefile	(revision 512)
+++ b/drivers/mmc/Makefile	(revision 1734)
@@ -26,8 +26,12 @@
 LIB	:= $(obj)libmmc.o
 
 ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_ADVANTECH
+COBJS-$(CONFIG_SPL_MMC_SUPPORT) += spl_mmc_advantech.o
+else
 COBJS-$(CONFIG_SPL_MMC_SUPPORT) += spl_mmc.o
 endif
+endif
 
 COBJS-$(CONFIG_BFIN_SDH) += bfin_sdh.o
 COBJS-$(CONFIG_DAVINCI_MMC) += davinci_mmc.o
